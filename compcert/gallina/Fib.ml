open Printf

type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f

type unit0 =
| Tt

type bool =
| True
| False

(** val xorb : bool -> bool -> bool **)

let xorb b1 b2 =
  match b1 with
  | True ->
    (match b2 with
     | True -> False
     | False -> True)
  | False -> b2

(** val negb : bool -> bool **)

let negb = function
| True -> False
| False -> True

type nat =
| O
| S of nat

type 'a option =
| Some of 'a
| None

type ('a, 'b) sum =
| Inl of 'a
| Inr of 'b

type ('a, 'b) prod =
| Pair of 'a * 'b

(** val fst : ('a1, 'a2) prod -> 'a1 **)

let fst = function
| Pair (x, y) -> x

(** val snd : ('a1, 'a2) prod -> 'a2 **)

let snd = function
| Pair (x, y) -> y

type 'a list =
| Nil
| Cons of 'a * 'a list

(** val length : 'a1 list -> nat **)

let rec length = function
| Nil -> O
| Cons (y, l') -> S (length l')

(** val app : 'a1 list -> 'a1 list -> 'a1 list **)

let rec app l m0 =
  match l with
  | Nil -> m0
  | Cons (a, l1) -> Cons (a, (app l1 m0))

type comparison =
| Eq
| Lt
| Gt

(** val compOpp : comparison -> comparison **)

let compOpp = function
| Eq -> Eq
| Lt -> Gt
| Gt -> Lt

type compareSpecT =
| CompEqT
| CompLtT
| CompGtT

(** val compareSpec2Type : comparison -> compareSpecT **)

let compareSpec2Type = function
| Eq -> CompEqT
| Lt -> CompLtT
| Gt -> CompGtT

type 'a compSpecT = compareSpecT

(** val compSpec2Type : 'a1 -> 'a1 -> comparison -> 'a1 compSpecT **)

let compSpec2Type x y c =
  compareSpec2Type c

type 'a sig0 =
  'a
  (* singleton inductive, whose constructor was exist *)

type 'a sig2 =
  'a
  (* singleton inductive, whose constructor was exist2 *)

type sumbool =
| Left
| Right

type 'a sumor =
| Inleft of 'a
| Inright

type 'a exc = 'a option

(** val value : 'a1 -> 'a1 option **)

let value x =
  Some x

(** val error : 'a1 option **)

let error =
  None

(** val plus : nat -> nat -> nat **)

let rec plus n0 m0 =
  match n0 with
  | O -> m0
  | S p -> S (plus p m0)

(** val max : nat -> nat -> nat **)

let rec max n0 m0 =
  match n0 with
  | O -> m0
  | S n' ->
    (match m0 with
     | O -> n0
     | S m' -> S (max n' m'))

(** val min : nat -> nat -> nat **)

let rec min n0 m0 =
  match n0 with
  | O -> O
  | S n' ->
    (match m0 with
     | O -> O
     | S m' -> S (min n' m'))

(** val nat_iter : nat -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)

let rec nat_iter n0 f x =
  match n0 with
  | O -> x
  | S n' -> f (nat_iter n' f x)

(** val le_lt_dec : nat -> nat -> sumbool **)

let rec le_lt_dec n0 m0 =
  match n0 with
  | O -> Left
  | S n1 ->
    (match m0 with
     | O -> Right
     | S m1 -> le_lt_dec n1 m1)

(** val le_gt_dec : nat -> nat -> sumbool **)

let le_gt_dec n0 m0 =
  le_lt_dec n0 m0

(** val beq_nat : nat -> nat -> bool **)

let rec beq_nat n0 m0 =
  match n0 with
  | O ->
    (match m0 with
     | O -> True
     | S n1 -> False)
  | S n1 ->
    (match m0 with
     | O -> False
     | S m1 -> beq_nat n1 m1)

type positive =
| XI of positive
| XO of positive
| XH

type n =
| N0
| Npos of positive

type z =
| Z0
| Zpos of positive
| Zneg of positive

(** val bool_dec : bool -> bool -> sumbool **)

let bool_dec b1 b2 =
  match b1 with
  | True ->
    (match b2 with
     | True -> Left
     | False -> Right)
  | False ->
    (match b2 with
     | True -> Right
     | False -> Left)

(** val eqb : bool -> bool -> bool **)

let eqb b1 b2 =
  match b1 with
  | True -> b2
  | False ->
    (match b2 with
     | True -> False
     | False -> True)

type reflect =
| ReflectT
| ReflectF

(** val iff_reflect : bool -> reflect **)

let iff_reflect = function
| True -> ReflectT
| False -> ReflectF

module type DecidableTypeOrig = 
 sig 
  type t 
  
  val eq_dec : t -> t -> sumbool
 end

module type OrderedType = 
 sig 
  type t 
  
  val compare : t -> t -> comparison
  
  val eq_dec : t -> t -> sumbool
 end

module type OrderedType' = 
 sig 
  type t 
  
  val compare : t -> t -> comparison
  
  val eq_dec : t -> t -> sumbool
 end

module OT_to_Full = 
 functor (O:OrderedType') ->
 struct 
  type t = O.t
  
  (** val compare : t -> t -> comparison **)
  
  let compare =
    O.compare
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    O.eq_dec
 end

module type TotalLeBool' = 
 sig 
  type t 
  
  val leb : t -> t -> bool
 end

module OT_to_OrderTac = 
 functor (OT:OrderedType) ->
 struct 
  module OTF = OT_to_Full(OT)
  
  module TO = 
   struct 
    type t = OTF.t
    
    (** val compare : t -> t -> comparison **)
    
    let compare =
      OTF.compare
    
    (** val eq_dec : t -> t -> sumbool **)
    
    let eq_dec =
      OTF.eq_dec
   end
 end

module OrderedTypeFacts = 
 functor (O:OrderedType') ->
 struct 
  module OrderTac = OT_to_OrderTac(O)
  
  (** val eq_dec : O.t -> O.t -> sumbool **)
  
  let eq_dec =
    O.eq_dec
  
  (** val lt_dec : O.t -> O.t -> sumbool **)
  
  let lt_dec x y =
    let c = compSpec2Type x y (O.compare x y) in
    (match c with
     | CompLtT -> Left
     | _ -> Right)
  
  (** val eqb : O.t -> O.t -> bool **)
  
  let eqb x y =
    match eq_dec x y with
    | Left -> True
    | Right -> False
 end

module Pos = 
 struct 
  type t = positive
  
  (** val succ : positive -> positive **)
  
  let rec succ = function
  | XI p -> XO (succ p)
  | XO p -> XI p
  | XH -> XO XH
  
  (** val add : positive -> positive -> positive **)
  
  let rec add x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> XO (add_carry p q)
       | XO q -> XI (add p q)
       | XH -> XO (succ p))
    | XO p ->
      (match y with
       | XI q -> XI (add p q)
       | XO q -> XO (add p q)
       | XH -> XI p)
    | XH ->
      (match y with
       | XI q -> XO (succ q)
       | XO q -> XI q
       | XH -> XO XH)
  
  (** val add_carry : positive -> positive -> positive **)
  
  and add_carry x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> XI (add_carry p q)
       | XO q -> XO (add_carry p q)
       | XH -> XI (succ p))
    | XO p ->
      (match y with
       | XI q -> XO (add_carry p q)
       | XO q -> XI (add p q)
       | XH -> XO (succ p))
    | XH ->
      (match y with
       | XI q -> XI (succ q)
       | XO q -> XO (succ q)
       | XH -> XI XH)
  
  (** val pred_double : positive -> positive **)
  
  let rec pred_double = function
  | XI p -> XI (XO p)
  | XO p -> XI (pred_double p)
  | XH -> XH
  
  (** val pred : positive -> positive **)
  
  let pred = function
  | XI p -> XO p
  | XO p -> pred_double p
  | XH -> XH
  
  (** val pred_N : positive -> n **)
  
  let pred_N = function
  | XI p -> Npos (XO p)
  | XO p -> Npos (pred_double p)
  | XH -> N0
  
  type mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  
  (** val mask_rect : 'a1 -> (positive -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (positive -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos XH
  | IsPos p -> IsPos (XI p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (XO p)
  | x0 -> x0
  
  (** val double_pred_mask : positive -> mask **)
  
  let double_pred_mask = function
  | XI p -> IsPos (XO (XO p))
  | XO p -> IsPos (XO (pred_double p))
  | XH -> IsNul
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (match q with
     | XH -> IsNul
     | _ -> IsPos (pred q))
  | _ -> IsNeg
  
  (** val sub_mask : positive -> positive -> mask **)
  
  let rec sub_mask x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> double_mask (sub_mask p q)
       | XO q -> succ_double_mask (sub_mask p q)
       | XH -> IsPos (XO p))
    | XO p ->
      (match y with
       | XI q -> succ_double_mask (sub_mask_carry p q)
       | XO q -> double_mask (sub_mask p q)
       | XH -> IsPos (pred_double p))
    | XH ->
      (match y with
       | XH -> IsNul
       | _ -> IsNeg)
  
  (** val sub_mask_carry : positive -> positive -> mask **)
  
  and sub_mask_carry x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> succ_double_mask (sub_mask_carry p q)
       | XO q -> double_mask (sub_mask p q)
       | XH -> IsPos (pred_double p))
    | XO p ->
      (match y with
       | XI q -> double_mask (sub_mask_carry p q)
       | XO q -> succ_double_mask (sub_mask_carry p q)
       | XH -> double_pred_mask p)
    | XH -> IsNeg
  
  (** val sub : positive -> positive -> positive **)
  
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -> z0
    | _ -> XH
  
  (** val mul : positive -> positive -> positive **)
  
  let rec mul x y =
    match x with
    | XI p -> add y (XO (mul p y))
    | XO p -> XO (mul p y)
    | XH -> y
  
  (** val iter : positive -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n0 f x =
    match n0 with
    | XI n' -> f (iter n' f (iter n' f x))
    | XO n' -> iter n' f (iter n' f x)
    | XH -> f x
  
  (** val pow : positive -> positive -> positive **)
  
  let pow x y =
    iter y (mul x) XH
  
  (** val square : positive -> positive **)
  
  let rec square = function
  | XI p0 -> XI (XO (add (square p0) p0))
  | XO p0 -> XO (XO (square p0))
  | XH -> XH
  
  (** val div2 : positive -> positive **)
  
  let div2 = function
  | XI p0 -> p0
  | XO p0 -> p0
  | XH -> XH
  
  (** val div2_up : positive -> positive **)
  
  let div2_up = function
  | XI p0 -> succ p0
  | XO p0 -> p0
  | XH -> XH
  
  (** val size_nat : positive -> nat **)
  
  let rec size_nat = function
  | XI p0 -> S (size_nat p0)
  | XO p0 -> S (size_nat p0)
  | XH -> S O
  
  (** val size : positive -> positive **)
  
  let rec size = function
  | XI p0 -> succ (size p0)
  | XO p0 -> succ (size p0)
  | XH -> XH
  
  (** val compare_cont : positive -> positive -> comparison -> comparison **)
  
  let rec compare_cont x y r =
    match x with
    | XI p ->
      (match y with
       | XI q -> compare_cont p q r
       | XO q -> compare_cont p q Gt
       | XH -> Gt)
    | XO p ->
      (match y with
       | XI q -> compare_cont p q Lt
       | XO q -> compare_cont p q r
       | XH -> Gt)
    | XH ->
      (match y with
       | XH -> r
       | _ -> Lt)
  
  (** val compare : positive -> positive -> comparison **)
  
  let compare x y =
    compare_cont x y Eq
  
  (** val min : positive -> positive -> positive **)
  
  let min p p' =
    match compare p p' with
    | Gt -> p'
    | _ -> p
  
  (** val max : positive -> positive -> positive **)
  
  let max p p' =
    match compare p p' with
    | Gt -> p
    | _ -> p'
  
  (** val eqb : positive -> positive -> bool **)
  
  let rec eqb p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> eqb p0 q0
       | _ -> False)
    | XO p0 ->
      (match q with
       | XO q0 -> eqb p0 q0
       | _ -> False)
    | XH ->
      (match q with
       | XH -> True
       | _ -> False)
  
  (** val leb : positive -> positive -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> False
    | _ -> True
  
  (** val ltb : positive -> positive -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> True
    | _ -> False
  
  (** val sqrtrem_step :
      (positive -> positive) -> (positive -> positive) -> (positive, mask)
      prod -> (positive, mask) prod **)
  
  let sqrtrem_step f g = function
  | Pair (s, y) ->
    (match y with
     | IsPos r ->
       let s' = XI (XO s) in
       let r' = g (f r) in
       (match leb s' r' with
        | True -> Pair ((XI s), (sub_mask r' s'))
        | False -> Pair ((XO s), (IsPos r')))
     | _ -> Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  
  (** val sqrtrem : positive -> (positive, mask) prod **)
  
  let rec sqrtrem = function
  | XI p0 ->
    (match p0 with
     | XI p1 -> sqrtrem_step (fun x -> XI x) (fun x -> XI x) (sqrtrem p1)
     | XO p1 -> sqrtrem_step (fun x -> XO x) (fun x -> XI x) (sqrtrem p1)
     | XH -> Pair (XH, (IsPos (XO XH))))
  | XO p0 ->
    (match p0 with
     | XI p1 -> sqrtrem_step (fun x -> XI x) (fun x -> XO x) (sqrtrem p1)
     | XO p1 -> sqrtrem_step (fun x -> XO x) (fun x -> XO x) (sqrtrem p1)
     | XH -> Pair (XH, (IsPos XH)))
  | XH -> Pair (XH, IsNul)
  
  (** val sqrt : positive -> positive **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : nat -> positive -> positive -> positive **)
  
  let rec gcdn n0 a b =
    match n0 with
    | O -> XH
    | S n1 ->
      (match a with
       | XI a' ->
         (match b with
          | XI b' ->
            (match compare a' b' with
             | Eq -> a
             | Lt -> gcdn n1 (sub b' a') a
             | Gt -> gcdn n1 (sub a' b') b)
          | XO b0 -> gcdn n1 a b0
          | XH -> XH)
       | XO a0 ->
         (match b with
          | XI p -> gcdn n1 a0 b
          | XO b0 -> XO (gcdn n1 a0 b0)
          | XH -> XH)
       | XH -> XH)
  
  (** val gcd : positive -> positive -> positive **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      nat -> positive -> positive -> (positive, (positive, positive) prod)
      prod **)
  
  let rec ggcdn n0 a b =
    match n0 with
    | O -> Pair (XH, (Pair (a, b)))
    | S n1 ->
      (match a with
       | XI a' ->
         (match b with
          | XI b' ->
            (match compare a' b' with
             | Eq -> Pair (a, (Pair (XH, XH)))
             | Lt ->
               let Pair (g, p) = ggcdn n1 (sub b' a') a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt ->
               let Pair (g, p) = ggcdn n1 (sub a' b') b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 ->
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -> Pair (XH, (Pair (a, XH))))
       | XO a0 ->
         (match b with
          | XI p ->
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -> let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -> Pair (XH, (Pair (a, XH))))
       | XH -> Pair (XH, (Pair (XH, b))))
  
  (** val ggcd :
      positive -> positive -> (positive, (positive, positive) prod) prod **)
  
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val coq_Nsucc_double : n -> n **)
  
  let coq_Nsucc_double = function
  | N0 -> Npos XH
  | Npos p -> Npos (XI p)
  
  (** val coq_Ndouble : n -> n **)
  
  let coq_Ndouble = function
  | N0 -> N0
  | Npos p -> Npos (XO p)
  
  (** val coq_lor : positive -> positive -> positive **)
  
  let rec coq_lor p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> XI (coq_lor p0 q0)
       | XO q0 -> XI (coq_lor p0 q0)
       | XH -> p)
    | XO p0 ->
      (match q with
       | XI q0 -> XI (coq_lor p0 q0)
       | XO q0 -> XO (coq_lor p0 q0)
       | XH -> XI p0)
    | XH ->
      (match q with
       | XO q0 -> XI q0
       | _ -> q)
  
  (** val coq_land : positive -> positive -> n **)
  
  let rec coq_land p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -> coq_Ndouble (coq_land p0 q0)
       | XH -> Npos XH)
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (coq_land p0 q0)
       | XO q0 -> coq_Ndouble (coq_land p0 q0)
       | XH -> N0)
    | XH ->
      (match q with
       | XO q0 -> N0
       | _ -> Npos XH)
  
  (** val ldiff : positive -> positive -> n **)
  
  let rec ldiff p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (ldiff p0 q0)
       | XO q0 -> coq_Nsucc_double (ldiff p0 q0)
       | XH -> Npos (XO p0))
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (ldiff p0 q0)
       | XO q0 -> coq_Ndouble (ldiff p0 q0)
       | XH -> Npos p)
    | XH ->
      (match q with
       | XO q0 -> Npos XH
       | _ -> N0)
  
  (** val coq_lxor : positive -> positive -> n **)
  
  let rec coq_lxor p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -> coq_Nsucc_double (coq_lxor p0 q0)
       | XH -> Npos (XO p0))
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -> coq_Ndouble (coq_lxor p0 q0)
       | XH -> Npos (XI p0))
    | XH ->
      (match q with
       | XI q0 -> Npos (XO q0)
       | XO q0 -> Npos (XI q0)
       | XH -> N0)
  
  (** val shiftl_nat : positive -> nat -> positive **)
  
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -> XO x) p
  
  (** val shiftr_nat : positive -> nat -> positive **)
  
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  
  (** val shiftl : positive -> n -> positive **)
  
  let shiftl p = function
  | N0 -> p
  | Npos n1 -> iter n1 (fun x -> XO x) p
  
  (** val shiftr : positive -> n -> positive **)
  
  let shiftr p = function
  | N0 -> p
  | Npos n1 -> iter n1 div2 p
  
  (** val testbit_nat : positive -> nat -> bool **)
  
  let rec testbit_nat p n0 =
    match p with
    | XI p0 ->
      (match n0 with
       | O -> True
       | S n' -> testbit_nat p0 n')
    | XO p0 ->
      (match n0 with
       | O -> False
       | S n' -> testbit_nat p0 n')
    | XH ->
      (match n0 with
       | O -> True
       | S n1 -> False)
  
  (** val testbit : positive -> n -> bool **)
  
  let rec testbit p n0 =
    match p with
    | XI p0 ->
      (match n0 with
       | N0 -> True
       | Npos n1 -> testbit p0 (pred_N n1))
    | XO p0 ->
      (match n0 with
       | N0 -> False
       | Npos n1 -> testbit p0 (pred_N n1))
    | XH ->
      (match n0 with
       | N0 -> True
       | Npos p0 -> False)
  
  (** val iter_op : ('a1 -> 'a1 -> 'a1) -> positive -> 'a1 -> 'a1 **)
  
  let rec iter_op op p a =
    match p with
    | XI p0 -> op a (iter_op op p0 (op a a))
    | XO p0 -> iter_op op p0 (op a a)
    | XH -> a
  
  (** val to_nat : positive -> nat **)
  
  let to_nat x =
    iter_op plus x (S O)
  
  (** val of_nat : nat -> positive **)
  
  let rec of_nat = function
  | O -> XH
  | S x ->
    (match x with
     | O -> XH
     | S n1 -> succ (of_nat x))
  
  (** val of_succ_nat : nat -> positive **)
  
  let rec of_succ_nat = function
  | O -> XH
  | S x -> succ (of_succ_nat x)
 end

module Coq_Pos = 
 struct 
  type t = positive
  
  (** val succ : positive -> positive **)
  
  let rec succ = function
  | XI p -> XO (succ p)
  | XO p -> XI p
  | XH -> XO XH
  
  (** val add : positive -> positive -> positive **)
  
  let rec add x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> XO (add_carry p q)
       | XO q -> XI (add p q)
       | XH -> XO (succ p))
    | XO p ->
      (match y with
       | XI q -> XI (add p q)
       | XO q -> XO (add p q)
       | XH -> XI p)
    | XH ->
      (match y with
       | XI q -> XO (succ q)
       | XO q -> XI q
       | XH -> XO XH)
  
  (** val add_carry : positive -> positive -> positive **)
  
  and add_carry x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> XI (add_carry p q)
       | XO q -> XO (add_carry p q)
       | XH -> XI (succ p))
    | XO p ->
      (match y with
       | XI q -> XO (add_carry p q)
       | XO q -> XI (add p q)
       | XH -> XO (succ p))
    | XH ->
      (match y with
       | XI q -> XI (succ q)
       | XO q -> XO (succ q)
       | XH -> XI XH)
  
  (** val pred_double : positive -> positive **)
  
  let rec pred_double = function
  | XI p -> XI (XO p)
  | XO p -> XI (pred_double p)
  | XH -> XH
  
  (** val pred : positive -> positive **)
  
  let pred = function
  | XI p -> XO p
  | XO p -> pred_double p
  | XH -> XH
  
  (** val pred_N : positive -> n **)
  
  let pred_N = function
  | XI p -> Npos (XO p)
  | XO p -> Npos (pred_double p)
  | XH -> N0
  
  type mask = Pos.mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  
  (** val mask_rect : 'a1 -> (positive -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (positive -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos XH
  | IsPos p -> IsPos (XI p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (XO p)
  | x0 -> x0
  
  (** val double_pred_mask : positive -> mask **)
  
  let double_pred_mask = function
  | XI p -> IsPos (XO (XO p))
  | XO p -> IsPos (XO (pred_double p))
  | XH -> IsNul
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (match q with
     | XH -> IsNul
     | _ -> IsPos (pred q))
  | _ -> IsNeg
  
  (** val sub_mask : positive -> positive -> mask **)
  
  let rec sub_mask x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> double_mask (sub_mask p q)
       | XO q -> succ_double_mask (sub_mask p q)
       | XH -> IsPos (XO p))
    | XO p ->
      (match y with
       | XI q -> succ_double_mask (sub_mask_carry p q)
       | XO q -> double_mask (sub_mask p q)
       | XH -> IsPos (pred_double p))
    | XH ->
      (match y with
       | XH -> IsNul
       | _ -> IsNeg)
  
  (** val sub_mask_carry : positive -> positive -> mask **)
  
  and sub_mask_carry x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> succ_double_mask (sub_mask_carry p q)
       | XO q -> double_mask (sub_mask p q)
       | XH -> IsPos (pred_double p))
    | XO p ->
      (match y with
       | XI q -> double_mask (sub_mask_carry p q)
       | XO q -> succ_double_mask (sub_mask_carry p q)
       | XH -> double_pred_mask p)
    | XH -> IsNeg
  
  (** val sub : positive -> positive -> positive **)
  
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -> z0
    | _ -> XH
  
  (** val mul : positive -> positive -> positive **)
  
  let rec mul x y =
    match x with
    | XI p -> add y (XO (mul p y))
    | XO p -> XO (mul p y)
    | XH -> y
  
  (** val iter : positive -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n0 f x =
    match n0 with
    | XI n' -> f (iter n' f (iter n' f x))
    | XO n' -> iter n' f (iter n' f x)
    | XH -> f x
  
  (** val pow : positive -> positive -> positive **)
  
  let pow x y =
    iter y (mul x) XH
  
  (** val square : positive -> positive **)
  
  let rec square = function
  | XI p0 -> XI (XO (add (square p0) p0))
  | XO p0 -> XO (XO (square p0))
  | XH -> XH
  
  (** val div2 : positive -> positive **)
  
  let div2 = function
  | XI p0 -> p0
  | XO p0 -> p0
  | XH -> XH
  
  (** val div2_up : positive -> positive **)
  
  let div2_up = function
  | XI p0 -> succ p0
  | XO p0 -> p0
  | XH -> XH
  
  (** val size_nat : positive -> nat **)
  
  let rec size_nat = function
  | XI p0 -> S (size_nat p0)
  | XO p0 -> S (size_nat p0)
  | XH -> S O
  
  (** val size : positive -> positive **)
  
  let rec size = function
  | XI p0 -> succ (size p0)
  | XO p0 -> succ (size p0)
  | XH -> XH
  
  (** val compare_cont : positive -> positive -> comparison -> comparison **)
  
  let rec compare_cont x y r =
    match x with
    | XI p ->
      (match y with
       | XI q -> compare_cont p q r
       | XO q -> compare_cont p q Gt
       | XH -> Gt)
    | XO p ->
      (match y with
       | XI q -> compare_cont p q Lt
       | XO q -> compare_cont p q r
       | XH -> Gt)
    | XH ->
      (match y with
       | XH -> r
       | _ -> Lt)
  
  (** val compare : positive -> positive -> comparison **)
  
  let compare x y =
    compare_cont x y Eq
  
  (** val min : positive -> positive -> positive **)
  
  let min p p' =
    match compare p p' with
    | Gt -> p'
    | _ -> p
  
  (** val max : positive -> positive -> positive **)
  
  let max p p' =
    match compare p p' with
    | Gt -> p
    | _ -> p'
  
  (** val eqb : positive -> positive -> bool **)
  
  let rec eqb p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> eqb p0 q0
       | _ -> False)
    | XO p0 ->
      (match q with
       | XO q0 -> eqb p0 q0
       | _ -> False)
    | XH ->
      (match q with
       | XH -> True
       | _ -> False)
  
  (** val leb : positive -> positive -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> False
    | _ -> True
  
  (** val ltb : positive -> positive -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> True
    | _ -> False
  
  (** val sqrtrem_step :
      (positive -> positive) -> (positive -> positive) -> (positive, mask)
      prod -> (positive, mask) prod **)
  
  let sqrtrem_step f g = function
  | Pair (s, y) ->
    (match y with
     | IsPos r ->
       let s' = XI (XO s) in
       let r' = g (f r) in
       (match leb s' r' with
        | True -> Pair ((XI s), (sub_mask r' s'))
        | False -> Pair ((XO s), (IsPos r')))
     | _ -> Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  
  (** val sqrtrem : positive -> (positive, mask) prod **)
  
  let rec sqrtrem = function
  | XI p0 ->
    (match p0 with
     | XI p1 -> sqrtrem_step (fun x -> XI x) (fun x -> XI x) (sqrtrem p1)
     | XO p1 -> sqrtrem_step (fun x -> XO x) (fun x -> XI x) (sqrtrem p1)
     | XH -> Pair (XH, (IsPos (XO XH))))
  | XO p0 ->
    (match p0 with
     | XI p1 -> sqrtrem_step (fun x -> XI x) (fun x -> XO x) (sqrtrem p1)
     | XO p1 -> sqrtrem_step (fun x -> XO x) (fun x -> XO x) (sqrtrem p1)
     | XH -> Pair (XH, (IsPos XH)))
  | XH -> Pair (XH, IsNul)
  
  (** val sqrt : positive -> positive **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : nat -> positive -> positive -> positive **)
  
  let rec gcdn n0 a b =
    match n0 with
    | O -> XH
    | S n1 ->
      (match a with
       | XI a' ->
         (match b with
          | XI b' ->
            (match compare a' b' with
             | Eq -> a
             | Lt -> gcdn n1 (sub b' a') a
             | Gt -> gcdn n1 (sub a' b') b)
          | XO b0 -> gcdn n1 a b0
          | XH -> XH)
       | XO a0 ->
         (match b with
          | XI p -> gcdn n1 a0 b
          | XO b0 -> XO (gcdn n1 a0 b0)
          | XH -> XH)
       | XH -> XH)
  
  (** val gcd : positive -> positive -> positive **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      nat -> positive -> positive -> (positive, (positive, positive) prod)
      prod **)
  
  let rec ggcdn n0 a b =
    match n0 with
    | O -> Pair (XH, (Pair (a, b)))
    | S n1 ->
      (match a with
       | XI a' ->
         (match b with
          | XI b' ->
            (match compare a' b' with
             | Eq -> Pair (a, (Pair (XH, XH)))
             | Lt ->
               let Pair (g, p) = ggcdn n1 (sub b' a') a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt ->
               let Pair (g, p) = ggcdn n1 (sub a' b') b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 ->
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -> Pair (XH, (Pair (a, XH))))
       | XO a0 ->
         (match b with
          | XI p ->
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -> let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -> Pair (XH, (Pair (a, XH))))
       | XH -> Pair (XH, (Pair (XH, b))))
  
  (** val ggcd :
      positive -> positive -> (positive, (positive, positive) prod) prod **)
  
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val coq_Nsucc_double : n -> n **)
  
  let coq_Nsucc_double = function
  | N0 -> Npos XH
  | Npos p -> Npos (XI p)
  
  (** val coq_Ndouble : n -> n **)
  
  let coq_Ndouble = function
  | N0 -> N0
  | Npos p -> Npos (XO p)
  
  (** val coq_lor : positive -> positive -> positive **)
  
  let rec coq_lor p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> XI (coq_lor p0 q0)
       | XO q0 -> XI (coq_lor p0 q0)
       | XH -> p)
    | XO p0 ->
      (match q with
       | XI q0 -> XI (coq_lor p0 q0)
       | XO q0 -> XO (coq_lor p0 q0)
       | XH -> XI p0)
    | XH ->
      (match q with
       | XO q0 -> XI q0
       | _ -> q)
  
  (** val coq_land : positive -> positive -> n **)
  
  let rec coq_land p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -> coq_Ndouble (coq_land p0 q0)
       | XH -> Npos XH)
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (coq_land p0 q0)
       | XO q0 -> coq_Ndouble (coq_land p0 q0)
       | XH -> N0)
    | XH ->
      (match q with
       | XO q0 -> N0
       | _ -> Npos XH)
  
  (** val ldiff : positive -> positive -> n **)
  
  let rec ldiff p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (ldiff p0 q0)
       | XO q0 -> coq_Nsucc_double (ldiff p0 q0)
       | XH -> Npos (XO p0))
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (ldiff p0 q0)
       | XO q0 -> coq_Ndouble (ldiff p0 q0)
       | XH -> Npos p)
    | XH ->
      (match q with
       | XO q0 -> Npos XH
       | _ -> N0)
  
  (** val coq_lxor : positive -> positive -> n **)
  
  let rec coq_lxor p q =
    match p with
    | XI p0 ->
      (match q with
       | XI q0 -> coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -> coq_Nsucc_double (coq_lxor p0 q0)
       | XH -> Npos (XO p0))
    | XO p0 ->
      (match q with
       | XI q0 -> coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -> coq_Ndouble (coq_lxor p0 q0)
       | XH -> Npos (XI p0))
    | XH ->
      (match q with
       | XI q0 -> Npos (XO q0)
       | XO q0 -> Npos (XI q0)
       | XH -> N0)
  
  (** val shiftl_nat : positive -> nat -> positive **)
  
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -> XO x) p
  
  (** val shiftr_nat : positive -> nat -> positive **)
  
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  
  (** val shiftl : positive -> n -> positive **)
  
  let shiftl p = function
  | N0 -> p
  | Npos n1 -> iter n1 (fun x -> XO x) p
  
  (** val shiftr : positive -> n -> positive **)
  
  let shiftr p = function
  | N0 -> p
  | Npos n1 -> iter n1 div2 p
  
  (** val testbit_nat : positive -> nat -> bool **)
  
  let rec testbit_nat p n0 =
    match p with
    | XI p0 ->
      (match n0 with
       | O -> True
       | S n' -> testbit_nat p0 n')
    | XO p0 ->
      (match n0 with
       | O -> False
       | S n' -> testbit_nat p0 n')
    | XH ->
      (match n0 with
       | O -> True
       | S n1 -> False)
  
  (** val testbit : positive -> n -> bool **)
  
  let rec testbit p n0 =
    match p with
    | XI p0 ->
      (match n0 with
       | N0 -> True
       | Npos n1 -> testbit p0 (pred_N n1))
    | XO p0 ->
      (match n0 with
       | N0 -> False
       | Npos n1 -> testbit p0 (pred_N n1))
    | XH ->
      (match n0 with
       | N0 -> True
       | Npos p0 -> False)
  
  (** val iter_op : ('a1 -> 'a1 -> 'a1) -> positive -> 'a1 -> 'a1 **)
  
  let rec iter_op op p a =
    match p with
    | XI p0 -> op a (iter_op op p0 (op a a))
    | XO p0 -> iter_op op p0 (op a a)
    | XH -> a
  
  (** val to_nat : positive -> nat **)
  
  let to_nat x =
    iter_op plus x (S O)
  
  (** val of_nat : nat -> positive **)
  
  let rec of_nat = function
  | O -> XH
  | S x ->
    (match x with
     | O -> XH
     | S n1 -> succ (of_nat x))
  
  (** val of_succ_nat : nat -> positive **)
  
  let rec of_succ_nat = function
  | O -> XH
  | S x -> succ (of_succ_nat x)
  
  (** val eq_dec : positive -> positive -> sumbool **)
  
  let rec eq_dec p y0 =
    match p with
    | XI p0 ->
      (match y0 with
       | XI p1 -> eq_dec p0 p1
       | _ -> Right)
    | XO p0 ->
      (match y0 with
       | XO p1 -> eq_dec p0 p1
       | _ -> Right)
    | XH ->
      (match y0 with
       | XH -> Left
       | _ -> Right)
  
  (** val peano_rect : 'a1 -> (positive -> 'a1 -> 'a1) -> positive -> 'a1 **)
  
  let rec peano_rect a f p =
    let f2 = peano_rect (f XH a) (fun p0 x -> f (succ (XO p0)) (f (XO p0) x))
    in
    (match p with
     | XI q -> f (XO q) (f2 q)
     | XO q -> f2 q
     | XH -> a)
  
  (** val peano_rec : 'a1 -> (positive -> 'a1 -> 'a1) -> positive -> 'a1 **)
  
  let peano_rec =
    peano_rect
  
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of positive * coq_PeanoView
  
  (** val coq_PeanoView_rect :
      'a1 -> (positive -> coq_PeanoView -> 'a1 -> 'a1) -> positive ->
      coq_PeanoView -> 'a1 **)
  
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne -> f
  | PeanoSucc (p1, p2) -> f0 p1 p2 (coq_PeanoView_rect f f0 p1 p2)
  
  (** val coq_PeanoView_rec :
      'a1 -> (positive -> coq_PeanoView -> 'a1 -> 'a1) -> positive ->
      coq_PeanoView -> 'a1 **)
  
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne -> f
  | PeanoSucc (p1, p2) -> f0 p1 p2 (coq_PeanoView_rec f f0 p1 p2)
  
  (** val peanoView_xO : positive -> coq_PeanoView -> coq_PeanoView **)
  
  let rec peanoView_xO p = function
  | PeanoOne -> PeanoSucc (XH, PeanoOne)
  | PeanoSucc (p0, q0) ->
    PeanoSucc ((succ (XO p0)), (PeanoSucc ((XO p0), (peanoView_xO p0 q0))))
  
  (** val peanoView_xI : positive -> coq_PeanoView -> coq_PeanoView **)
  
  let rec peanoView_xI p = function
  | PeanoOne -> PeanoSucc ((succ XH), (PeanoSucc (XH, PeanoOne)))
  | PeanoSucc (p0, q0) ->
    PeanoSucc ((succ (XI p0)), (PeanoSucc ((XI p0), (peanoView_xI p0 q0))))
  
  (** val peanoView : positive -> coq_PeanoView **)
  
  let rec peanoView = function
  | XI p0 -> peanoView_xI p0 (peanoView p0)
  | XO p0 -> peanoView_xO p0 (peanoView p0)
  | XH -> PeanoOne
  
  (** val coq_PeanoView_iter :
      'a1 -> (positive -> 'a1 -> 'a1) -> positive -> coq_PeanoView -> 'a1 **)
  
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne -> a
  | PeanoSucc (p0, q0) -> f p0 (coq_PeanoView_iter a f p0 q0)
  
  (** val eqb_spec : positive -> positive -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val switch_Eq : comparison -> comparison -> comparison **)
  
  let switch_Eq c = function
  | Eq -> c
  | x -> x
  
  (** val mask2cmp : mask -> comparison **)
  
  let mask2cmp = function
  | IsNul -> Eq
  | IsPos p0 -> Gt
  | IsNeg -> Lt
  
  (** val leb_spec0 : positive -> positive -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : positive -> positive -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        positive -> positive -> (positive -> positive -> __ -> 'a1 -> 'a1) ->
        (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let max_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat n0 (max n0 m0) __ (hl __)
       | _ -> compat m0 (max n0 m0) __ (hr __))
    
    (** val max_case :
        positive -> positive -> (positive -> positive -> __ -> 'a1 -> 'a1) ->
        'a1 -> 'a1 -> 'a1 **)
    
    let max_case n0 m0 x x0 x1 =
      max_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : positive -> positive -> sumbool **)
    
    let max_dec n0 m0 =
      max_case n0 m0 (fun x y _ h0 -> h0) Left Right
    
    (** val min_case_strong :
        positive -> positive -> (positive -> positive -> __ -> 'a1 -> 'a1) ->
        (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let min_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat m0 (min n0 m0) __ (hr __)
       | _ -> compat n0 (min n0 m0) __ (hl __))
    
    (** val min_case :
        positive -> positive -> (positive -> positive -> __ -> 'a1 -> 'a1) ->
        'a1 -> 'a1 -> 'a1 **)
    
    let min_case n0 m0 x x0 x1 =
      min_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : positive -> positive -> sumbool **)
    
    let min_dec n0 m0 =
      min_case n0 m0 (fun x y _ h0 -> h0) Left Right
   end
  
  (** val max_case_strong :
      positive -> positive -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n0 m0 x x0 =
    Private_Dec.max_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : positive -> positive -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n0 m0 x x0 =
    max_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : positive -> positive -> sumbool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      positive -> positive -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n0 m0 x x0 =
    Private_Dec.min_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : positive -> positive -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n0 m0 x x0 =
    min_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : positive -> positive -> sumbool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

module N = 
 struct 
  type t = n
  
  (** val zero : n **)
  
  let zero =
    N0
  
  (** val one : n **)
  
  let one =
    Npos XH
  
  (** val two : n **)
  
  let two =
    Npos (XO XH)
  
  (** val succ_double : n -> n **)
  
  let succ_double = function
  | N0 -> Npos XH
  | Npos p -> Npos (XI p)
  
  (** val double : n -> n **)
  
  let double = function
  | N0 -> N0
  | Npos p -> Npos (XO p)
  
  (** val succ : n -> n **)
  
  let succ = function
  | N0 -> Npos XH
  | Npos p -> Npos (Coq_Pos.succ p)
  
  (** val pred : n -> n **)
  
  let pred = function
  | N0 -> N0
  | Npos p -> Coq_Pos.pred_N p
  
  (** val succ_pos : n -> positive **)
  
  let succ_pos = function
  | N0 -> XH
  | Npos p -> Coq_Pos.succ p
  
  (** val add : n -> n -> n **)
  
  let add n0 m0 =
    match n0 with
    | N0 -> m0
    | Npos p ->
      (match m0 with
       | N0 -> n0
       | Npos q -> Npos (Coq_Pos.add p q))
  
  (** val sub : n -> n -> n **)
  
  let sub n0 m0 =
    match n0 with
    | N0 -> N0
    | Npos n' ->
      (match m0 with
       | N0 -> n0
       | Npos m' ->
         (match Coq_Pos.sub_mask n' m' with
          | Coq_Pos.IsPos p -> Npos p
          | _ -> N0))
  
  (** val mul : n -> n -> n **)
  
  let mul n0 m0 =
    match n0 with
    | N0 -> N0
    | Npos p ->
      (match m0 with
       | N0 -> N0
       | Npos q -> Npos (Coq_Pos.mul p q))
  
  (** val compare : n -> n -> comparison **)
  
  let compare n0 m0 =
    match n0 with
    | N0 ->
      (match m0 with
       | N0 -> Eq
       | Npos m' -> Lt)
    | Npos n' ->
      (match m0 with
       | N0 -> Gt
       | Npos m' -> Coq_Pos.compare n' m')
  
  (** val eqb : n -> n -> bool **)
  
  let rec eqb n0 m0 =
    match n0 with
    | N0 ->
      (match m0 with
       | N0 -> True
       | Npos p -> False)
    | Npos p ->
      (match m0 with
       | N0 -> False
       | Npos q -> Coq_Pos.eqb p q)
  
  (** val leb : n -> n -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> False
    | _ -> True
  
  (** val ltb : n -> n -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> True
    | _ -> False
  
  (** val min : n -> n -> n **)
  
  let min n0 n' =
    match compare n0 n' with
    | Gt -> n'
    | _ -> n0
  
  (** val max : n -> n -> n **)
  
  let max n0 n' =
    match compare n0 n' with
    | Gt -> n0
    | _ -> n'
  
  (** val div2 : n -> n **)
  
  let div2 = function
  | N0 -> N0
  | Npos p0 ->
    (match p0 with
     | XI p -> Npos p
     | XO p -> Npos p
     | XH -> N0)
  
  (** val even : n -> bool **)
  
  let even = function
  | N0 -> True
  | Npos p ->
    (match p with
     | XO p0 -> True
     | _ -> False)
  
  (** val odd : n -> bool **)
  
  let odd n0 =
    negb (even n0)
  
  (** val pow : n -> n -> n **)
  
  let pow n0 = function
  | N0 -> Npos XH
  | Npos p0 ->
    (match n0 with
     | N0 -> N0
     | Npos q -> Npos (Coq_Pos.pow q p0))
  
  (** val square : n -> n **)
  
  let square = function
  | N0 -> N0
  | Npos p -> Npos (Coq_Pos.square p)
  
  (** val log2 : n -> n **)
  
  let log2 = function
  | N0 -> N0
  | Npos p0 ->
    (match p0 with
     | XI p -> Npos (Coq_Pos.size p)
     | XO p -> Npos (Coq_Pos.size p)
     | XH -> N0)
  
  (** val size : n -> n **)
  
  let size = function
  | N0 -> N0
  | Npos p -> Npos (Coq_Pos.size p)
  
  (** val size_nat : n -> nat **)
  
  let size_nat = function
  | N0 -> O
  | Npos p -> Coq_Pos.size_nat p
  
  (** val pos_div_eucl : positive -> n -> (n, n) prod **)
  
  let rec pos_div_eucl a b =
    match a with
    | XI a' ->
      let Pair (q, r) = pos_div_eucl a' b in
      let r' = succ_double r in
      (match leb b r' with
       | True -> Pair ((succ_double q), (sub r' b))
       | False -> Pair ((double q), r'))
    | XO a' ->
      let Pair (q, r) = pos_div_eucl a' b in
      let r' = double r in
      (match leb b r' with
       | True -> Pair ((succ_double q), (sub r' b))
       | False -> Pair ((double q), r'))
    | XH ->
      (match b with
       | N0 -> Pair (N0, (Npos XH))
       | Npos p ->
         (match p with
          | XH -> Pair ((Npos XH), N0)
          | _ -> Pair (N0, (Npos XH))))
  
  (** val div_eucl : n -> n -> (n, n) prod **)
  
  let div_eucl a b =
    match a with
    | N0 -> Pair (N0, N0)
    | Npos na ->
      (match b with
       | N0 -> Pair (N0, a)
       | Npos p -> pos_div_eucl na b)
  
  (** val div : n -> n -> n **)
  
  let div a b =
    fst (div_eucl a b)
  
  (** val modulo : n -> n -> n **)
  
  let modulo a b =
    snd (div_eucl a b)
  
  (** val gcd : n -> n -> n **)
  
  let gcd a b =
    match a with
    | N0 -> b
    | Npos p ->
      (match b with
       | N0 -> a
       | Npos q -> Npos (Coq_Pos.gcd p q))
  
  (** val ggcd : n -> n -> (n, (n, n) prod) prod **)
  
  let ggcd a b =
    match a with
    | N0 -> Pair (b, (Pair (N0, (Npos XH))))
    | Npos p ->
      (match b with
       | N0 -> Pair (a, (Pair ((Npos XH), N0)))
       | Npos q ->
         let Pair (g, p0) = Coq_Pos.ggcd p q in
         let Pair (aa, bb) = p0 in
         Pair ((Npos g), (Pair ((Npos aa), (Npos bb)))))
  
  (** val sqrtrem : n -> (n, n) prod **)
  
  let sqrtrem = function
  | N0 -> Pair (N0, N0)
  | Npos p ->
    let Pair (s, m0) = Coq_Pos.sqrtrem p in
    (match m0 with
     | Coq_Pos.IsPos r -> Pair ((Npos s), (Npos r))
     | _ -> Pair ((Npos s), N0))
  
  (** val sqrt : n -> n **)
  
  let sqrt = function
  | N0 -> N0
  | Npos p -> Npos (Coq_Pos.sqrt p)
  
  (** val coq_lor : n -> n -> n **)
  
  let coq_lor n0 m0 =
    match n0 with
    | N0 -> m0
    | Npos p ->
      (match m0 with
       | N0 -> n0
       | Npos q -> Npos (Coq_Pos.coq_lor p q))
  
  (** val coq_land : n -> n -> n **)
  
  let coq_land n0 m0 =
    match n0 with
    | N0 -> N0
    | Npos p ->
      (match m0 with
       | N0 -> N0
       | Npos q -> Coq_Pos.coq_land p q)
  
  (** val ldiff : n -> n -> n **)
  
  let rec ldiff n0 m0 =
    match n0 with
    | N0 -> N0
    | Npos p ->
      (match m0 with
       | N0 -> n0
       | Npos q -> Coq_Pos.ldiff p q)
  
  (** val coq_lxor : n -> n -> n **)
  
  let coq_lxor n0 m0 =
    match n0 with
    | N0 -> m0
    | Npos p ->
      (match m0 with
       | N0 -> n0
       | Npos q -> Coq_Pos.coq_lxor p q)
  
  (** val shiftl_nat : n -> nat -> n **)
  
  let shiftl_nat a n0 =
    nat_iter n0 double a
  
  (** val shiftr_nat : n -> nat -> n **)
  
  let shiftr_nat a n0 =
    nat_iter n0 div2 a
  
  (** val shiftl : n -> n -> n **)
  
  let shiftl a n0 =
    match a with
    | N0 -> N0
    | Npos a0 -> Npos (Coq_Pos.shiftl a0 n0)
  
  (** val shiftr : n -> n -> n **)
  
  let shiftr a = function
  | N0 -> a
  | Npos p -> Coq_Pos.iter p div2 a
  
  (** val testbit_nat : n -> nat -> bool **)
  
  let testbit_nat = function
  | N0 -> (fun x -> False)
  | Npos p -> Coq_Pos.testbit_nat p
  
  (** val testbit : n -> n -> bool **)
  
  let testbit a n0 =
    match a with
    | N0 -> False
    | Npos p -> Coq_Pos.testbit p n0
  
  (** val to_nat : n -> nat **)
  
  let to_nat = function
  | N0 -> O
  | Npos p -> Coq_Pos.to_nat p
  
  (** val of_nat : nat -> n **)
  
  let of_nat = function
  | O -> N0
  | S n' -> Npos (Coq_Pos.of_succ_nat n')
  
  (** val iter : n -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let iter n0 f x =
    match n0 with
    | N0 -> x
    | Npos p -> Coq_Pos.iter p f x
  
  (** val eq_dec : n -> n -> sumbool **)
  
  let eq_dec n0 m0 =
    match n0 with
    | N0 ->
      (match m0 with
       | N0 -> Left
       | Npos p -> Right)
    | Npos x ->
      (match m0 with
       | N0 -> Right
       | Npos p0 -> Coq_Pos.eq_dec x p0)
  
  (** val discr : n -> positive sumor **)
  
  let discr = function
  | N0 -> Inright
  | Npos p -> Inleft p
  
  (** val binary_rect :
      'a1 -> (n -> 'a1 -> 'a1) -> (n -> 'a1 -> 'a1) -> n -> 'a1 **)
  
  let binary_rect f0 f2 fS2 n0 =
    let f2' = fun p -> f2 (Npos p) in
    let fS2' = fun p -> fS2 (Npos p) in
    (match n0 with
     | N0 -> f0
     | Npos p ->
       let rec f = function
       | XI p1 -> fS2' p1 (f p1)
       | XO p1 -> f2' p1 (f p1)
       | XH -> fS2 N0 f0
       in f p)
  
  (** val binary_rec :
      'a1 -> (n -> 'a1 -> 'a1) -> (n -> 'a1 -> 'a1) -> n -> 'a1 **)
  
  let binary_rec =
    binary_rect
  
  (** val peano_rect : 'a1 -> (n -> 'a1 -> 'a1) -> n -> 'a1 **)
  
  let peano_rect f0 f n0 =
    let f' = fun p -> f (Npos p) in
    (match n0 with
     | N0 -> f0
     | Npos p -> Coq_Pos.peano_rect (f N0 f0) f' p)
  
  (** val peano_rec : 'a1 -> (n -> 'a1 -> 'a1) -> n -> 'a1 **)
  
  let peano_rec =
    peano_rect
  
  (** val leb_spec0 : n -> n -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : n -> n -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val recursion : 'a1 -> (n -> 'a1 -> 'a1) -> n -> 'a1 **)
  
  let recursion x =
    peano_rect x
  
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
      
     end
    
    module Tac = 
     struct 
      
     end
   end
  
  module Private_NZPow = 
   struct 
    
   end
  
  module Private_NZSqrt = 
   struct 
    
   end
  
  (** val sqrt_up : n -> n **)
  
  let sqrt_up a =
    match compare N0 a with
    | Lt -> succ (sqrt (pred a))
    | _ -> N0
  
  (** val log2_up : n -> n **)
  
  let log2_up a =
    match compare (Npos XH) a with
    | Lt -> succ (log2 (pred a))
    | _ -> N0
  
  module Private_NZDiv = 
   struct 
    
   end
  
  (** val lcm : n -> n -> n **)
  
  let lcm a b =
    mul a (div b (gcd a b))
  
  (** val eqb_spec : n -> n -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val b2n : bool -> n **)
  
  let b2n = function
  | True -> Npos XH
  | False -> N0
  
  (** val setbit : n -> n -> n **)
  
  let setbit a n0 =
    coq_lor a (shiftl (Npos XH) n0)
  
  (** val clearbit : n -> n -> n **)
  
  let clearbit a n0 =
    ldiff a (shiftl (Npos XH) n0)
  
  (** val ones : n -> n **)
  
  let ones n0 =
    pred (shiftl (Npos XH) n0)
  
  (** val lnot : n -> n -> n **)
  
  let lnot a n0 =
    coq_lxor a (ones n0)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        n -> n -> (n -> n -> __ -> 'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1)
        -> 'a1 **)
    
    let max_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat n0 (max n0 m0) __ (hl __)
       | _ -> compat m0 (max n0 m0) __ (hr __))
    
    (** val max_case :
        n -> n -> (n -> n -> __ -> 'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n0 m0 x x0 x1 =
      max_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : n -> n -> sumbool **)
    
    let max_dec n0 m0 =
      max_case n0 m0 (fun x y _ h0 -> h0) Left Right
    
    (** val min_case_strong :
        n -> n -> (n -> n -> __ -> 'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1)
        -> 'a1 **)
    
    let min_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat m0 (min n0 m0) __ (hr __)
       | _ -> compat n0 (min n0 m0) __ (hl __))
    
    (** val min_case :
        n -> n -> (n -> n -> __ -> 'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n0 m0 x x0 x1 =
      min_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : n -> n -> sumbool **)
    
    let min_dec n0 m0 =
      min_case n0 m0 (fun x y _ h0 -> h0) Left Right
   end
  
  (** val max_case_strong : n -> n -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n0 m0 x x0 =
    Private_Dec.max_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : n -> n -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n0 m0 x x0 =
    max_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : n -> n -> sumbool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong : n -> n -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n0 m0 x x0 =
    Private_Dec.min_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : n -> n -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n0 m0 x x0 =
    min_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : n -> n -> sumbool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val hd : 'a1 -> 'a1 list -> 'a1 **)

let hd default0 = function
| Nil -> default0
| Cons (x, l0) -> x

(** val tl : 'a1 list -> 'a1 list **)

let tl = function
| Nil -> Nil
| Cons (a, m0) -> m0

(** val in_dec : ('a1 -> 'a1 -> sumbool) -> 'a1 -> 'a1 list -> sumbool **)

let rec in_dec h a = function
| Nil -> Right
| Cons (y, l0) ->
  let s = h y a in
  (match s with
   | Left -> Left
   | Right -> in_dec h a l0)

(** val nth_error : 'a1 list -> nat -> 'a1 exc **)

let rec nth_error l = function
| O ->
  (match l with
   | Nil -> error
   | Cons (x, l0) -> value x)
| S n1 ->
  (match l with
   | Nil -> error
   | Cons (a, l0) -> nth_error l0 n1)

(** val remove : ('a1 -> 'a1 -> sumbool) -> 'a1 -> 'a1 list -> 'a1 list **)

let rec remove eq_dec0 x = function
| Nil -> Nil
| Cons (y, tl0) ->
  (match eq_dec0 x y with
   | Left -> remove eq_dec0 x tl0
   | Right -> Cons (y, (remove eq_dec0 x tl0)))

(** val rev : 'a1 list -> 'a1 list **)

let rec rev = function
| Nil -> Nil
| Cons (x, l') -> app (rev l') (Cons (x, Nil))

(** val rev_append : 'a1 list -> 'a1 list -> 'a1 list **)

let rec rev_append l l' =
  match l with
  | Nil -> l'
  | Cons (a, l0) -> rev_append l0 (Cons (a, l'))

(** val rev' : 'a1 list -> 'a1 list **)

let rev' l =
  rev_append l Nil

(** val list_eq_dec :
    ('a1 -> 'a1 -> sumbool) -> 'a1 list -> 'a1 list -> sumbool **)

let rec list_eq_dec eq_dec0 l l' =
  match l with
  | Nil ->
    (match l' with
     | Nil -> Left
     | Cons (a, l0) -> Right)
  | Cons (y, l0) ->
    (match l' with
     | Nil -> Right
     | Cons (a0, l1) ->
       (match eq_dec0 y a0 with
        | Left -> list_eq_dec eq_dec0 l0 l1
        | Right -> Right))

module Coq__1 = struct 
 (** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)
 
 let rec map f = function
 | Nil -> Nil
 | Cons (a, t1) -> Cons ((f a), (map f t1))
end
let map = Coq__1.map


(** val fold_left : ('a1 -> 'a2 -> 'a1) -> 'a2 list -> 'a1 -> 'a1 **)

let rec fold_left f l a0 =
  match l with
  | Nil -> a0
  | Cons (b, t1) -> fold_left f t1 (f a0 b)

(** val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1 **)

let rec fold_right f a0 = function
| Nil -> a0
| Cons (b, t1) -> f b (fold_right f a0 t1)

(** val existsb : ('a1 -> bool) -> 'a1 list -> bool **)

let rec existsb f = function
| Nil -> False
| Cons (a, l0) ->
  (match f a with
   | True -> True
   | False -> existsb f l0)

(** val forallb : ('a1 -> bool) -> 'a1 list -> bool **)

let rec forallb f = function
| Nil -> True
| Cons (a, l0) ->
  (match f a with
   | True -> forallb f l0
   | False -> False)

(** val filter : ('a1 -> bool) -> 'a1 list -> 'a1 list **)

let rec filter f = function
| Nil -> Nil
| Cons (x, l0) ->
  (match f x with
   | True -> Cons (x, (filter f l0))
   | False -> filter f l0)

module Z = 
 struct 
  type t = z
  
  (** val zero : z **)
  
  let zero =
    Z0
  
  (** val one : z **)
  
  let one =
    Zpos XH
  
  (** val two : z **)
  
  let two =
    Zpos (XO XH)
  
  (** val double : z -> z **)
  
  let double = function
  | Z0 -> Z0
  | Zpos p -> Zpos (XO p)
  | Zneg p -> Zneg (XO p)
  
  (** val succ_double : z -> z **)
  
  let succ_double = function
  | Z0 -> Zpos XH
  | Zpos p -> Zpos (XI p)
  | Zneg p -> Zneg (Coq_Pos.pred_double p)
  
  (** val pred_double : z -> z **)
  
  let pred_double = function
  | Z0 -> Zneg XH
  | Zpos p -> Zpos (Coq_Pos.pred_double p)
  | Zneg p -> Zneg (XI p)
  
  (** val pos_sub : positive -> positive -> z **)
  
  let rec pos_sub x y =
    match x with
    | XI p ->
      (match y with
       | XI q -> double (pos_sub p q)
       | XO q -> succ_double (pos_sub p q)
       | XH -> Zpos (XO p))
    | XO p ->
      (match y with
       | XI q -> pred_double (pos_sub p q)
       | XO q -> double (pos_sub p q)
       | XH -> Zpos (Coq_Pos.pred_double p))
    | XH ->
      (match y with
       | XI q -> Zneg (XO q)
       | XO q -> Zneg (Coq_Pos.pred_double q)
       | XH -> Z0)
  
  (** val add : z -> z -> z **)
  
  let add x y =
    match x with
    | Z0 -> y
    | Zpos x' ->
      (match y with
       | Z0 -> x
       | Zpos y' -> Zpos (Coq_Pos.add x' y')
       | Zneg y' -> pos_sub x' y')
    | Zneg x' ->
      (match y with
       | Z0 -> x
       | Zpos y' -> pos_sub y' x'
       | Zneg y' -> Zneg (Coq_Pos.add x' y'))
  
  (** val opp : z -> z **)
  
  let opp = function
  | Z0 -> Z0
  | Zpos x0 -> Zneg x0
  | Zneg x0 -> Zpos x0
  
  (** val succ : z -> z **)
  
  let succ x =
    add x (Zpos XH)
  
  (** val pred : z -> z **)
  
  let pred x =
    add x (Zneg XH)
  
  (** val sub : z -> z -> z **)
  
  let sub m0 n0 =
    add m0 (opp n0)
  
  (** val mul : z -> z -> z **)
  
  let mul x y =
    match x with
    | Z0 -> Z0
    | Zpos x' ->
      (match y with
       | Z0 -> Z0
       | Zpos y' -> Zpos (Coq_Pos.mul x' y')
       | Zneg y' -> Zneg (Coq_Pos.mul x' y'))
    | Zneg x' ->
      (match y with
       | Z0 -> Z0
       | Zpos y' -> Zneg (Coq_Pos.mul x' y')
       | Zneg y' -> Zpos (Coq_Pos.mul x' y'))
  
  (** val pow_pos : z -> positive -> z **)
  
  let pow_pos z0 n0 =
    Coq_Pos.iter n0 (mul z0) (Zpos XH)
  
  (** val pow : z -> z -> z **)
  
  let pow x = function
  | Z0 -> Zpos XH
  | Zpos p -> pow_pos x p
  | Zneg p -> Z0
  
  (** val square : z -> z **)
  
  let square = function
  | Z0 -> Z0
  | Zpos p -> Zpos (Coq_Pos.square p)
  | Zneg p -> Zpos (Coq_Pos.square p)
  
  (** val compare : z -> z -> comparison **)
  
  let compare x y =
    match x with
    | Z0 ->
      (match y with
       | Z0 -> Eq
       | Zpos y' -> Lt
       | Zneg y' -> Gt)
    | Zpos x' ->
      (match y with
       | Zpos y' -> Coq_Pos.compare x' y'
       | _ -> Gt)
    | Zneg x' ->
      (match y with
       | Zneg y' -> compOpp (Coq_Pos.compare x' y')
       | _ -> Lt)
  
  (** val sgn : z -> z **)
  
  let sgn = function
  | Z0 -> Z0
  | Zpos p -> Zpos XH
  | Zneg p -> Zneg XH
  
  (** val leb : z -> z -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> False
    | _ -> True
  
  (** val ltb : z -> z -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> True
    | _ -> False
  
  (** val geb : z -> z -> bool **)
  
  let geb x y =
    match compare x y with
    | Lt -> False
    | _ -> True
  
  (** val gtb : z -> z -> bool **)
  
  let gtb x y =
    match compare x y with
    | Gt -> True
    | _ -> False
  
  (** val eqb : z -> z -> bool **)
  
  let rec eqb x y =
    match x with
    | Z0 ->
      (match y with
       | Z0 -> True
       | _ -> False)
    | Zpos p ->
      (match y with
       | Zpos q -> Coq_Pos.eqb p q
       | _ -> False)
    | Zneg p ->
      (match y with
       | Zneg q -> Coq_Pos.eqb p q
       | _ -> False)
  
  (** val max : z -> z -> z **)
  
  let max n0 m0 =
    match compare n0 m0 with
    | Lt -> m0
    | _ -> n0
  
  (** val min : z -> z -> z **)
  
  let min n0 m0 =
    match compare n0 m0 with
    | Gt -> m0
    | _ -> n0
  
  (** val abs : z -> z **)
  
  let abs = function
  | Zneg p -> Zpos p
  | x -> x
  
  (** val abs_nat : z -> nat **)
  
  let abs_nat = function
  | Z0 -> O
  | Zpos p -> Coq_Pos.to_nat p
  | Zneg p -> Coq_Pos.to_nat p
  
  (** val abs_N : z -> n **)
  
  let abs_N = function
  | Z0 -> N0
  | Zpos p -> Npos p
  | Zneg p -> Npos p
  
  (** val to_nat : z -> nat **)
  
  let to_nat = function
  | Zpos p -> Coq_Pos.to_nat p
  | _ -> O
  
  (** val to_N : z -> n **)
  
  let to_N = function
  | Zpos p -> Npos p
  | _ -> N0
  
  (** val of_nat : nat -> z **)
  
  let of_nat = function
  | O -> Z0
  | S n1 -> Zpos (Coq_Pos.of_succ_nat n1)
  
  (** val of_N : n -> z **)
  
  let of_N = function
  | N0 -> Z0
  | Npos p -> Zpos p
  
  (** val to_pos : z -> positive **)
  
  let to_pos = function
  | Zpos p -> p
  | _ -> XH
  
  (** val iter : z -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let iter n0 f x =
    match n0 with
    | Zpos p -> Coq_Pos.iter p f x
    | _ -> x
  
  (** val pos_div_eucl : positive -> z -> (z, z) prod **)
  
  let rec pos_div_eucl a b =
    match a with
    | XI a' ->
      let Pair (q, r) = pos_div_eucl a' b in
      let r' = add (mul (Zpos (XO XH)) r) (Zpos XH) in
      (match ltb r' b with
       | True -> Pair ((mul (Zpos (XO XH)) q), r')
       | False -> Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r' b)))
    | XO a' ->
      let Pair (q, r) = pos_div_eucl a' b in
      let r' = mul (Zpos (XO XH)) r in
      (match ltb r' b with
       | True -> Pair ((mul (Zpos (XO XH)) q), r')
       | False -> Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r' b)))
    | XH ->
      (match leb (Zpos (XO XH)) b with
       | True -> Pair (Z0, (Zpos XH))
       | False -> Pair ((Zpos XH), Z0))
  
  (** val div_eucl : z -> z -> (z, z) prod **)
  
  let div_eucl a b =
    match a with
    | Z0 -> Pair (Z0, Z0)
    | Zpos a' ->
      (match b with
       | Z0 -> Pair (Z0, Z0)
       | Zpos p -> pos_div_eucl a' b
       | Zneg b' ->
         let Pair (q, r) = pos_div_eucl a' (Zpos b') in
         (match r with
          | Z0 -> Pair ((opp q), Z0)
          | _ -> Pair ((opp (add q (Zpos XH))), (add b r))))
    | Zneg a' ->
      (match b with
       | Z0 -> Pair (Z0, Z0)
       | Zpos p ->
         let Pair (q, r) = pos_div_eucl a' b in
         (match r with
          | Z0 -> Pair ((opp q), Z0)
          | _ -> Pair ((opp (add q (Zpos XH))), (sub b r)))
       | Zneg b' ->
         let Pair (q, r) = pos_div_eucl a' (Zpos b') in Pair (q, (opp r)))
  
  (** val div : z -> z -> z **)
  
  let div a b =
    let Pair (q, x) = div_eucl a b in q
  
  (** val modulo : z -> z -> z **)
  
  let modulo a b =
    let Pair (x, r) = div_eucl a b in r
  
  (** val quotrem : z -> z -> (z, z) prod **)
  
  let quotrem a b =
    match a with
    | Z0 -> Pair (Z0, Z0)
    | Zpos a0 ->
      (match b with
       | Z0 -> Pair (Z0, a)
       | Zpos b0 ->
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (of_N r))
       | Zneg b0 ->
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (of_N r)))
    | Zneg a0 ->
      (match b with
       | Z0 -> Pair (Z0, a)
       | Zpos b0 ->
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (opp (of_N r)))
       | Zneg b0 ->
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (opp (of_N r))))
  
  (** val quot : z -> z -> z **)
  
  let quot a b =
    fst (quotrem a b)
  
  (** val rem : z -> z -> z **)
  
  let rem a b =
    snd (quotrem a b)
  
  (** val even : z -> bool **)
  
  let even = function
  | Z0 -> True
  | Zpos p ->
    (match p with
     | XO p0 -> True
     | _ -> False)
  | Zneg p ->
    (match p with
     | XO p0 -> True
     | _ -> False)
  
  (** val odd : z -> bool **)
  
  let odd = function
  | Z0 -> False
  | Zpos p ->
    (match p with
     | XO p0 -> False
     | _ -> True)
  | Zneg p ->
    (match p with
     | XO p0 -> False
     | _ -> True)
  
  (** val div2 : z -> z **)
  
  let div2 = function
  | Z0 -> Z0
  | Zpos p ->
    (match p with
     | XH -> Z0
     | _ -> Zpos (Coq_Pos.div2 p))
  | Zneg p -> Zneg (Coq_Pos.div2_up p)
  
  (** val quot2 : z -> z **)
  
  let quot2 = function
  | Z0 -> Z0
  | Zpos p ->
    (match p with
     | XH -> Z0
     | _ -> Zpos (Coq_Pos.div2 p))
  | Zneg p ->
    (match p with
     | XH -> Z0
     | _ -> Zneg (Coq_Pos.div2 p))
  
  (** val log2 : z -> z **)
  
  let log2 = function
  | Zpos p0 ->
    (match p0 with
     | XI p -> Zpos (Coq_Pos.size p)
     | XO p -> Zpos (Coq_Pos.size p)
     | XH -> Z0)
  | _ -> Z0
  
  (** val sqrtrem : z -> (z, z) prod **)
  
  let sqrtrem = function
  | Zpos p ->
    let Pair (s, m0) = Coq_Pos.sqrtrem p in
    (match m0 with
     | Coq_Pos.IsPos r -> Pair ((Zpos s), (Zpos r))
     | _ -> Pair ((Zpos s), Z0))
  | _ -> Pair (Z0, Z0)
  
  (** val sqrt : z -> z **)
  
  let sqrt = function
  | Zpos p -> Zpos (Coq_Pos.sqrt p)
  | _ -> Z0
  
  (** val gcd : z -> z -> z **)
  
  let gcd a b =
    match a with
    | Z0 -> abs b
    | Zpos a0 ->
      (match b with
       | Z0 -> abs a
       | Zpos b0 -> Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -> Zpos (Coq_Pos.gcd a0 b0))
    | Zneg a0 ->
      (match b with
       | Z0 -> abs a
       | Zpos b0 -> Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -> Zpos (Coq_Pos.gcd a0 b0))
  
  (** val ggcd : z -> z -> (z, (z, z) prod) prod **)
  
  let ggcd a b =
    match a with
    | Z0 -> Pair ((abs b), (Pair (Z0, (sgn b))))
    | Zpos a0 ->
      (match b with
       | Z0 -> Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 ->
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zpos bb))))
       | Zneg b0 ->
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zneg bb)))))
    | Zneg a0 ->
      (match b with
       | Z0 -> Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 ->
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zpos bb))))
       | Zneg b0 ->
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zneg bb)))))
  
  (** val testbit : z -> z -> bool **)
  
  let testbit a = function
  | Z0 -> odd a
  | Zpos p ->
    (match a with
     | Z0 -> False
     | Zpos a0 -> Coq_Pos.testbit a0 (Npos p)
     | Zneg a0 -> negb (N.testbit (Coq_Pos.pred_N a0) (Npos p)))
  | Zneg p -> False
  
  (** val shiftl : z -> z -> z **)
  
  let shiftl a = function
  | Z0 -> a
  | Zpos p -> Coq_Pos.iter p (mul (Zpos (XO XH))) a
  | Zneg p -> Coq_Pos.iter p div2 a
  
  (** val shiftr : z -> z -> z **)
  
  let shiftr a n0 =
    shiftl a (opp n0)
  
  (** val coq_lor : z -> z -> z **)
  
  let coq_lor a b =
    match a with
    | Z0 -> b
    | Zpos a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 -> Zpos (Coq_Pos.coq_lor a0 b0)
       | Zneg b0 -> Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) (Npos a0))))
    | Zneg a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 -> Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 ->
         Zneg
           (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  
  (** val coq_land : z -> z -> z **)
  
  let coq_land a b =
    match a with
    | Z0 -> Z0
    | Zpos a0 ->
      (match b with
       | Z0 -> Z0
       | Zpos b0 -> of_N (Coq_Pos.coq_land a0 b0)
       | Zneg b0 -> of_N (N.ldiff (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 ->
      (match b with
       | Z0 -> Z0
       | Zpos b0 -> of_N (N.ldiff (Npos b0) (Coq_Pos.pred_N a0))
       | Zneg b0 ->
         Zneg
           (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  
  (** val ldiff : z -> z -> z **)
  
  let ldiff a b =
    match a with
    | Z0 -> Z0
    | Zpos a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 -> of_N (Coq_Pos.ldiff a0 b0)
       | Zneg b0 -> of_N (N.coq_land (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 ->
         Zneg (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -> of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
  
  (** val coq_lxor : z -> z -> z **)
  
  let coq_lxor a b =
    match a with
    | Z0 -> b
    | Zpos a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 -> of_N (Coq_Pos.coq_lxor a0 b0)
       | Zneg b0 ->
         Zneg (N.succ_pos (N.coq_lxor (Npos a0) (Coq_Pos.pred_N b0))))
    | Zneg a0 ->
      (match b with
       | Z0 -> a
       | Zpos b0 ->
         Zneg (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -> of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
  
  (** val eq_dec : z -> z -> sumbool **)
  
  let eq_dec x y =
    match x with
    | Z0 ->
      (match y with
       | Z0 -> Left
       | _ -> Right)
    | Zpos x0 ->
      (match y with
       | Zpos p0 -> Coq_Pos.eq_dec x0 p0
       | _ -> Right)
    | Zneg x0 ->
      (match y with
       | Zneg p0 -> Coq_Pos.eq_dec x0 p0
       | _ -> Right)
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val leb_spec0 : z -> z -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : z -> z -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
      
     end
    
    module Tac = 
     struct 
      
     end
   end
  
  (** val sqrt_up : z -> z **)
  
  let sqrt_up a =
    match compare Z0 a with
    | Lt -> succ (sqrt (pred a))
    | _ -> Z0
  
  (** val log2_up : z -> z **)
  
  let log2_up a =
    match compare (Zpos XH) a with
    | Lt -> succ (log2 (pred a))
    | _ -> Z0
  
  module Private_NZDiv = 
   struct 
    
   end
  
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : z -> z -> z **)
      
      let div =
        quot
      
      (** val modulo : z -> z -> z **)
      
      let modulo =
        rem
     end
    
    module NZQuot = 
     struct 
      
     end
   end
  
  (** val lcm : z -> z -> z **)
  
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  
  (** val eqb_spec : z -> z -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val b2z : bool -> z **)
  
  let b2z = function
  | True -> Zpos XH
  | False -> Z0
  
  (** val setbit : z -> z -> z **)
  
  let setbit a n0 =
    coq_lor a (shiftl (Zpos XH) n0)
  
  (** val clearbit : z -> z -> z **)
  
  let clearbit a n0 =
    ldiff a (shiftl (Zpos XH) n0)
  
  (** val lnot : z -> z **)
  
  let lnot a =
    pred (opp a)
  
  (** val ones : z -> z **)
  
  let ones n0 =
    pred (shiftl (Zpos XH) n0)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        z -> z -> (z -> z -> __ -> 'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1)
        -> 'a1 **)
    
    let max_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat n0 (max n0 m0) __ (hl __)
       | _ -> compat m0 (max n0 m0) __ (hr __))
    
    (** val max_case :
        z -> z -> (z -> z -> __ -> 'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n0 m0 x x0 x1 =
      max_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : z -> z -> sumbool **)
    
    let max_dec n0 m0 =
      max_case n0 m0 (fun x y _ h0 -> h0) Left Right
    
    (** val min_case_strong :
        z -> z -> (z -> z -> __ -> 'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1)
        -> 'a1 **)
    
    let min_case_strong n0 m0 compat hl hr =
      let c = compSpec2Type n0 m0 (compare n0 m0) in
      (match c with
       | CompGtT -> compat m0 (min n0 m0) __ (hr __)
       | _ -> compat n0 (min n0 m0) __ (hl __))
    
    (** val min_case :
        z -> z -> (z -> z -> __ -> 'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n0 m0 x x0 x1 =
      min_case_strong n0 m0 x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : z -> z -> sumbool **)
    
    let min_dec n0 m0 =
      min_case n0 m0 (fun x y _ h0 -> h0) Left Right
   end
  
  (** val max_case_strong : z -> z -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n0 m0 x x0 =
    Private_Dec.max_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : z -> z -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n0 m0 x x0 =
    max_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : z -> z -> sumbool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong : z -> z -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n0 m0 x x0 =
    Private_Dec.min_case_strong n0 m0 (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : z -> z -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n0 m0 x x0 =
    min_case_strong n0 m0 (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : z -> z -> sumbool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val z_lt_dec : z -> z -> sumbool **)

let z_lt_dec x y =
  match Z.compare x y with
  | Lt -> Left
  | _ -> Right

(** val z_le_dec : z -> z -> sumbool **)

let z_le_dec x y =
  match Z.compare x y with
  | Gt -> Right
  | _ -> Left

(** val z_gt_dec : z -> z -> sumbool **)

let z_gt_dec x y =
  match Z.compare x y with
  | Gt -> Left
  | _ -> Right

(** val z_ge_dec : z -> z -> sumbool **)

let z_ge_dec x y =
  match Z.compare x y with
  | Lt -> Right
  | _ -> Left

(** val z_le_gt_dec : z -> z -> sumbool **)

let z_le_gt_dec x y =
  z_le_dec x y

(** val z_gt_le_dec : z -> z -> sumbool **)

let z_gt_le_dec x y =
  z_gt_dec x y

(** val z_ge_lt_dec : z -> z -> sumbool **)

let z_ge_lt_dec x y =
  z_ge_dec x y

(** val zeq_bool : z -> z -> bool **)

let zeq_bool x y =
  match Z.compare x y with
  | Eq -> True
  | _ -> False

type ascii =
| Ascii of bool * bool * bool * bool * bool * bool * bool * bool

(** val ascii_dec : ascii -> ascii -> sumbool **)

let ascii_dec a b =
  let Ascii (x, x0, x1, x2, x3, x4, x5, x6) = a in
  let Ascii (b8, b9, b10, b11, b12, b13, b14, b15) = b in
  (match bool_dec x b8 with
   | Left ->
     (match bool_dec x0 b9 with
      | Left ->
        (match bool_dec x1 b10 with
         | Left ->
           (match bool_dec x2 b11 with
            | Left ->
              (match bool_dec x3 b12 with
               | Left ->
                 (match bool_dec x4 b13 with
                  | Left ->
                    (match bool_dec x5 b14 with
                     | Left -> bool_dec x6 b15
                     | Right -> Right)
                  | Right -> Right)
               | Right -> Right)
            | Right -> Right)
         | Right -> Right)
      | Right -> Right)
   | Right -> Right)

type string =
| EmptyString
| String of ascii * string

(** val string_dec : string -> string -> sumbool **)

let rec string_dec s s0 =
  match s with
  | EmptyString ->
    (match s0 with
     | EmptyString -> Left
     | String (a, s1) -> Right)
  | String (a, s1) ->
    (match s0 with
     | EmptyString -> Right
     | String (a0, s2) ->
       (match ascii_dec a a0 with
        | Left -> string_dec s1 s2
        | Right -> Right))

(** val prefix : string -> string -> bool **)

let rec prefix s1 s2 =
  match s1 with
  | EmptyString -> True
  | String (a, s1') ->
    (match s2 with
     | EmptyString -> False
     | String (b, s2') ->
       (match ascii_dec a b with
        | Left -> prefix s1' s2'
        | Right -> False))

(** val shift_nat : nat -> positive -> positive **)

let shift_nat n0 z0 =
  nat_iter n0 (fun x -> XO x) z0

(** val shift_pos : positive -> positive -> positive **)

let shift_pos n0 z0 =
  Coq_Pos.iter n0 (fun x -> XO x) z0

(** val two_power_nat : nat -> z **)

let two_power_nat n0 =
  Zpos (shift_nat n0 XH)

(** val two_power_pos : positive -> z **)

let two_power_pos x =
  Zpos (shift_pos x XH)

(** val two_p : z -> z **)

let two_p = function
| Z0 -> Zpos XH
| Zpos y -> two_power_pos y
| Zneg y -> Z0

(** val peq : positive -> positive -> sumbool **)

let peq =
  Coq_Pos.eq_dec

(** val plt : positive -> positive -> sumbool **)

let plt x y =
  let c = Coq_Pos.compare x y in
  (match c with
   | Lt -> Left
   | _ -> Right)

(** val zeq : z -> z -> sumbool **)

let zeq =
  Z.eq_dec

(** val zlt : z -> z -> sumbool **)

let zlt =
  z_lt_dec

(** val zle : z -> z -> sumbool **)

let zle =
  z_le_gt_dec

(** val zdivide_dec : z -> z -> sumbool **)

let zdivide_dec p q =
  zeq (Z.modulo q p) Z0

(** val nat_of_Z : z -> nat **)

let nat_of_Z =
  Z.to_nat

(** val align : z -> z -> z **)

let align n0 amount =
  Z.mul (Z.div (Z.sub (Z.add n0 amount) (Zpos XH)) amount) amount

(** val option_eq :
    ('a1 -> 'a1 -> sumbool) -> 'a1 option -> 'a1 option -> sumbool **)

let option_eq eqA x y =
  match x with
  | Some x0 ->
    (match y with
     | Some a0 -> eqA x0 a0
     | None -> Right)
  | None ->
    (match y with
     | Some a -> Right
     | None -> Left)

(** val option_map : ('a1 -> 'a2) -> 'a1 option -> 'a2 option **)

let option_map f = function
| Some y -> Some (f y)
| None -> None

(** val sum_left_map : ('a1 -> 'a2) -> ('a1, 'a3) sum -> ('a2, 'a3) sum **)

let sum_left_map f = function
| Inl y -> Inl (f y)
| Inr z0 -> Inr z0

(** val list_length_z_aux : 'a1 list -> z -> z **)

let rec list_length_z_aux l acc =
  match l with
  | Nil -> acc
  | Cons (hd0, tl0) -> list_length_z_aux tl0 (Z.succ acc)

(** val list_length_z : 'a1 list -> z **)

let list_length_z l =
  list_length_z_aux l Z0

(** val list_nth_z : 'a1 list -> z -> 'a1 option **)

let rec list_nth_z l n0 =
  match l with
  | Nil -> None
  | Cons (hd0, tl0) ->
    (match zeq n0 Z0 with
     | Left -> Some hd0
     | Right -> list_nth_z tl0 (Z.pred n0))

(** val list_fold_left : ('a1 -> 'a2 -> 'a2) -> 'a2 -> 'a1 list -> 'a2 **)

let rec list_fold_left f accu = function
| Nil -> accu
| Cons (x, l') -> list_fold_left f (f x accu) l'

(** val list_fold_right : ('a1 -> 'a2 -> 'a2) -> 'a1 list -> 'a2 -> 'a2 **)

let list_fold_right f l base =
  list_fold_left f base (rev' l)

(** val list_disjoint_dec :
    ('a1 -> 'a1 -> sumbool) -> 'a1 list -> 'a1 list -> sumbool **)

let rec list_disjoint_dec eqA_dec l1 l2 =
  match l1 with
  | Nil -> Left
  | Cons (y, l) ->
    (match in_dec eqA_dec y l2 with
     | Left -> Right
     | Right -> list_disjoint_dec eqA_dec l l2)

(** val list_norepet_dec : ('a1 -> 'a1 -> sumbool) -> 'a1 list -> sumbool **)

let rec list_norepet_dec eqA_dec = function
| Nil -> Left
| Cons (y, l0) ->
  (match list_norepet_dec eqA_dec l0 with
   | Left ->
     (match in_dec eqA_dec y l0 with
      | Left -> Right
      | Right -> Left)
   | Right -> Right)

(** val list_repeat : nat -> 'a1 -> 'a1 list **)

let rec list_repeat n0 x =
  match n0 with
  | O -> Nil
  | S m0 -> Cons (x, (list_repeat m0 x))

(** val proj_sumbool : sumbool -> bool **)

let proj_sumbool = function
| Left -> True
| Right -> False

type errcode =
| MSG of string
| CTX of positive
| POS of positive

type errmsg = errcode list

(** val msg : string -> errmsg **)

let msg s =
  Cons ((MSG s), Nil)

type 'a res =
| OK of 'a
| Error of errmsg

(** val bind : 'a1 res -> ('a1 -> 'a2 res) -> 'a2 res **)

let bind f g =
  match f with
  | OK x -> g x
  | Error msg0 -> Error msg0

(** val bind2 : ('a1, 'a2) prod res -> ('a1 -> 'a2 -> 'a3 res) -> 'a3 res **)

let bind2 f g =
  match f with
  | OK p -> let Pair (x, y) = p in g x y
  | Error msg0 -> Error msg0

(** val assertion_failed : 'a1 res **)

let assertion_failed =
  Error
    (msg (String ((Ascii (True, False, False, False, False, False, True,
      False)), (String ((Ascii (True, True, False, False, True, True, True,
      False)), (String ((Ascii (True, True, False, False, True, True, True,
      False)), (String ((Ascii (True, False, True, False, False, True, True,
      False)), (String ((Ascii (False, True, False, False, True, True, True,
      False)), (String ((Ascii (False, False, True, False, True, True, True,
      False)), (String ((Ascii (True, False, False, True, False, True, True,
      False)), (String ((Ascii (True, True, True, True, False, True, True,
      False)), (String ((Ascii (False, True, True, True, False, True, True,
      False)), (String ((Ascii (False, False, False, False, False, True,
      False, False)), (String ((Ascii (False, True, True, False, False, True,
      True, False)), (String ((Ascii (True, False, False, False, False, True,
      True, False)), (String ((Ascii (True, False, False, True, False, True,
      True, False)), (String ((Ascii (False, False, True, True, False, True,
      True, False)), (String ((Ascii (True, False, True, False, False, True,
      True, False)), (String ((Ascii (False, False, True, False, False, True,
      True, False)), EmptyString)))))))))))))))))))))))))))))))))

type comparison0 =
| Ceq
| Cne
| Clt
| Cle
| Cgt
| Cge

(** val negate_comparison : comparison0 -> comparison0 **)

let negate_comparison = function
| Ceq -> Cne
| Cne -> Ceq
| Clt -> Cge
| Cle -> Cgt
| Cgt -> Cle
| Cge -> Clt

(** val swap_comparison : comparison0 -> comparison0 **)

let swap_comparison = function
| Clt -> Cgt
| Cle -> Cge
| Cgt -> Clt
| Cge -> Cle
| x -> x

module type WORDSIZE = 
 sig 
  val wordsize : nat
 end

module Make = 
 functor (WS:WORDSIZE) ->
 struct 
  (** val wordsize : nat **)
  
  let wordsize =
    WS.wordsize
  
  (** val zwordsize : z **)
  
  let zwordsize =
    Z.of_nat wordsize
  
  (** val modulus : z **)
  
  let modulus =
    two_power_nat wordsize
  
  (** val half_modulus : z **)
  
  let half_modulus =
    Z.div modulus (Zpos (XO XH))
  
  (** val max_unsigned : z **)
  
  let max_unsigned =
    Z.sub modulus (Zpos XH)
  
  (** val max_signed : z **)
  
  let max_signed =
    Z.sub half_modulus (Zpos XH)
  
  (** val min_signed : z **)
  
  let min_signed =
    Z.opp half_modulus
  
  type int =
    z
    (* singleton inductive, whose constructor was mkint *)
  
  (** val intval : int -> z **)
  
  let intval i =
    i
  
  (** val coq_P_mod_two_p : positive -> nat -> z **)
  
  let rec coq_P_mod_two_p p = function
  | O -> Z0
  | S m0 ->
    (match p with
     | XI q -> Z.succ_double (coq_P_mod_two_p q m0)
     | XO q -> Z.double (coq_P_mod_two_p q m0)
     | XH -> Zpos XH)
  
  (** val coq_Z_mod_modulus : z -> z **)
  
  let coq_Z_mod_modulus = function
  | Z0 -> Z0
  | Zpos p -> coq_P_mod_two_p p wordsize
  | Zneg p ->
    let r = coq_P_mod_two_p p wordsize in
    (match zeq r Z0 with
     | Left -> Z0
     | Right -> Z.sub modulus r)
  
  (** val unsigned : int -> z **)
  
  let unsigned n0 =
    intval n0
  
  (** val signed : int -> z **)
  
  let signed n0 =
    let x = unsigned n0 in
    (match zlt x half_modulus with
     | Left -> x
     | Right -> Z.sub x modulus)
  
  (** val repr : z -> int **)
  
  let repr x =
    coq_Z_mod_modulus x
  
  (** val zero : int **)
  
  let zero =
    repr Z0
  
  (** val one : int **)
  
  let one =
    repr (Zpos XH)
  
  (** val mone : int **)
  
  let mone =
    repr (Zneg XH)
  
  (** val iwordsize : int **)
  
  let iwordsize =
    repr zwordsize
  
  (** val eq_dec : int -> int -> sumbool **)
  
  let eq_dec x y =
    zeq x y
  
  (** val eq : int -> int -> bool **)
  
  let eq x y =
    match zeq (unsigned x) (unsigned y) with
    | Left -> True
    | Right -> False
  
  (** val lt : int -> int -> bool **)
  
  let lt x y =
    match zlt (signed x) (signed y) with
    | Left -> True
    | Right -> False
  
  (** val ltu : int -> int -> bool **)
  
  let ltu x y =
    match zlt (unsigned x) (unsigned y) with
    | Left -> True
    | Right -> False
  
  (** val neg : int -> int **)
  
  let neg x =
    repr (Z.opp (unsigned x))
  
  (** val add : int -> int -> int **)
  
  let add x y =
    repr (Z.add (unsigned x) (unsigned y))
  
  (** val sub : int -> int -> int **)
  
  let sub x y =
    repr (Z.sub (unsigned x) (unsigned y))
  
  (** val mul : int -> int -> int **)
  
  let mul x y =
    repr (Z.mul (unsigned x) (unsigned y))
  
  (** val divs : int -> int -> int **)
  
  let divs x y =
    repr (Z.quot (signed x) (signed y))
  
  (** val mods : int -> int -> int **)
  
  let mods x y =
    repr (Z.rem (signed x) (signed y))
  
  (** val divu : int -> int -> int **)
  
  let divu x y =
    repr (Z.div (unsigned x) (unsigned y))
  
  (** val modu : int -> int -> int **)
  
  let modu x y =
    repr (Z.modulo (unsigned x) (unsigned y))
  
  (** val coq_and : int -> int -> int **)
  
  let coq_and x y =
    repr (Z.coq_land (unsigned x) (unsigned y))
  
  (** val coq_or : int -> int -> int **)
  
  let coq_or x y =
    repr (Z.coq_lor (unsigned x) (unsigned y))
  
  (** val xor : int -> int -> int **)
  
  let xor x y =
    repr (Z.coq_lxor (unsigned x) (unsigned y))
  
  (** val not : int -> int **)
  
  let not x =
    xor x mone
  
  (** val shl : int -> int -> int **)
  
  let shl x y =
    repr (Z.shiftl (unsigned x) (unsigned y))
  
  (** val shru : int -> int -> int **)
  
  let shru x y =
    repr (Z.shiftr (unsigned x) (unsigned y))
  
  (** val shr : int -> int -> int **)
  
  let shr x y =
    repr (Z.shiftr (signed x) (unsigned y))
  
  (** val rol : int -> int -> int **)
  
  let rol x y =
    let n0 = Z.modulo (unsigned y) zwordsize in
    repr
      (Z.coq_lor (Z.shiftl (unsigned x) n0)
        (Z.shiftr (unsigned x) (Z.sub zwordsize n0)))
  
  (** val ror : int -> int -> int **)
  
  let ror x y =
    let n0 = Z.modulo (unsigned y) zwordsize in
    repr
      (Z.coq_lor (Z.shiftr (unsigned x) n0)
        (Z.shiftl (unsigned x) (Z.sub zwordsize n0)))
  
  (** val rolm : int -> int -> int -> int **)
  
  let rolm x a m0 =
    coq_and (rol x a) m0
  
  (** val shrx : int -> int -> int **)
  
  let shrx x y =
    divs x (shl one y)
  
  (** val mulhu : int -> int -> int **)
  
  let mulhu x y =
    repr (Z.div (Z.mul (unsigned x) (unsigned y)) modulus)
  
  (** val mulhs : int -> int -> int **)
  
  let mulhs x y =
    repr (Z.div (Z.mul (signed x) (signed y)) modulus)
  
  (** val negative : int -> int **)
  
  let negative x =
    match lt x zero with
    | True -> one
    | False -> zero
  
  (** val add_carry : int -> int -> int -> int **)
  
  let add_carry x y cin =
    match zlt (Z.add (Z.add (unsigned x) (unsigned y)) (unsigned cin))
            modulus with
    | Left -> zero
    | Right -> one
  
  (** val add_overflow : int -> int -> int -> int **)
  
  let add_overflow x y cin =
    let s = Z.add (Z.add (signed x) (signed y)) (signed cin) in
    (match match proj_sumbool (zle min_signed s) with
           | True -> proj_sumbool (zle s max_signed)
           | False -> False with
     | True -> zero
     | False -> one)
  
  (** val sub_borrow : int -> int -> int -> int **)
  
  let sub_borrow x y bin =
    match zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned bin)) Z0 with
    | Left -> one
    | Right -> zero
  
  (** val sub_overflow : int -> int -> int -> int **)
  
  let sub_overflow x y bin =
    let s = Z.sub (Z.sub (signed x) (signed y)) (signed bin) in
    (match match proj_sumbool (zle min_signed s) with
           | True -> proj_sumbool (zle s max_signed)
           | False -> False with
     | True -> zero
     | False -> one)
  
  (** val shr_carry : int -> int -> int **)
  
  let shr_carry x y =
    match match lt x zero with
          | True -> negb (eq (coq_and x (sub (shl one y) one)) zero)
          | False -> False with
    | True -> one
    | False -> zero
  
  (** val coq_Zshiftin : bool -> z -> z **)
  
  let coq_Zshiftin b x =
    match b with
    | True -> Z.succ_double x
    | False -> Z.double x
  
  (** val coq_Zzero_ext : z -> z -> z **)
  
  let coq_Zzero_ext n0 x =
    Z.iter n0 (fun rec0 x0 -> coq_Zshiftin (Z.odd x0) (rec0 (Z.div2 x0)))
      (fun x0 -> Z0) x
  
  (** val coq_Zsign_ext : z -> z -> z **)
  
  let coq_Zsign_ext n0 x =
    Z.iter (Z.pred n0) (fun rec0 x0 ->
      coq_Zshiftin (Z.odd x0) (rec0 (Z.div2 x0))) (fun x0 ->
      match Z.odd x0 with
      | True -> Zneg XH
      | False -> Z0) x
  
  (** val zero_ext : z -> int -> int **)
  
  let zero_ext n0 x =
    repr (coq_Zzero_ext n0 (unsigned x))
  
  (** val sign_ext : z -> int -> int **)
  
  let sign_ext n0 x =
    repr (coq_Zsign_ext n0 (unsigned x))
  
  (** val coq_Z_one_bits : nat -> z -> z -> z list **)
  
  let rec coq_Z_one_bits n0 x i =
    match n0 with
    | O -> Nil
    | S m0 ->
      (match Z.odd x with
       | True -> Cons (i, (coq_Z_one_bits m0 (Z.div2 x) (Z.add i (Zpos XH))))
       | False -> coq_Z_one_bits m0 (Z.div2 x) (Z.add i (Zpos XH)))
  
  (** val one_bits : int -> int list **)
  
  let one_bits x =
    map repr (coq_Z_one_bits wordsize (unsigned x) Z0)
  
  (** val is_power2 : int -> int option **)
  
  let is_power2 x =
    match coq_Z_one_bits wordsize (unsigned x) Z0 with
    | Nil -> None
    | Cons (i, l) ->
      (match l with
       | Nil -> Some (repr i)
       | Cons (z0, l0) -> None)
  
  (** val cmp : comparison0 -> int -> int -> bool **)
  
  let cmp c x y =
    match c with
    | Ceq -> eq x y
    | Cne -> negb (eq x y)
    | Clt -> lt x y
    | Cle -> negb (lt y x)
    | Cgt -> lt y x
    | Cge -> negb (lt x y)
  
  (** val cmpu : comparison0 -> int -> int -> bool **)
  
  let cmpu c x y =
    match c with
    | Ceq -> eq x y
    | Cne -> negb (eq x y)
    | Clt -> ltu x y
    | Cle -> negb (ltu y x)
    | Cgt -> ltu y x
    | Cge -> negb (ltu x y)
  
  (** val notbool : int -> int **)
  
  let notbool x =
    match eq x zero with
    | True -> one
    | False -> zero
  
  (** val testbit : int -> z -> bool **)
  
  let testbit x i =
    Z.testbit (unsigned x) i
  
  (** val powerserie : z list -> z **)
  
  let rec powerserie = function
  | Nil -> Z0
  | Cons (x, xs) -> Z.add (two_p x) (powerserie xs)
  
  (** val int_of_one_bits : int list -> int **)
  
  let rec int_of_one_bits = function
  | Nil -> zero
  | Cons (a, b) -> add (shl one a) (int_of_one_bits b)
  
  (** val no_overlap : int -> z -> int -> z -> bool **)
  
  let no_overlap ofs1 sz1 ofs2 sz2 =
    let x1 = unsigned ofs1 in
    let x2 = unsigned ofs2 in
    (match match proj_sumbool (zlt (Z.add x1 sz1) modulus) with
           | True -> proj_sumbool (zlt (Z.add x2 sz2) modulus)
           | False -> False with
     | True ->
       (match proj_sumbool (zle (Z.add x1 sz1) x2) with
        | True -> True
        | False -> proj_sumbool (zle (Z.add x2 sz2) x1))
     | False -> False)
  
  (** val coq_Zsize : z -> z **)
  
  let coq_Zsize = function
  | Zpos p -> Zpos (Coq_Pos.size p)
  | _ -> Z0
  
  (** val size : int -> z **)
  
  let size x =
    coq_Zsize (unsigned x)
 end

module Wordsize_32 = 
 struct 
  (** val wordsize : nat **)
  
  let wordsize =
    S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S O)))))))))))))))))))))))))))))))
 end

module Int = Make(Wordsize_32)

module Wordsize_8 = 
 struct 
  (** val wordsize : nat **)
  
  let wordsize =
    S (S (S (S (S (S (S (S O)))))))
 end

module Byte = Make(Wordsize_8)

module Wordsize_64 = 
 struct 
  (** val wordsize : nat **)
  
  let wordsize =
    S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 end

module Int64 = 
 struct 
  (** val wordsize : nat **)
  
  let wordsize =
    Wordsize_64.wordsize
  
  (** val zwordsize : z **)
  
  let zwordsize =
    Z.of_nat wordsize
  
  (** val modulus : z **)
  
  let modulus =
    two_power_nat wordsize
  
  (** val half_modulus : z **)
  
  let half_modulus =
    Z.div modulus (Zpos (XO XH))
  
  (** val max_unsigned : z **)
  
  let max_unsigned =
    Z.sub modulus (Zpos XH)
  
  (** val max_signed : z **)
  
  let max_signed =
    Z.sub half_modulus (Zpos XH)
  
  (** val min_signed : z **)
  
  let min_signed =
    Z.opp half_modulus
  
  type int =
    z
    (* singleton inductive, whose constructor was mkint *)
  
  (** val intval : int -> z **)
  
  let intval i =
    i
  
  (** val coq_P_mod_two_p : positive -> nat -> z **)
  
  let rec coq_P_mod_two_p p = function
  | O -> Z0
  | S m0 ->
    (match p with
     | XI q -> Z.succ_double (coq_P_mod_two_p q m0)
     | XO q -> Z.double (coq_P_mod_two_p q m0)
     | XH -> Zpos XH)
  
  (** val coq_Z_mod_modulus : z -> z **)
  
  let coq_Z_mod_modulus = function
  | Z0 -> Z0
  | Zpos p -> coq_P_mod_two_p p wordsize
  | Zneg p ->
    let r = coq_P_mod_two_p p wordsize in
    (match zeq r Z0 with
     | Left -> Z0
     | Right -> Z.sub modulus r)
  
  (** val unsigned : int -> z **)
  
  let unsigned n0 =
    intval n0
  
  (** val signed : int -> z **)
  
  let signed n0 =
    let x = unsigned n0 in
    (match zlt x half_modulus with
     | Left -> x
     | Right -> Z.sub x modulus)
  
  (** val repr : z -> int **)
  
  let repr x =
    coq_Z_mod_modulus x
  
  (** val zero : int **)
  
  let zero =
    repr Z0
  
  (** val one : int **)
  
  let one =
    repr (Zpos XH)
  
  (** val mone : int **)
  
  let mone =
    repr (Zneg XH)
  
  (** val iwordsize : int **)
  
  let iwordsize =
    repr zwordsize
  
  (** val eq_dec : int -> int -> sumbool **)
  
  let eq_dec x y =
    zeq x y
  
  (** val eq : int -> int -> bool **)
  
  let eq x y =
    match zeq (unsigned x) (unsigned y) with
    | Left -> True
    | Right -> False
  
  (** val lt : int -> int -> bool **)
  
  let lt x y =
    match zlt (signed x) (signed y) with
    | Left -> True
    | Right -> False
  
  (** val ltu : int -> int -> bool **)
  
  let ltu x y =
    match zlt (unsigned x) (unsigned y) with
    | Left -> True
    | Right -> False
  
  (** val neg : int -> int **)
  
  let neg x =
    repr (Z.opp (unsigned x))
  
  (** val add : int -> int -> int **)
  
  let add x y =
    repr (Z.add (unsigned x) (unsigned y))
  
  (** val sub : int -> int -> int **)
  
  let sub x y =
    repr (Z.sub (unsigned x) (unsigned y))
  
  (** val mul : int -> int -> int **)
  
  let mul x y =
    repr (Z.mul (unsigned x) (unsigned y))
  
  (** val divs : int -> int -> int **)
  
  let divs x y =
    repr (Z.quot (signed x) (signed y))
  
  (** val mods : int -> int -> int **)
  
  let mods x y =
    repr (Z.rem (signed x) (signed y))
  
  (** val divu : int -> int -> int **)
  
  let divu x y =
    repr (Z.div (unsigned x) (unsigned y))
  
  (** val modu : int -> int -> int **)
  
  let modu x y =
    repr (Z.modulo (unsigned x) (unsigned y))
  
  (** val coq_and : int -> int -> int **)
  
  let coq_and x y =
    repr (Z.coq_land (unsigned x) (unsigned y))
  
  (** val coq_or : int -> int -> int **)
  
  let coq_or x y =
    repr (Z.coq_lor (unsigned x) (unsigned y))
  
  (** val xor : int -> int -> int **)
  
  let xor x y =
    repr (Z.coq_lxor (unsigned x) (unsigned y))
  
  (** val not : int -> int **)
  
  let not x =
    xor x mone
  
  (** val shl : int -> int -> int **)
  
  let shl x y =
    repr (Z.shiftl (unsigned x) (unsigned y))
  
  (** val shru : int -> int -> int **)
  
  let shru x y =
    repr (Z.shiftr (unsigned x) (unsigned y))
  
  (** val shr : int -> int -> int **)
  
  let shr x y =
    repr (Z.shiftr (signed x) (unsigned y))
  
  (** val rol : int -> int -> int **)
  
  let rol x y =
    let n0 = Z.modulo (unsigned y) zwordsize in
    repr
      (Z.coq_lor (Z.shiftl (unsigned x) n0)
        (Z.shiftr (unsigned x) (Z.sub zwordsize n0)))
  
  (** val ror : int -> int -> int **)
  
  let ror x y =
    let n0 = Z.modulo (unsigned y) zwordsize in
    repr
      (Z.coq_lor (Z.shiftr (unsigned x) n0)
        (Z.shiftl (unsigned x) (Z.sub zwordsize n0)))
  
  (** val rolm : int -> int -> int -> int **)
  
  let rolm x a m0 =
    coq_and (rol x a) m0
  
  (** val shrx : int -> int -> int **)
  
  let shrx x y =
    divs x (shl one y)
  
  (** val mulhu : int -> int -> int **)
  
  let mulhu x y =
    repr (Z.div (Z.mul (unsigned x) (unsigned y)) modulus)
  
  (** val mulhs : int -> int -> int **)
  
  let mulhs x y =
    repr (Z.div (Z.mul (signed x) (signed y)) modulus)
  
  (** val negative : int -> int **)
  
  let negative x =
    match lt x zero with
    | True -> one
    | False -> zero
  
  (** val add_carry : int -> int -> int -> int **)
  
  let add_carry x y cin =
    match zlt (Z.add (Z.add (unsigned x) (unsigned y)) (unsigned cin))
            modulus with
    | Left -> zero
    | Right -> one
  
  (** val add_overflow : int -> int -> int -> int **)
  
  let add_overflow x y cin =
    let s = Z.add (Z.add (signed x) (signed y)) (signed cin) in
    (match match proj_sumbool (zle min_signed s) with
           | True -> proj_sumbool (zle s max_signed)
           | False -> False with
     | True -> zero
     | False -> one)
  
  (** val sub_borrow : int -> int -> int -> int **)
  
  let sub_borrow x y bin =
    match zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned bin)) Z0 with
    | Left -> one
    | Right -> zero
  
  (** val sub_overflow : int -> int -> int -> int **)
  
  let sub_overflow x y bin =
    let s = Z.sub (Z.sub (signed x) (signed y)) (signed bin) in
    (match match proj_sumbool (zle min_signed s) with
           | True -> proj_sumbool (zle s max_signed)
           | False -> False with
     | True -> zero
     | False -> one)
  
  (** val shr_carry : int -> int -> int **)
  
  let shr_carry x y =
    match match lt x zero with
          | True -> negb (eq (coq_and x (sub (shl one y) one)) zero)
          | False -> False with
    | True -> one
    | False -> zero
  
  (** val coq_Zshiftin : bool -> z -> z **)
  
  let coq_Zshiftin b x =
    match b with
    | True -> Z.succ_double x
    | False -> Z.double x
  
  (** val coq_Zzero_ext : z -> z -> z **)
  
  let coq_Zzero_ext n0 x =
    Z.iter n0 (fun rec0 x0 -> coq_Zshiftin (Z.odd x0) (rec0 (Z.div2 x0)))
      (fun x0 -> Z0) x
  
  (** val coq_Zsign_ext : z -> z -> z **)
  
  let coq_Zsign_ext n0 x =
    Z.iter (Z.pred n0) (fun rec0 x0 ->
      coq_Zshiftin (Z.odd x0) (rec0 (Z.div2 x0))) (fun x0 ->
      match Z.odd x0 with
      | True -> Zneg XH
      | False -> Z0) x
  
  (** val zero_ext : z -> int -> int **)
  
  let zero_ext n0 x =
    repr (coq_Zzero_ext n0 (unsigned x))
  
  (** val sign_ext : z -> int -> int **)
  
  let sign_ext n0 x =
    repr (coq_Zsign_ext n0 (unsigned x))
  
  (** val coq_Z_one_bits : nat -> z -> z -> z list **)
  
  let rec coq_Z_one_bits n0 x i =
    match n0 with
    | O -> Nil
    | S m0 ->
      (match Z.odd x with
       | True -> Cons (i, (coq_Z_one_bits m0 (Z.div2 x) (Z.add i (Zpos XH))))
       | False -> coq_Z_one_bits m0 (Z.div2 x) (Z.add i (Zpos XH)))
  
  (** val one_bits : int -> int list **)
  
  let one_bits x =
    map repr (coq_Z_one_bits wordsize (unsigned x) Z0)
  
  (** val is_power2 : int -> int option **)
  
  let is_power2 x =
    match coq_Z_one_bits wordsize (unsigned x) Z0 with
    | Nil -> None
    | Cons (i, l) ->
      (match l with
       | Nil -> Some (repr i)
       | Cons (z0, l0) -> None)
  
  (** val cmp : comparison0 -> int -> int -> bool **)
  
  let cmp c x y =
    match c with
    | Ceq -> eq x y
    | Cne -> negb (eq x y)
    | Clt -> lt x y
    | Cle -> negb (lt y x)
    | Cgt -> lt y x
    | Cge -> negb (lt x y)
  
  (** val cmpu : comparison0 -> int -> int -> bool **)
  
  let cmpu c x y =
    match c with
    | Ceq -> eq x y
    | Cne -> negb (eq x y)
    | Clt -> ltu x y
    | Cle -> negb (ltu y x)
    | Cgt -> ltu y x
    | Cge -> negb (ltu x y)
  
  (** val notbool : int -> int **)
  
  let notbool x =
    match eq x zero with
    | True -> one
    | False -> zero
  
  (** val testbit : int -> z -> bool **)
  
  let testbit x i =
    Z.testbit (unsigned x) i
  
  (** val powerserie : z list -> z **)
  
  let rec powerserie = function
  | Nil -> Z0
  | Cons (x, xs) -> Z.add (two_p x) (powerserie xs)
  
  (** val int_of_one_bits : int list -> int **)
  
  let rec int_of_one_bits = function
  | Nil -> zero
  | Cons (a, b) -> add (shl one a) (int_of_one_bits b)
  
  (** val no_overlap : int -> z -> int -> z -> bool **)
  
  let no_overlap ofs1 sz1 ofs2 sz2 =
    let x1 = unsigned ofs1 in
    let x2 = unsigned ofs2 in
    (match match proj_sumbool (zlt (Z.add x1 sz1) modulus) with
           | True -> proj_sumbool (zlt (Z.add x2 sz2) modulus)
           | False -> False with
     | True ->
       (match proj_sumbool (zle (Z.add x1 sz1) x2) with
        | True -> True
        | False -> proj_sumbool (zle (Z.add x2 sz2) x1))
     | False -> False)
  
  (** val coq_Zsize : z -> z **)
  
  let coq_Zsize = function
  | Zpos p -> Zpos (Coq_Pos.size p)
  | _ -> Z0
  
  (** val size : int -> z **)
  
  let size x =
    coq_Zsize (unsigned x)
  
  (** val iwordsize' : Int.int **)
  
  let iwordsize' =
    Int.repr zwordsize
  
  (** val shl' : int -> Int.int -> int **)
  
  let shl' x y =
    repr (Z.shiftl (unsigned x) (Int.unsigned y))
  
  (** val shru' : int -> Int.int -> int **)
  
  let shru' x y =
    repr (Z.shiftr (unsigned x) (Int.unsigned y))
  
  (** val shr' : int -> Int.int -> int **)
  
  let shr' x y =
    repr (Z.shiftr (signed x) (Int.unsigned y))
  
  (** val loword : int -> Int.int **)
  
  let loword n0 =
    Int.repr (unsigned n0)
  
  (** val hiword : int -> Int.int **)
  
  let hiword n0 =
    Int.repr (unsigned (shru n0 (repr Int.zwordsize)))
  
  (** val ofwords : Int.int -> Int.int -> int **)
  
  let ofwords hi lo =
    coq_or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize))
      (repr (Int.unsigned lo))
  
  (** val mul' : Int.int -> Int.int -> int **)
  
  let mul' x y =
    repr (Z.mul (Int.unsigned x) (Int.unsigned y))
 end

(** val zeven : z -> bool **)

let zeven = function
| Z0 -> True
| Zpos p ->
  (match p with
   | XO p0 -> True
   | _ -> False)
| Zneg p ->
  (match p with
   | XO p0 -> True
   | _ -> False)

type radix =
  z
  (* singleton inductive, whose constructor was Build_radix *)

(** val radix_val : radix -> z **)

let radix_val r =
  r

(** val radix2 : radix **)

let radix2 =
  Zpos (XO XH)

(** val cond_Zopp : bool -> z -> z **)

let cond_Zopp b m0 =
  match b with
  | True -> Z.opp m0
  | False -> m0

(** val zpos_div_eucl_aux1 : positive -> positive -> (z, z) prod **)

let rec zpos_div_eucl_aux1 a b = match b with
| XI p -> Z.pos_div_eucl a (Zpos b)
| XO b' ->
  (match a with
   | XI a' ->
     let Pair (q, r) = zpos_div_eucl_aux1 a' b' in
     Pair (q, (Z.add (Z.mul (Zpos (XO XH)) r) (Zpos XH)))
   | XO a' ->
     let Pair (q, r) = zpos_div_eucl_aux1 a' b' in
     Pair (q, (Z.mul (Zpos (XO XH)) r))
   | XH -> Pair (Z0, (Zpos a)))
| XH -> Pair ((Zpos a), Z0)

(** val zpos_div_eucl_aux : positive -> positive -> (z, z) prod **)

let zpos_div_eucl_aux a b =
  match Coq_Pos.compare a b with
  | Eq -> Pair ((Zpos XH), Z0)
  | Lt -> Pair (Z0, (Zpos a))
  | Gt -> zpos_div_eucl_aux1 a b

(** val zfast_div_eucl : z -> z -> (z, z) prod **)

let zfast_div_eucl a b =
  match a with
  | Z0 -> Pair (Z0, Z0)
  | Zpos a' ->
    (match b with
     | Z0 -> Pair (Z0, Z0)
     | Zpos b' -> zpos_div_eucl_aux a' b'
     | Zneg b' ->
       let Pair (q, r) = zpos_div_eucl_aux a' b' in
       (match r with
        | Z0 -> Pair ((Z.opp q), Z0)
        | _ -> Pair ((Z.opp (Z.add q (Zpos XH))), (Z.add b r))))
  | Zneg a' ->
    (match b with
     | Z0 -> Pair (Z0, Z0)
     | Zpos b' ->
       let Pair (q, r) = zpos_div_eucl_aux a' b' in
       (match r with
        | Z0 -> Pair ((Z.opp q), Z0)
        | _ -> Pair ((Z.opp (Z.add q (Zpos XH))), (Z.sub b r)))
     | Zneg b' ->
       let Pair (q, r) = zpos_div_eucl_aux a' b' in Pair (q, (Z.opp r)))

(** val iter_pos : ('a1 -> 'a1) -> positive -> 'a1 -> 'a1 **)

let rec iter_pos f n0 x =
  match n0 with
  | XI n' -> iter_pos f n' (iter_pos f n' (f x))
  | XO n' -> iter_pos f n' (iter_pos f n' x)
  | XH -> f x

(** val fLT_exp : z -> z -> z -> z **)

let fLT_exp emin prec e =
  Z.max (Z.sub e prec) emin

(** val digits2_pos : positive -> positive **)

let rec digits2_pos = function
| XI p -> Coq_Pos.succ (digits2_pos p)
| XO p -> Coq_Pos.succ (digits2_pos p)
| XH -> XH

(** val zdigits2 : z -> z **)

let zdigits2 n0 = match n0 with
| Z0 -> n0
| Zpos p -> Zpos (digits2_pos p)
| Zneg p -> Zpos (digits2_pos p)

type location =
| Loc_Exact
| Loc_Inexact of comparison

(** val new_location_even : z -> z -> location -> location **)

let new_location_even nb_steps k l =
  match zeq_bool k Z0 with
  | True ->
    (match l with
     | Loc_Exact -> l
     | Loc_Inexact c -> Loc_Inexact Lt)
  | False ->
    Loc_Inexact
      (match Z.compare (Z.mul (Zpos (XO XH)) k) nb_steps with
       | Eq ->
         (match l with
          | Loc_Exact -> Eq
          | Loc_Inexact c -> Gt)
       | x -> x)

(** val new_location_odd : z -> z -> location -> location **)

let new_location_odd nb_steps k l =
  match zeq_bool k Z0 with
  | True ->
    (match l with
     | Loc_Exact -> l
     | Loc_Inexact c -> Loc_Inexact Lt)
  | False ->
    Loc_Inexact
      (match Z.compare (Z.add (Z.mul (Zpos (XO XH)) k) (Zpos XH)) nb_steps with
       | Eq ->
         (match l with
          | Loc_Exact -> Lt
          | Loc_Inexact l0 -> l0)
       | x -> x)

(** val new_location : z -> z -> location -> location **)

let new_location nb_steps =
  match zeven nb_steps with
  | True -> new_location_even nb_steps
  | False -> new_location_odd nb_steps

(** val cond_incr : bool -> z -> z **)

let cond_incr b m0 =
  match b with
  | True -> Z.add m0 (Zpos XH)
  | False -> m0

(** val round_sign_DN : bool -> location -> bool **)

let round_sign_DN s = function
| Loc_Exact -> False
| Loc_Inexact c -> s

(** val round_sign_UP : bool -> location -> bool **)

let round_sign_UP s = function
| Loc_Exact -> False
| Loc_Inexact c -> negb s

(** val round_N : bool -> location -> bool **)

let round_N p = function
| Loc_Exact -> False
| Loc_Inexact c ->
  (match c with
   | Eq -> p
   | Lt -> False
   | Gt -> True)

type full_float =
| F754_zero of bool
| F754_infinity of bool
| F754_nan of bool * positive
| F754_finite of bool * positive * z

type nan_pl = positive

type binary_float =
| B754_zero of bool
| B754_infinity of bool
| B754_nan of bool * nan_pl
| B754_finite of bool * positive * z

(** val fF2B : z -> z -> full_float -> binary_float **)

let fF2B prec emax = function
| F754_zero s -> B754_zero s
| F754_infinity s -> B754_infinity s
| F754_nan (b, pl) -> B754_nan (b, pl)
| F754_finite (s, m0, e) -> B754_finite (s, m0, e)

(** val bopp :
    z -> z -> (bool -> nan_pl -> (bool, nan_pl) prod) -> binary_float ->
    binary_float **)

let bopp prec emax opp_nan = function
| B754_zero sx -> B754_zero (negb sx)
| B754_infinity sx -> B754_infinity (negb sx)
| B754_nan (sx, plx) ->
  let Pair (sres, plres) = opp_nan sx plx in B754_nan (sres, plres)
| B754_finite (sx, mx, ex) -> B754_finite ((negb sx), mx, ex)

(** val babs :
    z -> z -> (bool -> nan_pl -> (bool, nan_pl) prod) -> binary_float ->
    binary_float **)

let babs prec emax abs_nan = function
| B754_zero sx -> B754_zero False
| B754_infinity sx -> B754_infinity False
| B754_nan (sx, plx) ->
  let Pair (sres, plres) = abs_nan sx plx in B754_nan (sres, plres)
| B754_finite (sx, mx, ex) -> B754_finite (False, mx, ex)

(** val bcompare :
    z -> z -> binary_float -> binary_float -> comparison option **)

let bcompare prec emax f1 f2 =
  match f1 with
  | B754_zero b ->
    (match f2 with
     | B754_zero b0 -> Some Eq
     | B754_infinity b0 ->
       (match b0 with
        | True -> Some Gt
        | False -> Some Lt)
     | B754_nan (b0, n0) -> None
     | B754_finite (b0, m0, e) ->
       (match b0 with
        | True -> Some Gt
        | False -> Some Lt))
  | B754_infinity b ->
    (match b with
     | True ->
       (match f2 with
        | B754_infinity b0 ->
          (match b0 with
           | True -> Some Eq
           | False -> Some Lt)
        | B754_nan (b0, n0) -> None
        | _ -> Some Lt)
     | False ->
       (match f2 with
        | B754_infinity b0 ->
          (match b0 with
           | True -> Some Gt
           | False -> Some Eq)
        | B754_nan (b0, n0) -> None
        | _ -> Some Gt))
  | B754_nan (b, n0) -> None
  | B754_finite (s1, m1, e1) ->
    (match s1 with
     | True ->
       (match f2 with
        | B754_zero b -> Some Lt
        | B754_infinity b ->
          (match b with
           | True -> Some Gt
           | False -> Some Lt)
        | B754_nan (b, n0) -> None
        | B754_finite (s2, m2, e2) ->
          (match s1 with
           | True ->
             (match s2 with
              | True ->
                (match Z.compare e1 e2 with
                 | Eq -> Some (compOpp (Coq_Pos.compare_cont m1 m2 Eq))
                 | Lt -> Some Gt
                 | Gt -> Some Lt)
              | False -> Some Lt)
           | False ->
             (match s2 with
              | True -> Some Gt
              | False ->
                (match Z.compare e1 e2 with
                 | Eq -> Some (Coq_Pos.compare_cont m1 m2 Eq)
                 | x -> Some x))))
     | False ->
       (match f2 with
        | B754_zero b -> Some Gt
        | B754_infinity b ->
          (match b with
           | True -> Some Gt
           | False -> Some Lt)
        | B754_nan (b, n0) -> None
        | B754_finite (s2, m2, e2) ->
          (match s1 with
           | True ->
             (match s2 with
              | True ->
                (match Z.compare e1 e2 with
                 | Eq -> Some (compOpp (Coq_Pos.compare_cont m1 m2 Eq))
                 | Lt -> Some Gt
                 | Gt -> Some Lt)
              | False -> Some Lt)
           | False ->
             (match s2 with
              | True -> Some Gt
              | False ->
                (match Z.compare e1 e2 with
                 | Eq -> Some (Coq_Pos.compare_cont m1 m2 Eq)
                 | x -> Some x)))))

type shr_record = { shr_m : z; shr_r : bool; shr_s : bool }

(** val shr_m : shr_record -> z **)

let shr_m x = x.shr_m

(** val shr_1 : shr_record -> shr_record **)

let shr_1 mrs =
  let { shr_m = m0; shr_r = r; shr_s = s } = mrs in
  let s0 =
    match r with
    | True -> True
    | False -> s
  in
  (match m0 with
   | Z0 -> { shr_m = Z0; shr_r = False; shr_s = s0 }
   | Zpos p0 ->
     (match p0 with
      | XI p -> { shr_m = (Zpos p); shr_r = True; shr_s = s0 }
      | XO p -> { shr_m = (Zpos p); shr_r = False; shr_s = s0 }
      | XH -> { shr_m = Z0; shr_r = True; shr_s = s0 })
   | Zneg p0 ->
     (match p0 with
      | XI p -> { shr_m = (Zneg p); shr_r = True; shr_s = s0 }
      | XO p -> { shr_m = (Zneg p); shr_r = False; shr_s = s0 }
      | XH -> { shr_m = Z0; shr_r = True; shr_s = s0 }))

(** val loc_of_shr_record : shr_record -> location **)

let loc_of_shr_record mrs =
  let { shr_m = shr_m0; shr_r = shr_r0; shr_s = shr_s0 } = mrs in
  (match shr_r0 with
   | True ->
     (match shr_s0 with
      | True -> Loc_Inexact Gt
      | False -> Loc_Inexact Eq)
   | False ->
     (match shr_s0 with
      | True -> Loc_Inexact Lt
      | False -> Loc_Exact))

(** val shr_record_of_loc : z -> location -> shr_record **)

let shr_record_of_loc m0 = function
| Loc_Exact -> { shr_m = m0; shr_r = False; shr_s = False }
| Loc_Inexact c ->
  (match c with
   | Eq -> { shr_m = m0; shr_r = True; shr_s = False }
   | Lt -> { shr_m = m0; shr_r = False; shr_s = True }
   | Gt -> { shr_m = m0; shr_r = True; shr_s = True })

(** val shr0 : shr_record -> z -> z -> (shr_record, z) prod **)

let shr0 mrs e n0 = match n0 with
| Zpos p -> Pair ((iter_pos shr_1 p mrs), (Z.add e n0))
| _ -> Pair (mrs, e)

(** val shr_fexp : z -> z -> z -> z -> location -> (shr_record, z) prod **)

let shr_fexp prec emax =
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  let fexp = fLT_exp emin prec in
  (fun m0 e l ->
  shr0 (shr_record_of_loc m0 l) e (Z.sub (fexp (Z.add (zdigits2 m0) e)) e))

type mode =
| Mode_NE
| Mode_ZR
| Mode_DN
| Mode_UP
| Mode_NA

(** val choice_mode : mode -> bool -> z -> location -> z **)

let choice_mode m0 sx mx lx =
  match m0 with
  | Mode_NE -> cond_incr (round_N (negb (zeven mx)) lx) mx
  | Mode_ZR -> mx
  | Mode_DN -> cond_incr (round_sign_DN sx lx) mx
  | Mode_UP -> cond_incr (round_sign_UP sx lx) mx
  | Mode_NA -> cond_incr (round_N True lx) mx

(** val overflow_to_inf : mode -> bool -> bool **)

let overflow_to_inf m0 s =
  match m0 with
  | Mode_ZR -> False
  | Mode_DN -> s
  | Mode_UP -> negb s
  | _ -> True

(** val binary_overflow : z -> z -> mode -> bool -> full_float **)

let binary_overflow prec emax m0 s =
  match overflow_to_inf m0 s with
  | True -> F754_infinity s
  | False ->
    F754_finite (s,
      (match Z.sub (Z.pow (Zpos (XO XH)) prec) (Zpos XH) with
       | Zpos p -> p
       | _ -> XH), (Z.sub emax prec))

(** val binary_round_aux :
    z -> z -> mode -> bool -> positive -> z -> location -> full_float **)

let binary_round_aux prec emax mode1 sx mx ex lx =
  let Pair (mrs', e') = shr_fexp prec emax (Zpos mx) ex lx in
  let Pair (mrs'', e'') =
    shr_fexp prec emax
      (choice_mode mode1 sx mrs'.shr_m (loc_of_shr_record mrs')) e' Loc_Exact
  in
  (match mrs''.shr_m with
   | Z0 -> F754_zero sx
   | Zpos m0 ->
     (match Z.leb e'' (Z.sub emax prec) with
      | True -> F754_finite (sx, m0, e'')
      | False -> binary_overflow prec emax mode1 sx)
   | Zneg p -> F754_nan (False, XH))

(** val bmult :
    z -> z -> (binary_float -> binary_float -> (bool, nan_pl) prod) -> mode
    -> binary_float -> binary_float -> binary_float **)

let bmult prec emax mult_nan m0 x y =
  match x with
  | B754_zero sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero sy -> B754_zero (xorb sx sy)
     | B754_finite (sy, m1, e) -> B754_zero (xorb sx sy)
     | _ -> f (mult_nan x y))
  | B754_infinity sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_infinity sy -> B754_infinity (xorb sx sy)
     | B754_finite (sy, m1, e) -> B754_infinity (xorb sx sy)
     | _ -> f (mult_nan x y))
  | B754_nan (b, n0) ->
    let pl = mult_nan x y in B754_nan ((fst pl), (snd pl))
  | B754_finite (sx, mx, ex) ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero sy -> B754_zero (xorb sx sy)
     | B754_infinity sy -> B754_infinity (xorb sx sy)
     | B754_nan (b, n0) -> f (mult_nan x y)
     | B754_finite (sy, my, ey) ->
       fF2B prec emax
         (binary_round_aux prec emax m0 (xorb sx sy) (Coq_Pos.mul mx my)
           (Z.add ex ey) Loc_Exact))

(** val shl_align : positive -> z -> z -> (positive, z) prod **)

let shl_align mx ex ex' =
  match Z.sub ex' ex with
  | Zneg d -> Pair ((shift_pos d mx), ex')
  | _ -> Pair (mx, ex)

(** val shl_align_fexp : z -> z -> positive -> z -> (positive, z) prod **)

let shl_align_fexp prec emax =
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  let fexp = fLT_exp emin prec in
  (fun mx ex -> shl_align mx ex (fexp (Z.add (Zpos (digits2_pos mx)) ex)))

(** val binary_round :
    z -> z -> mode -> bool -> positive -> z -> full_float **)

let binary_round prec emax m0 sx mx ex =
  let Pair (mz, ez) = shl_align_fexp prec emax mx ex in
  binary_round_aux prec emax m0 sx mz ez Loc_Exact

(** val binary_normalize :
    z -> z -> mode -> z -> z -> bool -> binary_float **)

let binary_normalize prec emax mode1 m0 e szero =
  match m0 with
  | Z0 -> B754_zero szero
  | Zpos m1 -> fF2B prec emax (binary_round prec emax mode1 False m1 e)
  | Zneg m1 -> fF2B prec emax (binary_round prec emax mode1 True m1 e)

(** val bplus :
    z -> z -> (binary_float -> binary_float -> (bool, nan_pl) prod) -> mode
    -> binary_float -> binary_float -> binary_float **)

let bplus prec emax plus_nan m0 x y =
  match x with
  | B754_zero sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero sy ->
       (match eqb sx sy with
        | True -> x
        | False ->
          (match m0 with
           | Mode_DN -> B754_zero True
           | _ -> B754_zero False))
     | B754_nan (b, n0) -> f (plus_nan x y)
     | _ -> y)
  | B754_infinity sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_infinity sy ->
       (match eqb sx sy with
        | True -> x
        | False -> f (plus_nan x y))
     | B754_nan (b, n0) -> f (plus_nan x y)
     | _ -> x)
  | B754_nan (b, n0) ->
    let pl = plus_nan x y in B754_nan ((fst pl), (snd pl))
  | B754_finite (sx, mx, ex) ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero b -> x
     | B754_infinity b -> y
     | B754_nan (b, n0) -> f (plus_nan x y)
     | B754_finite (sy, my, ey) ->
       let ez = Z.min ex ey in
       binary_normalize prec emax m0
         (Z.add (cond_Zopp sx (Zpos (fst (shl_align mx ex ez))))
           (cond_Zopp sy (Zpos (fst (shl_align my ey ez))))) ez
         (match m0 with
          | Mode_DN -> True
          | _ -> False))

(** val bminus :
    z -> z -> (binary_float -> binary_float -> (bool, nan_pl) prod) -> mode
    -> binary_float -> binary_float -> binary_float **)

let bminus prec emax minus_nan m0 x y =
  bplus prec emax minus_nan m0 x
    (bopp prec emax (fun x0 x1 -> Pair (x0, x1)) y)

(** val fdiv_core_binary :
    z -> z -> z -> z -> z -> ((z, z) prod, location) prod **)

let fdiv_core_binary prec m1 e1 m2 e2 =
  let d1 = zdigits2 m1 in
  let d2 = zdigits2 m2 in
  let e = Z.sub e1 e2 in
  (match Z.sub (Z.add d2 prec) d1 with
   | Zpos p ->
     let m0 = Z.shiftl m1 (Zpos p) in
     let e' = Z.add e (Zneg p) in
     let Pair (q, r) = zfast_div_eucl m0 m2 in
     Pair ((Pair (q, e')), (new_location m2 r Loc_Exact))
   | _ ->
     let Pair (q, r) = zfast_div_eucl m1 m2 in
     Pair ((Pair (q, e)), (new_location m2 r Loc_Exact)))

(** val bdiv :
    z -> z -> (binary_float -> binary_float -> (bool, nan_pl) prod) -> mode
    -> binary_float -> binary_float -> binary_float **)

let bdiv prec emax div_nan m0 x y =
  match x with
  | B754_zero sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_infinity sy -> B754_zero (xorb sx sy)
     | B754_finite (sy, m1, e) -> B754_zero (xorb sx sy)
     | _ -> f (div_nan x y))
  | B754_infinity sx ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero sy -> B754_infinity (xorb sx sy)
     | B754_finite (sy, m1, e) -> B754_infinity (xorb sx sy)
     | _ -> f (div_nan x y))
  | B754_nan (b, n0) -> let pl = div_nan x y in B754_nan ((fst pl), (snd pl))
  | B754_finite (sx, mx, ex) ->
    let f = fun pl -> B754_nan ((fst pl), (snd pl)) in
    (match y with
     | B754_zero sy -> B754_infinity (xorb sx sy)
     | B754_infinity sy -> B754_zero (xorb sx sy)
     | B754_nan (b, n0) -> f (div_nan x y)
     | B754_finite (sy, my, ey) ->
       fF2B prec emax
         (let Pair (p, lz) = fdiv_core_binary prec (Zpos mx) ex (Zpos my) ey
          in
          let Pair (mz, ez) = p in
          (match mz with
           | Zpos mz0 -> binary_round_aux prec emax m0 (xorb sx sy) mz0 ez lz
           | _ -> F754_nan (False, XH))))

(** val join_bits : z -> z -> bool -> z -> z -> z **)

let join_bits mw ew s m0 e =
  Z.add
    (Z.shiftl
      (Z.add
        (match s with
         | True -> Z.pow (Zpos (XO XH)) ew
         | False -> Z0) e) mw) m0

(** val split_bits : z -> z -> z -> ((bool, z) prod, z) prod **)

let split_bits mw ew x =
  let mm = Z.pow (Zpos (XO XH)) mw in
  let em = Z.pow (Zpos (XO XH)) ew in
  Pair ((Pair ((Z.leb (Z.mul mm em) x), (Z.modulo x mm))),
  (Z.modulo (Z.div x mm) em))

(** val bits_of_binary_float : z -> z -> binary_float -> z **)

let bits_of_binary_float mw ew =
  let emax = Z.pow (Zpos (XO XH)) (Z.sub ew (Zpos XH)) in
  let prec = Z.add mw (Zpos XH) in
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  (fun x ->
  match x with
  | B754_zero sx -> join_bits mw ew sx Z0 Z0
  | B754_infinity sx ->
    join_bits mw ew sx Z0 (Z.sub (Z.pow (Zpos (XO XH)) ew) (Zpos XH))
  | B754_nan (sx, n0) ->
    join_bits mw ew sx (Zpos n0) (Z.sub (Z.pow (Zpos (XO XH)) ew) (Zpos XH))
  | B754_finite (sx, mx, ex) ->
    let m0 = Z.sub (Zpos mx) (Z.pow (Zpos (XO XH)) mw) in
    (match Z.leb Z0 m0 with
     | True -> join_bits mw ew sx m0 (Z.add (Z.sub ex emin) (Zpos XH))
     | False -> join_bits mw ew sx (Zpos mx) Z0))

(** val binary_float_of_bits_aux : z -> z -> z -> full_float **)

let binary_float_of_bits_aux mw ew =
  let emax = Z.pow (Zpos (XO XH)) (Z.sub ew (Zpos XH)) in
  let prec = Z.add mw (Zpos XH) in
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  (fun x ->
  let Pair (p, ex) = split_bits mw ew x in
  let Pair (sx, mx) = p in
  (match zeq_bool ex Z0 with
   | True ->
     (match mx with
      | Z0 -> F754_zero sx
      | Zpos px -> F754_finite (sx, px, emin)
      | Zneg p0 -> F754_nan (False, XH))
   | False ->
     (match zeq_bool ex (Z.sub (Z.pow (Zpos (XO XH)) ew) (Zpos XH)) with
      | True ->
        (match mx with
         | Z0 -> F754_infinity sx
         | Zpos plx -> F754_nan (sx, plx)
         | Zneg p0 -> F754_nan (False, XH))
      | False ->
        (match Z.add mx (Z.pow (Zpos (XO XH)) mw) with
         | Zpos px -> F754_finite (sx, px, (Z.sub (Z.add ex emin) (Zpos XH)))
         | _ -> F754_nan (False, XH)))))

(** val binary_float_of_bits : z -> z -> z -> binary_float **)

let binary_float_of_bits mw ew x =
  let emax = Z.pow (Zpos (XO XH)) (Z.sub ew (Zpos XH)) in
  let prec = Z.add mw (Zpos XH) in
  fF2B prec emax (binary_float_of_bits_aux mw ew x)

type binary32 = binary_float

(** val b32_of_bits : z -> binary32 **)

let b32_of_bits =
  binary_float_of_bits (Zpos (XI (XI (XI (XO XH))))) (Zpos (XO (XO (XO XH))))

(** val bits_of_b32 : binary32 -> z **)

let bits_of_b32 =
  bits_of_binary_float (Zpos (XI (XI (XI (XO XH))))) (Zpos (XO (XO (XO XH))))

type binary64 = binary_float

(** val b64_of_bits : z -> binary64 **)

let b64_of_bits =
  binary_float_of_bits (Zpos (XO (XO (XI (XO (XI XH)))))) (Zpos (XI (XI (XO
    XH))))

(** val bits_of_b64 : binary64 -> z **)

let bits_of_b64 =
  bits_of_binary_float (Zpos (XO (XO (XI (XO (XI XH)))))) (Zpos (XI (XI (XO
    XH))))

(** val beq_dec : z -> z -> binary_float -> binary_float -> sumbool **)

let beq_dec prec emax f1 f2 =
  match f1 with
  | B754_zero b ->
    (match f2 with
     | B754_zero b0 ->
       (match b with
        | True ->
          (match b0 with
           | True -> Left
           | False -> Right)
        | False ->
          (match b0 with
           | True -> Right
           | False -> Left))
     | _ -> Right)
  | B754_infinity b ->
    (match f2 with
     | B754_infinity b0 ->
       (match b with
        | True ->
          (match b0 with
           | True -> Left
           | False -> Right)
        | False ->
          (match b0 with
           | True -> Right
           | False -> Left))
     | _ -> Right)
  | B754_nan (b, n0) ->
    (match f2 with
     | B754_nan (b0, n1) ->
       (match b with
        | True ->
          (match b0 with
           | True -> Coq_Pos.eq_dec n0 n1
           | False -> Right)
        | False ->
          (match b0 with
           | True -> Right
           | False -> Coq_Pos.eq_dec n0 n1))
     | _ -> Right)
  | B754_finite (b, m0, e) ->
    (match f2 with
     | B754_finite (b0, m1, e1) ->
       (match b with
        | True ->
          (match b0 with
           | True ->
             let s = Coq_Pos.eq_dec m0 m1 in
             (match s with
              | Left -> Z.eq_dec e e1
              | Right -> Right)
           | False -> Right)
        | False ->
          (match b0 with
           | True -> Right
           | False ->
             let s = Coq_Pos.eq_dec m0 m1 in
             (match s with
              | Left -> Z.eq_dec e e1
              | Right -> Right)))
     | _ -> Right)

(** val bofZ : z -> z -> z -> binary_float **)

let bofZ prec emax n0 =
  binary_normalize prec emax Mode_NE n0 Z0 False

(** val zofB : z -> z -> binary_float -> z option **)

let zofB prec emax = function
| B754_zero b -> Some Z0
| B754_finite (s, m0, e0) ->
  (match e0 with
   | Z0 -> Some (cond_Zopp s (Zpos m0))
   | Zpos e ->
     Some (Z.mul (cond_Zopp s (Zpos m0)) (Z.pow_pos (radix_val radix2) e))
   | Zneg e ->
     Some (cond_Zopp s (Z.div (Zpos m0) (Z.pow_pos (radix_val radix2) e))))
| _ -> None

(** val zofB_range : z -> z -> binary_float -> z -> z -> z option **)

let zofB_range prec emax f zmin zmax =
  match zofB prec emax f with
  | Some z0 ->
    (match match Z.leb zmin z0 with
           | True -> Z.leb z0 zmax
           | False -> False with
     | True -> Some z0
     | False -> None)
  | None -> None

(** val bexact_inverse_mantissa : z -> positive **)

let bexact_inverse_mantissa prec =
  Z.iter (Z.sub prec (Zpos XH)) (fun x -> XO x) XH

(** val bexact_inverse : z -> z -> binary_float -> binary_float option **)

let bexact_inverse prec emax f =
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  (match f with
   | B754_finite (s, m0, e) ->
     (match Coq_Pos.eq_dec m0 (bexact_inverse_mantissa prec) with
      | Left ->
        let e' =
          Z.sub (Z.opp e) (Z.mul (Z.sub prec (Zpos XH)) (Zpos (XO XH)))
        in
        (match z_le_dec emin e' with
         | Left ->
           (match z_le_dec e' emax with
            | Left -> Some (B754_finite (s, m0, e'))
            | Right -> None)
         | Right -> None)
      | Right -> None)
   | x -> None)

(** val pos_pow : positive -> positive -> positive **)

let rec pos_pow x = function
| XI y0 -> Coq_Pos.mul x (Coq_Pos.square (pos_pow x y0))
| XO y0 -> Coq_Pos.square (pos_pow x y0)
| XH -> x

(** val bparse : z -> z -> positive -> positive -> z -> binary_float **)

let bparse prec emax base m0 e =
  let emin = Z.sub (Z.sub (Zpos (XI XH)) emax) prec in
  (match e with
   | Z0 -> bofZ prec emax (Zpos m0)
   | Zpos p ->
     (match Z.ltb (Z.mul e (Z.log2 (Zpos base))) emax with
      | True -> bofZ prec emax (Z.mul (Zpos m0) (Zpos (pos_pow base p)))
      | False -> B754_infinity False)
   | Zneg p ->
     (match Z.ltb
              (Z.add (Z.mul e (Z.log2 (Zpos base))) (Z.log2_up (Zpos m0)))
              emin with
      | True -> B754_zero False
      | False ->
        fF2B prec emax
          (let Pair (p0, lz) =
             fdiv_core_binary prec (Zpos m0) Z0 (Zpos (pos_pow base p)) Z0
           in
           let Pair (mz, ez) = p0 in
           (match mz with
            | Zpos mz0 ->
              binary_round_aux prec emax Mode_NE (xorb False False) mz0 ez lz
            | _ -> F754_nan (False, XH)))))

(** val bconv :
    z -> z -> z -> z -> (bool -> nan_pl -> (bool, nan_pl) prod) -> mode ->
    binary_float -> binary_float **)

let bconv prec1 emax1 prec2 emax2 conv_nan md = function
| B754_nan (s, pl) ->
  let Pair (s0, pl0) = conv_nan s pl in B754_nan (s0, pl0)
| B754_finite (s, m0, e) ->
  binary_normalize prec2 emax2 md (cond_Zopp s (Zpos m0)) e s
| x -> x

(** val big_endian : bool **)

let big_endian =
  False

(** val default_pl_64 : (bool, nan_pl) prod **)

let default_pl_64 =
  Pair (True,
    (nat_iter (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))
      (fun x -> XO x) XH))

(** val choose_binop_pl_64 : bool -> nan_pl -> bool -> nan_pl -> bool **)

let choose_binop_pl_64 s1 pl1 s2 pl2 =
  False

(** val default_pl_32 : (bool, nan_pl) prod **)

let default_pl_32 =
  Pair (True,
    (nat_iter (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S O)))))))))))))))))))))) (fun x -> XO x) XH))

(** val choose_binop_pl_32 : bool -> nan_pl -> bool -> nan_pl -> bool **)

let choose_binop_pl_32 s1 pl1 s2 pl2 =
  False

(** val float_of_single_preserves_sNaN : bool **)

let float_of_single_preserves_sNaN =
  False

type float = binary64

type float32 = binary32

(** val cmp_of_comparison : comparison0 -> comparison option -> bool **)

let cmp_of_comparison c x =
  match c with
  | Ceq ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Eq -> True
        | _ -> False)
     | None -> False)
  | Cne ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Eq -> False
        | _ -> True)
     | None -> True)
  | Clt ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Lt -> True
        | _ -> False)
     | None -> False)
  | Cle ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Gt -> False
        | _ -> True)
     | None -> False)
  | Cgt ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Gt -> True
        | _ -> False)
     | None -> False)
  | Cge ->
    (match x with
     | Some c0 ->
       (match c0 with
        | Lt -> False
        | _ -> True)
     | None -> False)

module Float = 
 struct 
  (** val transform_quiet_pl : nan_pl -> nan_pl **)
  
  let transform_quiet_pl pl =
    Coq_Pos.coq_lor pl
      (nat_iter (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
        (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
        (S (S (S (S (S (S (S (S
        O))))))))))))))))))))))))))))))))))))))))))))))))))) (fun x -> XO x)
        XH)
  
  (** val expand_pl : nan_pl -> nan_pl **)
  
  let expand_pl pl =
    Coq_Pos.shiftl_nat pl (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S (S (S (S (S (S O)))))))))))))))))))))))))))))
  
  (** val of_single_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let of_single_pl s pl =
    Pair (s,
      (match float_of_single_preserves_sNaN with
       | True -> expand_pl pl
       | False -> transform_quiet_pl (expand_pl pl)))
  
  (** val reduce_pl : nan_pl -> nan_pl **)
  
  let reduce_pl pl =
    Coq_Pos.shiftr_nat pl (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
      (S (S (S (S (S (S (S (S (S (S (S (S O)))))))))))))))))))))))))))))
  
  (** val to_single_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let to_single_pl s pl =
    Pair (s, (reduce_pl (transform_quiet_pl pl)))
  
  (** val neg_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let neg_pl s pl =
    Pair ((negb s), pl)
  
  (** val abs_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let abs_pl s pl =
    Pair (False, pl)
  
  (** val binop_pl : binary64 -> binary64 -> (bool, nan_pl) prod **)
  
  let binop_pl x y =
    match x with
    | B754_nan (s1, pl1) ->
      (match y with
       | B754_nan (s2, pl2) ->
         (match choose_binop_pl_64 s1 pl1 s2 pl2 with
          | True -> Pair (s2, (transform_quiet_pl pl2))
          | False -> Pair (s1, (transform_quiet_pl pl1)))
       | _ -> Pair (s1, (transform_quiet_pl pl1)))
    | _ ->
      (match y with
       | B754_nan (s2, pl2) -> Pair (s2, (transform_quiet_pl pl2))
       | _ -> default_pl_64)
  
  (** val zero : float **)
  
  let zero =
    B754_zero False
  
  (** val eq_dec : float -> float -> sumbool **)
  
  let eq_dec =
    beq_dec (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH)))))))))))
  
  (** val neg : float -> float **)
  
  let neg =
    bopp (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) neg_pl
  
  (** val abs : float -> float **)
  
  let abs =
    babs (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) abs_pl
  
  (** val add : float -> float -> float **)
  
  let add =
    bplus (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH))))))))))) binop_pl Mode_NE
  
  (** val sub : float -> float -> float **)
  
  let sub =
    bminus (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH))))))))))) binop_pl Mode_NE
  
  (** val mul : float -> float -> float **)
  
  let mul =
    bmult (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH))))))))))) binop_pl Mode_NE
  
  (** val div : float -> float -> float **)
  
  let div =
    bdiv (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) binop_pl Mode_NE
  
  (** val cmp : comparison0 -> float -> float -> bool **)
  
  let cmp c f1 f2 =
    cmp_of_comparison c
      (bcompare (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO
        (XO (XO (XO (XO (XO XH))))))))))) f1 f2)
  
  (** val of_single : float32 -> float **)
  
  let of_single =
    bconv (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO
      (XO (XO (XO (XO (XO XH))))))))))) of_single_pl Mode_NE
  
  (** val to_single : float -> float32 **)
  
  let to_single =
    bconv (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH))))))))))) (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO
      (XO (XO (XO (XO (XO (XO XH)))))))) to_single_pl Mode_NE
  
  (** val to_int : float -> Int.int option **)
  
  let to_int f =
    option_map Int.repr
      (zofB_range (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO
        (XO (XO (XO (XO (XO (XO XH))))))))))) f Int.min_signed
        Int.max_signed)
  
  (** val to_intu : float -> Int.int option **)
  
  let to_intu f =
    option_map Int.repr
      (zofB_range (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO
        (XO (XO (XO (XO (XO (XO XH))))))))))) f Z0 Int.max_unsigned)
  
  (** val to_long : float -> Int64.int option **)
  
  let to_long f =
    option_map Int64.repr
      (zofB_range (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO
        (XO (XO (XO (XO (XO (XO XH))))))))))) f Int64.min_signed
        Int64.max_signed)
  
  (** val to_longu : float -> Int64.int option **)
  
  let to_longu f =
    option_map Int64.repr
      (zofB_range (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO
        (XO (XO (XO (XO (XO (XO XH))))))))))) f Z0 Int64.max_unsigned)
  
  (** val of_int : Int.int -> float **)
  
  let of_int n0 =
    bofZ (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) (Int.signed n0)
  
  (** val of_intu : Int.int -> float **)
  
  let of_intu n0 =
    bofZ (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) (Int.unsigned n0)
  
  (** val of_long : Int64.int -> float **)
  
  let of_long n0 =
    bofZ (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) (Int64.signed n0)
  
  (** val of_longu : Int64.int -> float **)
  
  let of_longu n0 =
    bofZ (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO XH))))))))))) (Int64.unsigned n0)
  
  (** val from_parsed : positive -> positive -> z -> float **)
  
  let from_parsed base intPart expPart =
    bparse (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO XH))))))))))) base intPart expPart
  
  (** val to_bits : float -> Int64.int **)
  
  let to_bits f =
    Int64.repr (bits_of_b64 f)
  
  (** val of_bits : Int64.int -> float **)
  
  let of_bits b =
    b64_of_bits (Int64.unsigned b)
  
  (** val from_words : Int.int -> Int.int -> float **)
  
  let from_words hi lo =
    of_bits (Int64.ofwords hi lo)
  
  (** val exact_inverse : float -> float option **)
  
  let exact_inverse =
    bexact_inverse (Zpos (XI (XO (XI (XO (XI XH)))))) (Zpos (XO (XO (XO (XO
      (XO (XO (XO (XO (XO (XO XH)))))))))))
  
  (** val ox8000_0000 : Int.int **)
  
  let ox8000_0000 =
    Int.repr Int.half_modulus
  
  (** val ox4330_0000 : Int.int **)
  
  let ox4330_0000 =
    Int.repr (Zpos (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO (XO (XO (XI (XI (XO (XO (XI (XI (XO (XO (XO (XO
      XH)))))))))))))))))))))))))))))))
  
  (** val ox4530_0000 : Int.int **)
  
  let ox4530_0000 =
    Int.repr (Zpos (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO
      (XO (XO (XO (XO (XO (XO (XI (XI (XO (XO (XI (XO (XI (XO (XO (XO
      XH)))))))))))))))))))))))))))))))
 end

module Float32 = 
 struct 
  (** val transform_quiet_pl : nan_pl -> nan_pl **)
  
  let transform_quiet_pl pl =
    Coq_Pos.coq_lor pl
      (nat_iter (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S
        (S (S O)))))))))))))))))))))) (fun x -> XO x) XH)
  
  (** val neg_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let neg_pl s pl =
    Pair ((negb s), pl)
  
  (** val abs_pl : bool -> nan_pl -> (bool, nan_pl) prod **)
  
  let abs_pl s pl =
    Pair (False, pl)
  
  (** val binop_pl : binary32 -> binary32 -> (bool, nan_pl) prod **)
  
  let binop_pl x y =
    match x with
    | B754_nan (s1, pl1) ->
      (match y with
       | B754_nan (s2, pl2) ->
         (match choose_binop_pl_32 s1 pl1 s2 pl2 with
          | True -> Pair (s2, (transform_quiet_pl pl2))
          | False -> Pair (s1, (transform_quiet_pl pl1)))
       | _ -> Pair (s1, (transform_quiet_pl pl1)))
    | _ ->
      (match y with
       | B754_nan (s2, pl2) -> Pair (s2, (transform_quiet_pl pl2))
       | _ -> default_pl_32)
  
  (** val zero : float32 **)
  
  let zero =
    B754_zero False
  
  (** val eq_dec : float32 -> float32 -> sumbool **)
  
  let eq_dec =
    beq_dec (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH))))))))
  
  (** val neg : float32 -> float32 **)
  
  let neg =
    bopp (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) neg_pl
  
  (** val abs : float32 -> float32 **)
  
  let abs =
    babs (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) abs_pl
  
  (** val add : float32 -> float32 -> float32 **)
  
  let add =
    bplus (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) binop_pl Mode_NE
  
  (** val sub : float32 -> float32 -> float32 **)
  
  let sub =
    bminus (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) binop_pl Mode_NE
  
  (** val mul : float32 -> float32 -> float32 **)
  
  let mul =
    bmult (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) binop_pl Mode_NE
  
  (** val div : float32 -> float32 -> float32 **)
  
  let div =
    bdiv (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) binop_pl Mode_NE
  
  (** val cmp : comparison0 -> float32 -> float32 -> bool **)
  
  let cmp c f1 f2 =
    cmp_of_comparison c
      (bcompare (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO
        (XO XH)))))))) f1 f2)
  
  (** val of_double : float -> float32 **)
  
  let of_double =
    Float.to_single
  
  (** val to_double : float32 -> float **)
  
  let to_double =
    Float.of_single
  
  (** val to_int : float32 -> Int.int option **)
  
  let to_int f =
    option_map Int.repr
      (zofB_range (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO
        (XO XH)))))))) f Int.min_signed Int.max_signed)
  
  (** val to_intu : float32 -> Int.int option **)
  
  let to_intu f =
    option_map Int.repr
      (zofB_range (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO
        (XO XH)))))))) f Z0 Int.max_unsigned)
  
  (** val to_long : float32 -> Int64.int option **)
  
  let to_long f =
    option_map Int64.repr
      (zofB_range (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO
        (XO XH)))))))) f Int64.min_signed Int64.max_signed)
  
  (** val to_longu : float32 -> Int64.int option **)
  
  let to_longu f =
    option_map Int64.repr
      (zofB_range (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO
        (XO XH)))))))) f Z0 Int64.max_unsigned)
  
  (** val of_int : Int.int -> float32 **)
  
  let of_int n0 =
    bofZ (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) (Int.signed n0)
  
  (** val of_intu : Int.int -> float32 **)
  
  let of_intu n0 =
    bofZ (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) (Int.unsigned n0)
  
  (** val of_long : Int64.int -> float32 **)
  
  let of_long n0 =
    bofZ (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) (Int64.signed n0)
  
  (** val of_longu : Int64.int -> float32 **)
  
  let of_longu n0 =
    bofZ (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) (Int64.unsigned n0)
  
  (** val from_parsed : positive -> positive -> z -> float32 **)
  
  let from_parsed base intPart expPart =
    bparse (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO (XO (XO
      XH)))))))) base intPart expPart
  
  (** val to_bits : float32 -> Int.int **)
  
  let to_bits f =
    Int.repr (bits_of_b32 f)
  
  (** val of_bits : Int.int -> float32 **)
  
  let of_bits b =
    b32_of_bits (Int.unsigned b)
  
  (** val exact_inverse : float32 -> float32 option **)
  
  let exact_inverse =
    bexact_inverse (Zpos (XO (XO (XO (XI XH))))) (Zpos (XO (XO (XO (XO (XO
      (XO (XO XH))))))))
 end

type ident = positive

(** val ident_eq : positive -> positive -> sumbool **)

let ident_eq =
  peq

type typ =
| Tint
| Tfloat
| Tlong
| Tsingle
| Tany32
| Tany64

(** val typ_eq : typ -> typ -> sumbool **)

let typ_eq t1 t2 =
  match t1 with
  | Tint ->
    (match t2 with
     | Tint -> Left
     | _ -> Right)
  | Tfloat ->
    (match t2 with
     | Tfloat -> Left
     | _ -> Right)
  | Tlong ->
    (match t2 with
     | Tlong -> Left
     | _ -> Right)
  | Tsingle ->
    (match t2 with
     | Tsingle -> Left
     | _ -> Right)
  | Tany32 ->
    (match t2 with
     | Tany32 -> Left
     | _ -> Right)
  | Tany64 ->
    (match t2 with
     | Tany64 -> Left
     | _ -> Right)

(** val opt_typ_eq : typ option -> typ option -> sumbool **)

let opt_typ_eq =
  option_eq typ_eq

(** val list_typ_eq : typ list -> typ list -> sumbool **)

let list_typ_eq =
  list_eq_dec typ_eq

(** val subtype : typ -> typ -> bool **)

let subtype ty1 ty2 =
  match ty1 with
  | Tint ->
    (match ty2 with
     | Tfloat -> False
     | Tlong -> False
     | Tsingle -> False
     | _ -> True)
  | Tfloat ->
    (match ty2 with
     | Tfloat -> True
     | Tany64 -> True
     | _ -> False)
  | Tlong ->
    (match ty2 with
     | Tlong -> True
     | Tany64 -> True
     | _ -> False)
  | Tsingle ->
    (match ty2 with
     | Tint -> False
     | Tfloat -> False
     | Tlong -> False
     | _ -> True)
  | Tany32 ->
    (match ty2 with
     | Tany32 -> True
     | Tany64 -> True
     | _ -> False)
  | Tany64 ->
    (match ty2 with
     | Tany64 -> True
     | _ -> False)

type calling_convention = { cc_vararg : bool; cc_unproto : bool;
                            cc_structret : bool }

(** val cc_default : calling_convention **)

let cc_default =
  { cc_vararg = False; cc_unproto = False; cc_structret = False }

type signature = { sig_args : typ list; sig_res : typ option;
                   sig_cc : calling_convention }

(** val sig_args : signature -> typ list **)

let sig_args x = x.sig_args

(** val sig_res : signature -> typ option **)

let sig_res x = x.sig_res

(** val proj_sig_res : signature -> typ **)

let proj_sig_res s =
  match s.sig_res with
  | Some t1 -> t1
  | None -> Tint

(** val signature_eq : signature -> signature -> sumbool **)

let signature_eq s1 s2 =
  let { sig_args = x; sig_res = x0; sig_cc = x1 } = s1 in
  let { sig_args = sig_args1; sig_res = sig_res1; sig_cc = sig_cc1 } = s2 in
  (match list_typ_eq x sig_args1 with
   | Left ->
     (match opt_typ_eq x0 sig_res1 with
      | Left ->
        let { cc_vararg = x2; cc_unproto = x3; cc_structret = x4 } = x1 in
        let { cc_vararg = cc_vararg1; cc_unproto = cc_unproto1;
          cc_structret = cc_structret1 } = sig_cc1
        in
        (match bool_dec x2 cc_vararg1 with
         | Left ->
           (match bool_dec x3 cc_unproto1 with
            | Left -> bool_dec x4 cc_structret1
            | Right -> Right)
         | Right -> Right)
      | Right -> Right)
   | Right -> Right)

type memory_chunk =
| Mint8signed
| Mint8unsigned
| Mint16signed
| Mint16unsigned
| Mint32
| Mint64
| Mfloat32
| Mfloat64
| Many32
| Many64

(** val chunk_eq : memory_chunk -> memory_chunk -> sumbool **)

let chunk_eq c1 c2 =
  match c1 with
  | Mint8signed ->
    (match c2 with
     | Mint8signed -> Left
     | _ -> Right)
  | Mint8unsigned ->
    (match c2 with
     | Mint8unsigned -> Left
     | _ -> Right)
  | Mint16signed ->
    (match c2 with
     | Mint16signed -> Left
     | _ -> Right)
  | Mint16unsigned ->
    (match c2 with
     | Mint16unsigned -> Left
     | _ -> Right)
  | Mint32 ->
    (match c2 with
     | Mint32 -> Left
     | _ -> Right)
  | Mint64 ->
    (match c2 with
     | Mint64 -> Left
     | _ -> Right)
  | Mfloat32 ->
    (match c2 with
     | Mfloat32 -> Left
     | _ -> Right)
  | Mfloat64 ->
    (match c2 with
     | Mfloat64 -> Left
     | _ -> Right)
  | Many32 ->
    (match c2 with
     | Many32 -> Left
     | _ -> Right)
  | Many64 ->
    (match c2 with
     | Many64 -> Left
     | _ -> Right)

(** val type_of_chunk : memory_chunk -> typ **)

let type_of_chunk = function
| Mint64 -> Tlong
| Mfloat32 -> Tsingle
| Mfloat64 -> Tfloat
| Many32 -> Tany32
| Many64 -> Tany64
| _ -> Tint

(** val chunk_of_type : typ -> memory_chunk **)

let chunk_of_type = function
| Tint -> Mint32
| Tfloat -> Mfloat64
| Tlong -> Mint64
| Tsingle -> Mfloat32
| Tany32 -> Many32
| Tany64 -> Many64

type init_data =
| Init_int8 of Int.int
| Init_int16 of Int.int
| Init_int32 of Int.int
| Init_int64 of Int64.int
| Init_float32 of float32
| Init_float64 of float
| Init_space of z
| Init_addrof of ident * Int.int

type 'v globvar = { gvar_info : 'v; gvar_init : init_data list;
                    gvar_readonly : bool; gvar_volatile : bool }

(** val gvar_info : 'a1 globvar -> 'a1 **)

let gvar_info x = x.gvar_info

(** val gvar_init : 'a1 globvar -> init_data list **)

let gvar_init x = x.gvar_init

(** val gvar_readonly : 'a1 globvar -> bool **)

let gvar_readonly x = x.gvar_readonly

(** val gvar_volatile : 'a1 globvar -> bool **)

let gvar_volatile x = x.gvar_volatile

type ('f, 'v) globdef =
| Gfun of 'f
| Gvar of 'v globvar

type ('f, 'v) program = { prog_defs : (ident, ('f, 'v) globdef) prod list;
                          prog_public : ident list; prog_main : ident }

(** val prog_defs :
    ('a1, 'a2) program -> (ident, ('a1, 'a2) globdef) prod list **)

let prog_defs x = x.prog_defs

(** val prog_public : ('a1, 'a2) program -> ident list **)

let prog_public x = x.prog_public

(** val prog_main : ('a1, 'a2) program -> ident **)

let prog_main x = x.prog_main

(** val transform_program_globdef :
    ('a1 -> 'a2) -> (ident, ('a1, 'a3) globdef) prod -> (ident, ('a2, 'a3)
    globdef) prod **)

let transform_program_globdef transf = function
| Pair (id, g) ->
  (match g with
   | Gfun f -> Pair (id, (Gfun (transf f)))
   | Gvar v -> Pair (id, (Gvar v)))

(** val transform_program :
    ('a1 -> 'a2) -> ('a1, 'a3) program -> ('a2, 'a3) program **)

let transform_program transf p =
  { prog_defs = (map (transform_program_globdef transf) p.prog_defs);
    prog_public = p.prog_public; prog_main = p.prog_main }

(** val transf_globvar :
    ('a1 -> 'a2 res) -> 'a1 globvar -> 'a2 globvar res **)

let transf_globvar transf_var g =
  bind (transf_var g.gvar_info) (fun info' -> OK { gvar_info = info';
    gvar_init = g.gvar_init; gvar_readonly = g.gvar_readonly; gvar_volatile =
    g.gvar_volatile })

(** val transf_globdefs :
    ('a1 -> 'a2 res) -> ('a3 -> 'a4 res) -> (ident, ('a1, 'a3) globdef) prod
    list -> (ident, ('a2, 'a4) globdef) prod list res **)

let rec transf_globdefs transf_fun transf_var = function
| Nil -> OK Nil
| Cons (p, l') ->
  let Pair (id, g) = p in
  (match g with
   | Gfun f ->
     (match transf_fun f with
      | OK tf ->
        bind (transf_globdefs transf_fun transf_var l') (fun tl' -> OK (Cons
          ((Pair (id, (Gfun tf))), tl')))
      | Error msg0 ->
        Error (Cons ((MSG (String ((Ascii (True, False, False, True, False,
          False, True, False)), (String ((Ascii (False, True, True, True,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)), (String ((Ascii (False, True,
          True, False, False, True, True, False)), (String ((Ascii (True,
          False, True, False, True, True, True, False)), (String ((Ascii
          (False, True, True, True, False, True, True, False)), (String
          ((Ascii (True, True, False, False, False, True, True, False)),
          (String ((Ascii (False, False, True, False, True, True, True,
          False)), (String ((Ascii (True, False, False, True, False, True,
          True, False)), (String ((Ascii (True, True, True, True, False,
          True, True, False)), (String ((Ascii (False, True, True, True,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)),
          EmptyString))))))))))))))))))))))))), (Cons ((CTX id), (Cons ((MSG
          (String ((Ascii (False, True, False, True, True, True, False,
          False)), (String ((Ascii (False, False, False, False, False, True,
          False, False)), EmptyString))))), msg0)))))))
   | Gvar v ->
     (match transf_globvar transf_var v with
      | OK tv ->
        bind (transf_globdefs transf_fun transf_var l') (fun tl' -> OK (Cons
          ((Pair (id, (Gvar tv))), tl')))
      | Error msg0 ->
        Error (Cons ((MSG (String ((Ascii (True, False, False, True, False,
          False, True, False)), (String ((Ascii (False, True, True, True,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)), (String ((Ascii (False, True,
          True, False, True, True, True, False)), (String ((Ascii (True,
          False, False, False, False, True, True, False)), (String ((Ascii
          (False, True, False, False, True, True, True, False)), (String
          ((Ascii (True, False, False, True, False, True, True, False)),
          (String ((Ascii (True, False, False, False, False, True, True,
          False)), (String ((Ascii (False, True, False, False, False, True,
          True, False)), (String ((Ascii (False, False, True, True, False,
          True, True, False)), (String ((Ascii (True, False, True, False,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)),
          EmptyString))))))))))))))))))))))))), (Cons ((CTX id), (Cons ((MSG
          (String ((Ascii (False, True, False, True, True, True, False,
          False)), (String ((Ascii (False, False, False, False, False, True,
          False, False)), EmptyString))))), msg0))))))))

(** val transform_partial_program2 :
    ('a1 -> 'a2 res) -> ('a3 -> 'a4 res) -> ('a1, 'a3) program -> ('a2, 'a4)
    program res **)

let transform_partial_program2 transf_fun transf_var p =
  bind (transf_globdefs transf_fun transf_var p.prog_defs) (fun gl' -> OK
    { prog_defs = gl'; prog_public = p.prog_public; prog_main =
    p.prog_main })

(** val transform_partial_program :
    ('a1 -> 'a2 res) -> ('a1, 'a3) program -> ('a2, 'a3) program res **)

let transform_partial_program transf_partial p =
  transform_partial_program2 transf_partial (fun v -> OK v) p

type external_function =
| EF_external of string * signature
| EF_builtin of string * signature
| EF_vload of memory_chunk
| EF_vstore of memory_chunk
| EF_malloc
| EF_free
| EF_memcpy of z * z
| EF_annot of string * typ list
| EF_annot_val of string * typ
| EF_inline_asm of string * signature * string list
| EF_debug of positive * ident * typ list

(** val ef_sig : external_function -> signature **)

let ef_sig = function
| EF_external (name, sg) -> sg
| EF_builtin (name, sg) -> sg
| EF_vload chunk ->
  { sig_args = (Cons (Tint, Nil)); sig_res = (Some (type_of_chunk chunk));
    sig_cc = cc_default }
| EF_vstore chunk ->
  { sig_args = (Cons (Tint, (Cons ((type_of_chunk chunk), Nil)))); sig_res =
    None; sig_cc = cc_default }
| EF_malloc ->
  { sig_args = (Cons (Tint, Nil)); sig_res = (Some Tint); sig_cc =
    cc_default }
| EF_free ->
  { sig_args = (Cons (Tint, Nil)); sig_res = None; sig_cc = cc_default }
| EF_memcpy (sz, al) ->
  { sig_args = (Cons (Tint, (Cons (Tint, Nil)))); sig_res = None; sig_cc =
    cc_default }
| EF_annot (text, targs) ->
  { sig_args = targs; sig_res = None; sig_cc = cc_default }
| EF_annot_val (text, targ) ->
  { sig_args = (Cons (targ, Nil)); sig_res = (Some targ); sig_cc =
    cc_default }
| EF_inline_asm (text, sg, clob) -> sg
| EF_debug (kind, text, targs) ->
  { sig_args = targs; sig_res = None; sig_cc = cc_default }

(** val ef_inline : external_function -> bool **)

let ef_inline = function
| EF_external (name, sg) -> False
| EF_malloc -> False
| EF_free -> False
| _ -> True

(** val external_function_eq :
    external_function -> external_function -> sumbool **)

let external_function_eq =
  let x = fun _ -> list_eq_dec in
  (fun ef1 ef2 ->
  match ef1 with
  | EF_external (x0, x1) ->
    (match ef2 with
     | EF_external (name0, sg0) ->
       (match string_dec x0 name0 with
        | Left -> signature_eq x1 sg0
        | Right -> Right)
     | _ -> Right)
  | EF_builtin (x0, x1) ->
    (match ef2 with
     | EF_builtin (name0, sg0) ->
       (match string_dec x0 name0 with
        | Left -> signature_eq x1 sg0
        | Right -> Right)
     | _ -> Right)
  | EF_vload x0 ->
    (match ef2 with
     | EF_vload chunk0 -> chunk_eq x0 chunk0
     | _ -> Right)
  | EF_vstore x0 ->
    (match ef2 with
     | EF_vstore chunk0 -> chunk_eq x0 chunk0
     | _ -> Right)
  | EF_malloc ->
    (match ef2 with
     | EF_malloc -> Left
     | _ -> Right)
  | EF_free ->
    (match ef2 with
     | EF_free -> Left
     | _ -> Right)
  | EF_memcpy (x0, x1) ->
    (match ef2 with
     | EF_memcpy (sz0, al0) ->
       (match zeq x0 sz0 with
        | Left -> zeq x1 al0
        | Right -> Right)
     | _ -> Right)
  | EF_annot (x0, x1) ->
    (match ef2 with
     | EF_annot (text0, targs0) ->
       (match string_dec x0 text0 with
        | Left -> x __ typ_eq x1 targs0
        | Right -> Right)
     | _ -> Right)
  | EF_annot_val (x0, x1) ->
    (match ef2 with
     | EF_annot_val (text0, targ0) ->
       (match string_dec x0 text0 with
        | Left -> typ_eq x1 targ0
        | Right -> Right)
     | _ -> Right)
  | EF_inline_asm (x0, x1, x2) ->
    (match ef2 with
     | EF_inline_asm (text0, sg0, clobbers0) ->
       (match string_dec x0 text0 with
        | Left ->
          (match signature_eq x1 sg0 with
           | Left -> x __ string_dec x2 clobbers0
           | Right -> Right)
        | Right -> Right)
     | _ -> Right)
  | EF_debug (x0, x1, x2) ->
    (match ef2 with
     | EF_debug (kind0, text0, targs0) ->
       (match ident_eq x0 kind0 with
        | Left ->
          (match ident_eq x1 text0 with
           | Left -> x __ typ_eq x2 targs0
           | Right -> Right)
        | Right -> Right)
     | _ -> Right))

type 'f fundef =
| Internal of 'f
| External of external_function

(** val transf_fundef : ('a1 -> 'a2) -> 'a1 fundef -> 'a2 fundef **)

let transf_fundef transf = function
| Internal f -> Internal (transf f)
| External ef -> External ef

(** val transf_partial_fundef :
    ('a1 -> 'a2 res) -> 'a1 fundef -> 'a2 fundef res **)

let transf_partial_fundef transf_partial = function
| Internal f -> bind (transf_partial f) (fun f' -> OK (Internal f'))
| External ef -> OK (External ef)

type 'a builtin_arg =
| BA of 'a
| BA_int of Int.int
| BA_long of Int64.int
| BA_float of float
| BA_single of float32
| BA_loadstack of memory_chunk * Int.int
| BA_addrstack of Int.int
| BA_loadglobal of memory_chunk * ident * Int.int
| BA_addrglobal of ident * Int.int
| BA_splitlong of 'a builtin_arg * 'a builtin_arg

type 'a builtin_res =
| BR of 'a
| BR_none
| BR_splitlong of 'a builtin_res * 'a builtin_res

(** val globals_of_builtin_arg : 'a1 builtin_arg -> ident list **)

let rec globals_of_builtin_arg = function
| BA_loadglobal (chunk, id, ofs) -> Cons (id, Nil)
| BA_addrglobal (id, ofs) -> Cons (id, Nil)
| BA_splitlong (hi, lo) ->
  app (globals_of_builtin_arg hi) (globals_of_builtin_arg lo)
| _ -> Nil

(** val globals_of_builtin_args : 'a1 builtin_arg list -> ident list **)

let globals_of_builtin_args al =
  fold_right (fun a l -> app (globals_of_builtin_arg a) l) Nil al

(** val params_of_builtin_arg : 'a1 builtin_arg -> 'a1 list **)

let rec params_of_builtin_arg = function
| BA x -> Cons (x, Nil)
| BA_splitlong (hi, lo) ->
  app (params_of_builtin_arg hi) (params_of_builtin_arg lo)
| _ -> Nil

(** val params_of_builtin_args : 'a1 builtin_arg list -> 'a1 list **)

let params_of_builtin_args al =
  fold_right (fun a l -> app (params_of_builtin_arg a) l) Nil al

(** val params_of_builtin_res : 'a1 builtin_res -> 'a1 list **)

let rec params_of_builtin_res = function
| BR x -> Cons (x, Nil)
| BR_none -> Nil
| BR_splitlong (hi, lo) ->
  app (params_of_builtin_res hi) (params_of_builtin_res lo)

(** val map_builtin_arg :
    ('a1 -> 'a2) -> 'a1 builtin_arg -> 'a2 builtin_arg **)

let rec map_builtin_arg f = function
| BA x -> BA (f x)
| BA_int n0 -> BA_int n0
| BA_long n0 -> BA_long n0
| BA_float n0 -> BA_float n0
| BA_single n0 -> BA_single n0
| BA_loadstack (chunk, ofs) -> BA_loadstack (chunk, ofs)
| BA_addrstack ofs -> BA_addrstack ofs
| BA_loadglobal (chunk, id, ofs) -> BA_loadglobal (chunk, id, ofs)
| BA_addrglobal (id, ofs) -> BA_addrglobal (id, ofs)
| BA_splitlong (hi, lo) ->
  BA_splitlong ((map_builtin_arg f hi), (map_builtin_arg f lo))

(** val map_builtin_res :
    ('a1 -> 'a2) -> 'a1 builtin_res -> 'a2 builtin_res **)

let rec map_builtin_res f = function
| BR x -> BR (f x)
| BR_none -> BR_none
| BR_splitlong (hi, lo) ->
  BR_splitlong ((map_builtin_res f hi), (map_builtin_res f lo))

type builtin_arg_constraint =
| OK_default
| OK_const
| OK_addrstack
| OK_addrglobal
| OK_addrany
| OK_all

(** val builtin_arg_ok :
    'a1 builtin_arg -> builtin_arg_constraint -> bool **)

let builtin_arg_ok ba c =
  match ba with
  | BA x -> True
  | BA_loadstack (chunk, ofs) ->
    (match c with
     | OK_all -> True
     | _ -> False)
  | BA_addrstack ofs ->
    (match c with
     | OK_default -> False
     | OK_const -> False
     | OK_addrglobal -> False
     | _ -> True)
  | BA_loadglobal (chunk, id, ofs) ->
    (match c with
     | OK_all -> True
     | _ -> False)
  | BA_addrglobal (id, ofs) ->
    (match c with
     | OK_default -> False
     | OK_const -> False
     | OK_addrstack -> False
     | _ -> True)
  | BA_splitlong (hi, lo) -> True
  | _ ->
    (match c with
     | OK_const -> True
     | OK_all -> True
     | _ -> False)

type block = positive

(** val eq_block : positive -> positive -> sumbool **)

let eq_block =
  peq

type val0 =
| Vundef
| Vint of Int.int
| Vlong of Int64.int
| Vfloat of float
| Vsingle of float32
| Vptr of block * Int.int

(** val vzero : val0 **)

let vzero =
  Vint Int.zero

(** val vtrue : val0 **)

let vtrue =
  Vint Int.one

(** val vfalse : val0 **)

let vfalse =
  Vint Int.zero

module Val = 
 struct 
  (** val eq : val0 -> val0 -> sumbool **)
  
  let eq x y =
    match x with
    | Vundef ->
      (match y with
       | Vundef -> Left
       | _ -> Right)
    | Vint x0 ->
      (match y with
       | Vint i0 -> Int.eq_dec x0 i0
       | _ -> Right)
    | Vlong x0 ->
      (match y with
       | Vlong i0 -> Int64.eq_dec x0 i0
       | _ -> Right)
    | Vfloat x0 ->
      (match y with
       | Vfloat f0 -> Float.eq_dec x0 f0
       | _ -> Right)
    | Vsingle x0 ->
      (match y with
       | Vsingle f0 -> Float32.eq_dec x0 f0
       | _ -> Right)
    | Vptr (x0, x1) ->
      (match y with
       | Vptr (b0, i0) ->
         (match eq_block x0 b0 with
          | Left -> Int.eq_dec x1 i0
          | Right -> Right)
       | _ -> Right)
  
  (** val neg : val0 -> val0 **)
  
  let neg = function
  | Vint n0 -> Vint (Int.neg n0)
  | _ -> Vundef
  
  (** val negf : val0 -> val0 **)
  
  let negf = function
  | Vfloat f -> Vfloat (Float.neg f)
  | _ -> Vundef
  
  (** val absf : val0 -> val0 **)
  
  let absf = function
  | Vfloat f -> Vfloat (Float.abs f)
  | _ -> Vundef
  
  (** val negfs : val0 -> val0 **)
  
  let negfs = function
  | Vsingle f -> Vsingle (Float32.neg f)
  | _ -> Vundef
  
  (** val absfs : val0 -> val0 **)
  
  let absfs = function
  | Vsingle f -> Vsingle (Float32.abs f)
  | _ -> Vundef
  
  (** val maketotal : val0 option -> val0 **)
  
  let maketotal = function
  | Some v -> v
  | None -> Vundef
  
  (** val intoffloat : val0 -> val0 option **)
  
  let intoffloat = function
  | Vfloat f -> option_map (fun x -> Vint x) (Float.to_int f)
  | _ -> None
  
  (** val intuoffloat : val0 -> val0 option **)
  
  let intuoffloat = function
  | Vfloat f -> option_map (fun x -> Vint x) (Float.to_intu f)
  | _ -> None
  
  (** val floatofint : val0 -> val0 option **)
  
  let floatofint = function
  | Vint n0 -> Some (Vfloat (Float.of_int n0))
  | _ -> None
  
  (** val floatofintu : val0 -> val0 option **)
  
  let floatofintu = function
  | Vint n0 -> Some (Vfloat (Float.of_intu n0))
  | _ -> None
  
  (** val intofsingle : val0 -> val0 option **)
  
  let intofsingle = function
  | Vsingle f -> option_map (fun x -> Vint x) (Float32.to_int f)
  | _ -> None
  
  (** val intuofsingle : val0 -> val0 option **)
  
  let intuofsingle = function
  | Vsingle f -> option_map (fun x -> Vint x) (Float32.to_intu f)
  | _ -> None
  
  (** val singleofint : val0 -> val0 option **)
  
  let singleofint = function
  | Vint n0 -> Some (Vsingle (Float32.of_int n0))
  | _ -> None
  
  (** val singleofintu : val0 -> val0 option **)
  
  let singleofintu = function
  | Vint n0 -> Some (Vsingle (Float32.of_intu n0))
  | _ -> None
  
  (** val negint : val0 -> val0 **)
  
  let negint = function
  | Vint n0 -> Vint (Int.neg n0)
  | _ -> Vundef
  
  (** val notint : val0 -> val0 **)
  
  let notint = function
  | Vint n0 -> Vint (Int.not n0)
  | _ -> Vundef
  
  (** val of_bool : bool -> val0 **)
  
  let of_bool = function
  | True -> vtrue
  | False -> vfalse
  
  (** val boolval : val0 -> val0 **)
  
  let boolval = function
  | Vint n0 -> of_bool (negb (Int.eq n0 Int.zero))
  | Vptr (b, ofs) -> vtrue
  | _ -> Vundef
  
  (** val notbool : val0 -> val0 **)
  
  let notbool = function
  | Vint n0 -> of_bool (Int.eq n0 Int.zero)
  | Vptr (b, ofs) -> vfalse
  | _ -> Vundef
  
  (** val zero_ext : z -> val0 -> val0 **)
  
  let zero_ext nbits = function
  | Vint n0 -> Vint (Int.zero_ext nbits n0)
  | _ -> Vundef
  
  (** val sign_ext : z -> val0 -> val0 **)
  
  let sign_ext nbits = function
  | Vint n0 -> Vint (Int.sign_ext nbits n0)
  | _ -> Vundef
  
  (** val singleoffloat : val0 -> val0 **)
  
  let singleoffloat = function
  | Vfloat f -> Vsingle (Float.to_single f)
  | _ -> Vundef
  
  (** val floatofsingle : val0 -> val0 **)
  
  let floatofsingle = function
  | Vsingle f -> Vfloat (Float.of_single f)
  | _ -> Vundef
  
  (** val add : val0 -> val0 -> val0 **)
  
  let add v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.add n1 n2)
       | Vptr (b2, ofs2) -> Vptr (b2, (Int.add ofs2 n1))
       | _ -> Vundef)
    | Vptr (b1, ofs1) ->
      (match v2 with
       | Vint n2 -> Vptr (b1, (Int.add ofs1 n2))
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val sub : val0 -> val0 -> val0 **)
  
  let sub v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.sub n1 n2)
       | _ -> Vundef)
    | Vptr (b1, ofs1) ->
      (match v2 with
       | Vint n2 -> Vptr (b1, (Int.sub ofs1 n2))
       | Vptr (b2, ofs2) ->
         (match eq_block b1 b2 with
          | Left -> Vint (Int.sub ofs1 ofs2)
          | Right -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mul : val0 -> val0 -> val0 **)
  
  let mul v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.mul n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mulhs : val0 -> val0 -> val0 **)
  
  let mulhs v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.mulhs n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mulhu : val0 -> val0 -> val0 **)
  
  let mulhu v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.mulhu n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val divs : val0 -> val0 -> val0 option **)
  
  let divs v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match match Int.eq n2 Int.zero with
                | True -> True
                | False ->
                  (match Int.eq n1 (Int.repr Int.min_signed) with
                   | True -> Int.eq n2 Int.mone
                   | False -> False) with
          | True -> None
          | False -> Some (Vint (Int.divs n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val mods : val0 -> val0 -> val0 option **)
  
  let mods v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match match Int.eq n2 Int.zero with
                | True -> True
                | False ->
                  (match Int.eq n1 (Int.repr Int.min_signed) with
                   | True -> Int.eq n2 Int.mone
                   | False -> False) with
          | True -> None
          | False -> Some (Vint (Int.mods n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val divu : val0 -> val0 -> val0 option **)
  
  let divu v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.eq n2 Int.zero with
          | True -> None
          | False -> Some (Vint (Int.divu n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val modu : val0 -> val0 -> val0 option **)
  
  let modu v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.eq n2 Int.zero with
          | True -> None
          | False -> Some (Vint (Int.modu n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val add_carry : val0 -> val0 -> val0 -> val0 **)
  
  let add_carry v1 v2 cin =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match cin with
          | Vint c -> Vint (Int.add_carry n1 n2 c)
          | _ -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val sub_overflow : val0 -> val0 -> val0 **)
  
  let sub_overflow v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.sub_overflow n1 n2 Int.zero)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val negative : val0 -> val0 **)
  
  let negative = function
  | Vint n0 -> Vint (Int.negative n0)
  | _ -> Vundef
  
  (** val coq_and : val0 -> val0 -> val0 **)
  
  let coq_and v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.coq_and n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val coq_or : val0 -> val0 -> val0 **)
  
  let coq_or v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.coq_or n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val xor : val0 -> val0 -> val0 **)
  
  let xor v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vint (Int.xor n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shl : val0 -> val0 -> val0 **)
  
  let shl v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int.iwordsize with
          | True -> Vint (Int.shl n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shr : val0 -> val0 -> val0 **)
  
  let shr v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int.iwordsize with
          | True -> Vint (Int.shr n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shr_carry : val0 -> val0 -> val0 **)
  
  let shr_carry v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int.iwordsize with
          | True -> Vint (Int.shr_carry n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shrx : val0 -> val0 -> val0 option **)
  
  let shrx v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 (Int.repr (Zpos (XI (XI (XI (XI XH)))))) with
          | True -> Some (Vint (Int.shrx n1 n2))
          | False -> None)
       | _ -> None)
    | _ -> None
  
  (** val shru : val0 -> val0 -> val0 **)
  
  let shru v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int.iwordsize with
          | True -> Vint (Int.shru n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val rolm : val0 -> Int.int -> Int.int -> val0 **)
  
  let rolm v amount mask0 =
    match v with
    | Vint n0 -> Vint (Int.rolm n0 amount mask0)
    | _ -> Vundef
  
  (** val ror : val0 -> val0 -> val0 **)
  
  let ror v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int.iwordsize with
          | True -> Vint (Int.ror n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val addf : val0 -> val0 -> val0 **)
  
  let addf v1 v2 =
    match v1 with
    | Vfloat f1 ->
      (match v2 with
       | Vfloat f2 -> Vfloat (Float.add f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val subf : val0 -> val0 -> val0 **)
  
  let subf v1 v2 =
    match v1 with
    | Vfloat f1 ->
      (match v2 with
       | Vfloat f2 -> Vfloat (Float.sub f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mulf : val0 -> val0 -> val0 **)
  
  let mulf v1 v2 =
    match v1 with
    | Vfloat f1 ->
      (match v2 with
       | Vfloat f2 -> Vfloat (Float.mul f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val divf : val0 -> val0 -> val0 **)
  
  let divf v1 v2 =
    match v1 with
    | Vfloat f1 ->
      (match v2 with
       | Vfloat f2 -> Vfloat (Float.div f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val floatofwords : val0 -> val0 -> val0 **)
  
  let floatofwords v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vfloat (Float.from_words n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val addfs : val0 -> val0 -> val0 **)
  
  let addfs v1 v2 =
    match v1 with
    | Vsingle f1 ->
      (match v2 with
       | Vsingle f2 -> Vsingle (Float32.add f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val subfs : val0 -> val0 -> val0 **)
  
  let subfs v1 v2 =
    match v1 with
    | Vsingle f1 ->
      (match v2 with
       | Vsingle f2 -> Vsingle (Float32.sub f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mulfs : val0 -> val0 -> val0 **)
  
  let mulfs v1 v2 =
    match v1 with
    | Vsingle f1 ->
      (match v2 with
       | Vsingle f2 -> Vsingle (Float32.mul f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val divfs : val0 -> val0 -> val0 **)
  
  let divfs v1 v2 =
    match v1 with
    | Vsingle f1 ->
      (match v2 with
       | Vsingle f2 -> Vsingle (Float32.div f1 f2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val longofwords : val0 -> val0 -> val0 **)
  
  let longofwords v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vlong (Int64.ofwords n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val loword : val0 -> val0 **)
  
  let loword = function
  | Vlong n0 -> Vint (Int64.loword n0)
  | _ -> Vundef
  
  (** val hiword : val0 -> val0 **)
  
  let hiword = function
  | Vlong n0 -> Vint (Int64.hiword n0)
  | _ -> Vundef
  
  (** val negl : val0 -> val0 **)
  
  let negl = function
  | Vlong n0 -> Vlong (Int64.neg n0)
  | _ -> Vundef
  
  (** val notl : val0 -> val0 **)
  
  let notl = function
  | Vlong n0 -> Vlong (Int64.not n0)
  | _ -> Vundef
  
  (** val longofint : val0 -> val0 **)
  
  let longofint = function
  | Vint n0 -> Vlong (Int64.repr (Int.signed n0))
  | _ -> Vundef
  
  (** val longofintu : val0 -> val0 **)
  
  let longofintu = function
  | Vint n0 -> Vlong (Int64.repr (Int.unsigned n0))
  | _ -> Vundef
  
  (** val longoffloat : val0 -> val0 option **)
  
  let longoffloat = function
  | Vfloat f -> option_map (fun x -> Vlong x) (Float.to_long f)
  | _ -> None
  
  (** val longuoffloat : val0 -> val0 option **)
  
  let longuoffloat = function
  | Vfloat f -> option_map (fun x -> Vlong x) (Float.to_longu f)
  | _ -> None
  
  (** val longofsingle : val0 -> val0 option **)
  
  let longofsingle = function
  | Vsingle f -> option_map (fun x -> Vlong x) (Float32.to_long f)
  | _ -> None
  
  (** val longuofsingle : val0 -> val0 option **)
  
  let longuofsingle = function
  | Vsingle f -> option_map (fun x -> Vlong x) (Float32.to_longu f)
  | _ -> None
  
  (** val floatoflong : val0 -> val0 option **)
  
  let floatoflong = function
  | Vlong n0 -> Some (Vfloat (Float.of_long n0))
  | _ -> None
  
  (** val floatoflongu : val0 -> val0 option **)
  
  let floatoflongu = function
  | Vlong n0 -> Some (Vfloat (Float.of_longu n0))
  | _ -> None
  
  (** val singleoflong : val0 -> val0 option **)
  
  let singleoflong = function
  | Vlong n0 -> Some (Vsingle (Float32.of_long n0))
  | _ -> None
  
  (** val singleoflongu : val0 -> val0 option **)
  
  let singleoflongu = function
  | Vlong n0 -> Some (Vsingle (Float32.of_longu n0))
  | _ -> None
  
  (** val addl : val0 -> val0 -> val0 **)
  
  let addl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.add n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val subl : val0 -> val0 -> val0 **)
  
  let subl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.sub n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mull : val0 -> val0 -> val0 **)
  
  let mull v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.mul n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val mull' : val0 -> val0 -> val0 **)
  
  let mull' v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Vlong (Int64.mul' n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val divls : val0 -> val0 -> val0 option **)
  
  let divls v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 ->
         (match match Int64.eq n2 Int64.zero with
                | True -> True
                | False ->
                  (match Int64.eq n1 (Int64.repr Int64.min_signed) with
                   | True -> Int64.eq n2 Int64.mone
                   | False -> False) with
          | True -> None
          | False -> Some (Vlong (Int64.divs n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val modls : val0 -> val0 -> val0 option **)
  
  let modls v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 ->
         (match match Int64.eq n2 Int64.zero with
                | True -> True
                | False ->
                  (match Int64.eq n1 (Int64.repr Int64.min_signed) with
                   | True -> Int64.eq n2 Int64.mone
                   | False -> False) with
          | True -> None
          | False -> Some (Vlong (Int64.mods n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val divlu : val0 -> val0 -> val0 option **)
  
  let divlu v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 ->
         (match Int64.eq n2 Int64.zero with
          | True -> None
          | False -> Some (Vlong (Int64.divu n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val modlu : val0 -> val0 -> val0 option **)
  
  let modlu v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 ->
         (match Int64.eq n2 Int64.zero with
          | True -> None
          | False -> Some (Vlong (Int64.modu n1 n2)))
       | _ -> None)
    | _ -> None
  
  (** val andl : val0 -> val0 -> val0 **)
  
  let andl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.coq_and n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val orl : val0 -> val0 -> val0 **)
  
  let orl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.coq_or n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val xorl : val0 -> val0 -> val0 **)
  
  let xorl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Vlong (Int64.xor n1 n2)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shll : val0 -> val0 -> val0 **)
  
  let shll v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int64.iwordsize' with
          | True -> Vlong (Int64.shl' n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shrl : val0 -> val0 -> val0 **)
  
  let shrl v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int64.iwordsize' with
          | True -> Vlong (Int64.shr' n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val shrlu : val0 -> val0 -> val0 **)
  
  let shrlu v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vint n2 ->
         (match Int.ltu n2 Int64.iwordsize' with
          | True -> Vlong (Int64.shru' n1 n2)
          | False -> Vundef)
       | _ -> Vundef)
    | _ -> Vundef
  
  (** val cmp_bool : comparison0 -> val0 -> val0 -> bool option **)
  
  let cmp_bool c v1 v2 =
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Some (Int.cmp c n1 n2)
       | _ -> None)
    | _ -> None
  
  (** val cmp_different_blocks : comparison0 -> bool option **)
  
  let cmp_different_blocks = function
  | Ceq -> Some False
  | Cne -> Some True
  | _ -> None
  
  (** val cmpu_bool :
      (block -> z -> bool) -> comparison0 -> val0 -> val0 -> bool option **)
  
  let cmpu_bool valid_ptr =
    let weak_valid_ptr = fun b ofs ->
      match valid_ptr b ofs with
      | True -> True
      | False -> valid_ptr b (Z.sub ofs (Zpos XH))
    in
    (fun c v1 v2 ->
    match v1 with
    | Vint n1 ->
      (match v2 with
       | Vint n2 -> Some (Int.cmpu c n1 n2)
       | Vptr (b2, ofs2) ->
         (match match Int.eq n1 Int.zero with
                | True -> weak_valid_ptr b2 (Int.unsigned ofs2)
                | False -> False with
          | True -> cmp_different_blocks c
          | False -> None)
       | _ -> None)
    | Vptr (b1, ofs1) ->
      (match v2 with
       | Vint n2 ->
         (match match Int.eq n2 Int.zero with
                | True -> weak_valid_ptr b1 (Int.unsigned ofs1)
                | False -> False with
          | True -> cmp_different_blocks c
          | False -> None)
       | Vptr (b2, ofs2) ->
         (match eq_block b1 b2 with
          | Left ->
            (match match weak_valid_ptr b1 (Int.unsigned ofs1) with
                   | True -> weak_valid_ptr b2 (Int.unsigned ofs2)
                   | False -> False with
             | True -> Some (Int.cmpu c ofs1 ofs2)
             | False -> None)
          | Right ->
            (match match valid_ptr b1 (Int.unsigned ofs1) with
                   | True -> valid_ptr b2 (Int.unsigned ofs2)
                   | False -> False with
             | True -> cmp_different_blocks c
             | False -> None))
       | _ -> None)
    | _ -> None)
  
  (** val cmpf_bool : comparison0 -> val0 -> val0 -> bool option **)
  
  let cmpf_bool c v1 v2 =
    match v1 with
    | Vfloat f1 ->
      (match v2 with
       | Vfloat f2 -> Some (Float.cmp c f1 f2)
       | _ -> None)
    | _ -> None
  
  (** val cmpfs_bool : comparison0 -> val0 -> val0 -> bool option **)
  
  let cmpfs_bool c v1 v2 =
    match v1 with
    | Vsingle f1 ->
      (match v2 with
       | Vsingle f2 -> Some (Float32.cmp c f1 f2)
       | _ -> None)
    | _ -> None
  
  (** val cmpl_bool : comparison0 -> val0 -> val0 -> bool option **)
  
  let cmpl_bool c v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Some (Int64.cmp c n1 n2)
       | _ -> None)
    | _ -> None
  
  (** val cmplu_bool : comparison0 -> val0 -> val0 -> bool option **)
  
  let cmplu_bool c v1 v2 =
    match v1 with
    | Vlong n1 ->
      (match v2 with
       | Vlong n2 -> Some (Int64.cmpu c n1 n2)
       | _ -> None)
    | _ -> None
  
  (** val of_optbool : bool option -> val0 **)
  
  let of_optbool = function
  | Some b ->
    (match b with
     | True -> vtrue
     | False -> vfalse)
  | None -> Vundef
  
  (** val cmp : comparison0 -> val0 -> val0 -> val0 **)
  
  let cmp c v1 v2 =
    of_optbool (cmp_bool c v1 v2)
  
  (** val cmpu :
      (block -> z -> bool) -> comparison0 -> val0 -> val0 -> val0 **)
  
  let cmpu valid_ptr c v1 v2 =
    of_optbool (cmpu_bool valid_ptr c v1 v2)
  
  (** val cmpf : comparison0 -> val0 -> val0 -> val0 **)
  
  let cmpf c v1 v2 =
    of_optbool (cmpf_bool c v1 v2)
  
  (** val cmpfs : comparison0 -> val0 -> val0 -> val0 **)
  
  let cmpfs c v1 v2 =
    of_optbool (cmpfs_bool c v1 v2)
  
  (** val cmpl : comparison0 -> val0 -> val0 -> val0 option **)
  
  let cmpl c v1 v2 =
    option_map of_bool (cmpl_bool c v1 v2)
  
  (** val cmplu : comparison0 -> val0 -> val0 -> val0 option **)
  
  let cmplu c v1 v2 =
    option_map of_bool (cmplu_bool c v1 v2)
  
  (** val maskzero_bool : val0 -> Int.int -> bool option **)
  
  let maskzero_bool v mask0 =
    match v with
    | Vint n0 -> Some (Int.eq (Int.coq_and n0 mask0) Int.zero)
    | _ -> None
  
  (** val load_result : memory_chunk -> val0 -> val0 **)
  
  let load_result chunk v =
    match chunk with
    | Mint8signed ->
      (match v with
       | Vint n0 -> Vint (Int.sign_ext (Zpos (XO (XO (XO XH)))) n0)
       | _ -> Vundef)
    | Mint8unsigned ->
      (match v with
       | Vint n0 -> Vint (Int.zero_ext (Zpos (XO (XO (XO XH)))) n0)
       | _ -> Vundef)
    | Mint16signed ->
      (match v with
       | Vint n0 -> Vint (Int.sign_ext (Zpos (XO (XO (XO (XO XH))))) n0)
       | _ -> Vundef)
    | Mint16unsigned ->
      (match v with
       | Vint n0 -> Vint (Int.zero_ext (Zpos (XO (XO (XO (XO XH))))) n0)
       | _ -> Vundef)
    | Mint32 ->
      (match v with
       | Vint n0 -> Vint n0
       | Vptr (b, ofs) -> Vptr (b, ofs)
       | _ -> Vundef)
    | Mint64 ->
      (match v with
       | Vlong n0 -> Vlong n0
       | _ -> Vundef)
    | Mfloat32 ->
      (match v with
       | Vsingle f -> Vsingle f
       | _ -> Vundef)
    | Mfloat64 ->
      (match v with
       | Vfloat f -> Vfloat f
       | _ -> Vundef)
    | Many32 ->
      (match v with
       | Vundef -> Vundef
       | Vlong i -> Vundef
       | Vfloat f -> Vundef
       | _ -> v)
    | Many64 -> v
  
  type meminj = block -> (block, z) prod option
 end

type 'a eqDec = 'a -> 'a -> sumbool

(** val equiv_dec : 'a1 eqDec -> 'a1 -> 'a1 -> sumbool **)

let equiv_dec eqDec0 =
  eqDec0

module type TREE = 
 sig 
  type elt 
  
  val elt_eq : elt -> elt -> sumbool
  
  type 'x t 
  
  val empty : 'a1 t
  
  val get : elt -> 'a1 t -> 'a1 option
  
  val set : elt -> 'a1 -> 'a1 t -> 'a1 t
  
  val remove : elt -> 'a1 t -> 'a1 t
  
  val beq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
  
  val map : (elt -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t
  
  val map1 : ('a1 -> 'a2) -> 'a1 t -> 'a2 t
  
  val combine :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t
  
  val elements : 'a1 t -> (elt, 'a1) prod list
  
  val fold : ('a2 -> elt -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2
  
  val fold1 : ('a2 -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2
 end

module PTree = 
 struct 
  type elt = positive
  
  (** val elt_eq : positive -> positive -> sumbool **)
  
  let elt_eq =
    peq
  
  type 'a tree =
  | Leaf
  | Node of 'a tree * 'a option * 'a tree
  
  type 'a t = 'a tree
  
  (** val empty : 'a1 t **)
  
  let empty =
    Leaf
  
  (** val get : positive -> 'a1 t -> 'a1 option **)
  
  let rec get i = function
  | Leaf -> None
  | Node (l, o, r) ->
    (match i with
     | XI ii -> get ii r
     | XO ii -> get ii l
     | XH -> o)
  
  (** val set : positive -> 'a1 -> 'a1 t -> 'a1 t **)
  
  let rec set i v = function
  | Leaf ->
    (match i with
     | XI ii -> Node (Leaf, None, (set ii v Leaf))
     | XO ii -> Node ((set ii v Leaf), None, Leaf)
     | XH -> Node (Leaf, (Some v), Leaf))
  | Node (l, o, r) ->
    (match i with
     | XI ii -> Node (l, o, (set ii v r))
     | XO ii -> Node ((set ii v l), o, r)
     | XH -> Node (l, (Some v), r))
  
  (** val remove : positive -> 'a1 t -> 'a1 t **)
  
  let rec remove i m0 =
    match i with
    | XI ii ->
      (match m0 with
       | Leaf -> Leaf
       | Node (l, o, r) ->
         (match l with
          | Leaf ->
            (match o with
             | Some a -> Node (l, o, (remove ii r))
             | None ->
               (match remove ii r with
                | Leaf -> Leaf
                | Node (t1, o0, t2) -> Node (Leaf, None, (Node (t1, o0, t2)))))
          | Node (t1, o0, t2) -> Node (l, o, (remove ii r))))
    | XO ii ->
      (match m0 with
       | Leaf -> Leaf
       | Node (l, o, r) ->
         (match o with
          | Some a -> Node ((remove ii l), o, r)
          | None ->
            (match r with
             | Leaf ->
               (match remove ii l with
                | Leaf -> Leaf
                | Node (t1, o0, t2) -> Node ((Node (t1, o0, t2)), None, Leaf))
             | Node (t1, o0, t2) -> Node ((remove ii l), o, r))))
    | XH ->
      (match m0 with
       | Leaf -> Leaf
       | Node (l, o, r) ->
         (match l with
          | Leaf ->
            (match r with
             | Leaf -> Leaf
             | Node (t1, o0, t2) -> Node (l, None, r))
          | Node (t1, o0, t2) -> Node (l, None, r)))
  
  (** val bempty : 'a1 t -> bool **)
  
  let rec bempty = function
  | Leaf -> True
  | Node (l, o, r) ->
    (match o with
     | Some a -> False
     | None ->
       (match bempty l with
        | True -> bempty r
        | False -> False))
  
  (** val beq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let rec beq beqA m1 m2 =
    match m1 with
    | Leaf -> bempty m2
    | Node (l1, o1, r1) ->
      (match m2 with
       | Leaf -> bempty m1
       | Node (l2, o2, r2) ->
         (match match match o1 with
                      | Some y1 ->
                        (match o2 with
                         | Some y2 -> beqA y1 y2
                         | None -> False)
                      | None ->
                        (match o2 with
                         | Some a -> False
                         | None -> True) with
                | True -> beq beqA l1 l2
                | False -> False with
          | True -> beq beqA r1 r2
          | False -> False))
  
  (** val prev_append : positive -> positive -> positive **)
  
  let rec prev_append i j =
    match i with
    | XI i' -> prev_append i' (XI j)
    | XO i' -> prev_append i' (XO j)
    | XH -> j
  
  (** val prev : positive -> positive **)
  
  let prev i =
    prev_append i XH
  
  (** val xmap : (positive -> 'a1 -> 'a2) -> 'a1 t -> positive -> 'a2 t **)
  
  let rec xmap f m0 i =
    match m0 with
    | Leaf -> Leaf
    | Node (l, o, r) ->
      Node ((xmap f l (XO i)),
        (match o with
         | Some x -> Some (f (prev i) x)
         | None -> None), (xmap f r (XI i)))
  
  (** val map : (positive -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m0 =
    xmap f m0 XH
  
  (** val map1 : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let rec map1 f = function
  | Leaf -> Leaf
  | Node (l, o, r) -> Node ((map1 f l), (option_map f o), (map1 f r))
  
  (** val coq_Node' : 'a1 t -> 'a1 option -> 'a1 t -> 'a1 t **)
  
  let coq_Node' l x r =
    match l with
    | Leaf ->
      (match x with
       | Some a -> Node (l, x, r)
       | None ->
         (match r with
          | Leaf -> Leaf
          | Node (t1, o, t2) -> Node (l, x, r)))
    | Node (t1, o, t2) -> Node (l, x, r)
  
  (** val filter1 : ('a1 -> bool) -> 'a1 t -> 'a1 t **)
  
  let rec filter1 pred0 = function
  | Leaf -> Leaf
  | Node (l, o, r) ->
    let o' =
      match o with
      | Some x ->
        (match pred0 x with
         | True -> o
         | False -> None)
      | None -> None
    in
    coq_Node' (filter1 pred0 l) o' (filter1 pred0 r)
  
  (** val xcombine_l :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t **)
  
  let rec xcombine_l f = function
  | Leaf -> Leaf
  | Node (l, o, r) -> coq_Node' (xcombine_l f l) (f o None) (xcombine_l f r)
  
  (** val xcombine_r :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t **)
  
  let rec xcombine_r f = function
  | Leaf -> Leaf
  | Node (l, o, r) -> coq_Node' (xcombine_r f l) (f None o) (xcombine_r f r)
  
  (** val combine :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t **)
  
  let rec combine f m1 m2 =
    match m1 with
    | Leaf -> xcombine_r f m2
    | Node (l1, o1, r1) ->
      (match m2 with
       | Leaf -> xcombine_l f m1
       | Node (l2, o2, r2) ->
         coq_Node' (combine f l1 l2) (f o1 o2) (combine f r1 r2))
  
  (** val xelements :
      'a1 t -> positive -> (positive, 'a1) prod list -> (positive, 'a1) prod
      list **)
  
  let rec xelements m0 i k =
    match m0 with
    | Leaf -> k
    | Node (l, o, r) ->
      (match o with
       | Some x ->
         xelements l (XO i) (Cons ((Pair ((prev i), x)),
           (xelements r (XI i) k)))
       | None -> xelements l (XO i) (xelements r (XI i) k))
  
  (** val elements : 'a1 t -> (positive, 'a1) prod list **)
  
  let elements m0 =
    xelements m0 XH Nil
  
  (** val xkeys : 'a1 t -> positive -> positive list **)
  
  let xkeys m0 i =
    Coq__1.map fst (xelements m0 i Nil)
  
  (** val xfold :
      ('a2 -> positive -> 'a1 -> 'a2) -> positive -> 'a1 t -> 'a2 -> 'a2 **)
  
  let rec xfold f i m0 v =
    match m0 with
    | Leaf -> v
    | Node (l, o, r) ->
      (match o with
       | Some x ->
         let v1 = xfold f (XO i) l v in
         let v2 = f v1 (prev i) x in xfold f (XI i) r v2
       | None -> let v1 = xfold f (XO i) l v in xfold f (XI i) r v1)
  
  (** val fold : ('a2 -> positive -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 **)
  
  let fold f m0 v =
    xfold f XH m0 v
  
  (** val fold1 : ('a2 -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 **)
  
  let rec fold1 f m0 v =
    match m0 with
    | Leaf -> v
    | Node (l, o, r) ->
      (match o with
       | Some x -> let v1 = fold1 f l v in let v2 = f v1 x in fold1 f r v2
       | None -> let v1 = fold1 f l v in fold1 f r v1)
 end

module PMap = 
 struct 
  type elt = positive
  
  (** val elt_eq : positive -> positive -> sumbool **)
  
  let elt_eq =
    peq
  
  type 'a t = ('a, 'a PTree.t) prod
  
  (** val init : 'a1 -> ('a1, 'a1 PTree.t) prod **)
  
  let init x =
    Pair (x, PTree.empty)
  
  (** val get : positive -> 'a1 t -> 'a1 **)
  
  let get i m0 =
    match PTree.get i (snd m0) with
    | Some x -> x
    | None -> fst m0
  
  (** val set : positive -> 'a1 -> 'a1 t -> ('a1, 'a1 PTree.t) prod **)
  
  let set i x m0 =
    Pair ((fst m0), (PTree.set i x (snd m0)))
  
  (** val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m0 =
    Pair ((f (fst m0)), (PTree.map1 f (snd m0)))
 end

module type INDEXED_TYPE = 
 sig 
  type t 
  
  val index : t -> positive
  
  val eq : t -> t -> sumbool
 end

module IMap = 
 functor (X:INDEXED_TYPE) ->
 struct 
  type elt = X.t
  
  (** val elt_eq : X.t -> X.t -> sumbool **)
  
  let elt_eq =
    X.eq
  
  type 'x t = 'x PMap.t
  
  (** val init : 'a1 -> ('a1, 'a1 PTree.t) prod **)
  
  let init x =
    PMap.init x
  
  (** val get : X.t -> 'a1 t -> 'a1 **)
  
  let get i m0 =
    PMap.get (X.index i) m0
  
  (** val set : X.t -> 'a1 -> 'a1 t -> ('a1, 'a1 PTree.t) prod **)
  
  let set i v m0 =
    PMap.set (X.index i) v m0
  
  (** val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m0 =
    PMap.map f m0
 end

module ZIndexed = 
 struct 
  type t = z
  
  (** val index : z -> positive **)
  
  let index = function
  | Z0 -> XH
  | Zpos p -> XO p
  | Zneg p -> XI p
  
  (** val eq : z -> z -> sumbool **)
  
  let eq =
    zeq
 end

module ZMap = IMap(ZIndexed)

module Tree_Properties = 
 functor (T:TREE) ->
 struct 
  (** val cardinal : 'a1 T.t -> nat **)
  
  let cardinal x =
    length (T.elements x)
  
  (** val for_all : 'a1 T.t -> (T.elt -> 'a1 -> bool) -> bool **)
  
  let for_all m0 f =
    T.fold (fun b x a ->
      match b with
      | True -> f x a
      | False -> False) m0 True
  
  (** val exists_ : 'a1 T.t -> (T.elt -> 'a1 -> bool) -> bool **)
  
  let exists_ m0 f =
    T.fold (fun b x a ->
      match b with
      | True -> True
      | False -> f x a) m0 False
  
  (** val coq_Equal_dec : 'a1 eqDec -> 'a1 T.t -> 'a1 T.t -> sumbool **)
  
  let coq_Equal_dec eqAdec m1 m2 =
    let filtered_var =
      T.beq (fun a1 a2 -> proj_sumbool (equiv_dec eqAdec a1 a2)) m1 m2
    in
    (match filtered_var with
     | True -> Left
     | False -> Right)
  
  (** val coq_Equal_EqDec : 'a1 eqDec -> 'a1 T.t eqDec **)
  
  let coq_Equal_EqDec eqAdec =
    coq_Equal_dec eqAdec
 end

module PTree_Properties = Tree_Properties(PTree)

(** val size_chunk : memory_chunk -> z **)

let size_chunk = function
| Mint8signed -> Zpos XH
| Mint8unsigned -> Zpos XH
| Mint16signed -> Zpos (XO XH)
| Mint16unsigned -> Zpos (XO XH)
| Mint32 -> Zpos (XO (XO XH))
| Mfloat32 -> Zpos (XO (XO XH))
| Many32 -> Zpos (XO (XO XH))
| _ -> Zpos (XO (XO (XO XH)))

(** val size_chunk_nat : memory_chunk -> nat **)

let size_chunk_nat chunk =
  nat_of_Z (size_chunk chunk)

(** val align_chunk : memory_chunk -> z **)

let align_chunk = function
| Mint8signed -> Zpos XH
| Mint8unsigned -> Zpos XH
| Mint16signed -> Zpos (XO XH)
| Mint16unsigned -> Zpos (XO XH)
| Mint64 -> Zpos (XO (XO (XO XH)))
| _ -> Zpos (XO (XO XH))

type quantity =
| Q32
| Q64

(** val quantity_eq : quantity -> quantity -> sumbool **)

let quantity_eq q1 q2 =
  match q1 with
  | Q32 ->
    (match q2 with
     | Q32 -> Left
     | Q64 -> Right)
  | Q64 ->
    (match q2 with
     | Q32 -> Right
     | Q64 -> Left)

(** val size_quantity_nat : quantity -> nat **)

let size_quantity_nat = function
| Q32 -> S (S (S (S O)))
| Q64 -> S (S (S (S (S (S (S (S O)))))))

type memval =
| Undef
| Byte of Byte.int
| Fragment of val0 * quantity * nat

(** val bytes_of_int : nat -> z -> Byte.int list **)

let rec bytes_of_int n0 x =
  match n0 with
  | O -> Nil
  | S m0 ->
    Cons ((Byte.repr x),
      (bytes_of_int m0
        (Z.div x (Zpos (XO (XO (XO (XO (XO (XO (XO (XO XH))))))))))))

(** val int_of_bytes : Byte.int list -> z **)

let rec int_of_bytes = function
| Nil -> Z0
| Cons (b, l') ->
  Z.add (Byte.unsigned b)
    (Z.mul (int_of_bytes l') (Zpos (XO (XO (XO (XO (XO (XO (XO (XO
      XH))))))))))

(** val rev_if_be : Byte.int list -> Byte.int list **)

let rev_if_be l =
  match big_endian with
  | True -> rev l
  | False -> l

(** val encode_int : nat -> z -> Byte.int list **)

let encode_int sz x =
  rev_if_be (bytes_of_int sz x)

(** val decode_int : Byte.int list -> z **)

let decode_int b =
  int_of_bytes (rev_if_be b)

(** val inj_bytes : Byte.int list -> memval list **)

let inj_bytes bl =
  map (fun x -> Byte x) bl

(** val proj_bytes : memval list -> Byte.int list option **)

let rec proj_bytes = function
| Nil -> Some Nil
| Cons (m0, vl') ->
  (match m0 with
   | Byte b ->
     (match proj_bytes vl' with
      | Some bl -> Some (Cons (b, bl))
      | None -> None)
   | _ -> None)

(** val inj_value_rec : nat -> val0 -> quantity -> memval list **)

let rec inj_value_rec n0 v q =
  match n0 with
  | O -> Nil
  | S m0 -> Cons ((Fragment (v, q, m0)), (inj_value_rec m0 v q))

(** val inj_value : quantity -> val0 -> memval list **)

let inj_value q v =
  inj_value_rec (size_quantity_nat q) v q

(** val check_value : nat -> val0 -> quantity -> memval list -> bool **)

let rec check_value n0 v q vl =
  match n0 with
  | O ->
    (match vl with
     | Nil -> True
     | Cons (m0, l) -> False)
  | S m0 ->
    (match vl with
     | Nil -> False
     | Cons (m1, vl') ->
       (match m1 with
        | Fragment (v', q', m') ->
          (match match match proj_sumbool (Val.eq v v') with
                       | True -> proj_sumbool (quantity_eq q q')
                       | False -> False with
                 | True -> beq_nat m0 m'
                 | False -> False with
           | True -> check_value m0 v q vl'
           | False -> False)
        | _ -> False))

(** val proj_value : quantity -> memval list -> val0 **)

let proj_value q vl = match vl with
| Nil -> Vundef
| Cons (m0, vl') ->
  (match m0 with
   | Fragment (v, q', n0) ->
     (match check_value (size_quantity_nat q) v q vl with
      | True -> v
      | False -> Vundef)
   | _ -> Vundef)

(** val encode_val : memory_chunk -> val0 -> memval list **)

let encode_val chunk v = match v with
| Vundef ->
  (match chunk with
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)
| Vint n0 ->
  (match chunk with
   | Mint8signed -> inj_bytes (encode_int (S O) (Int.unsigned n0))
   | Mint8unsigned -> inj_bytes (encode_int (S O) (Int.unsigned n0))
   | Mint16signed -> inj_bytes (encode_int (S (S O)) (Int.unsigned n0))
   | Mint16unsigned -> inj_bytes (encode_int (S (S O)) (Int.unsigned n0))
   | Mint32 -> inj_bytes (encode_int (S (S (S (S O)))) (Int.unsigned n0))
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)
| Vlong n0 ->
  (match chunk with
   | Mint64 ->
     inj_bytes
       (encode_int (S (S (S (S (S (S (S (S O)))))))) (Int64.unsigned n0))
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)
| Vfloat n0 ->
  (match chunk with
   | Mfloat64 ->
     inj_bytes
       (encode_int (S (S (S (S (S (S (S (S O))))))))
         (Int64.unsigned (Float.to_bits n0)))
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)
| Vsingle n0 ->
  (match chunk with
   | Mfloat32 ->
     inj_bytes
       (encode_int (S (S (S (S O)))) (Int.unsigned (Float32.to_bits n0)))
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)
| Vptr (b, ofs) ->
  (match chunk with
   | Mint32 -> inj_value Q32 v
   | Many32 -> inj_value Q32 v
   | Many64 -> inj_value Q64 v
   | _ -> list_repeat (size_chunk_nat chunk) Undef)

(** val decode_val : memory_chunk -> memval list -> val0 **)

let decode_val chunk vl =
  match proj_bytes vl with
  | Some bl ->
    (match chunk with
     | Mint8signed ->
       Vint
         (Int.sign_ext (Zpos (XO (XO (XO XH)))) (Int.repr (decode_int bl)))
     | Mint8unsigned ->
       Vint
         (Int.zero_ext (Zpos (XO (XO (XO XH)))) (Int.repr (decode_int bl)))
     | Mint16signed ->
       Vint
         (Int.sign_ext (Zpos (XO (XO (XO (XO XH)))))
           (Int.repr (decode_int bl)))
     | Mint16unsigned ->
       Vint
         (Int.zero_ext (Zpos (XO (XO (XO (XO XH)))))
           (Int.repr (decode_int bl)))
     | Mint32 -> Vint (Int.repr (decode_int bl))
     | Mint64 -> Vlong (Int64.repr (decode_int bl))
     | Mfloat32 -> Vsingle (Float32.of_bits (Int.repr (decode_int bl)))
     | Mfloat64 -> Vfloat (Float.of_bits (Int64.repr (decode_int bl)))
     | _ -> Vundef)
  | None ->
    (match chunk with
     | Mint32 -> Val.load_result chunk (proj_value Q32 vl)
     | Many32 -> Val.load_result chunk (proj_value Q32 vl)
     | Many64 -> Val.load_result chunk (proj_value Q64 vl)
     | _ -> Vundef)

type permission =
| Freeable
| Writable
| Readable
| Nonempty

type perm_kind =
| Max
| Cur

module Mem = 
 struct 
  type mem' = { mem_contents : memval ZMap.t PMap.t;
                mem_access : (z -> perm_kind -> permission option) PMap.t;
                nextblock : block }
  
  (** val mem_contents : mem' -> memval ZMap.t PMap.t **)
  
  let mem_contents x = x.mem_contents
  
  (** val mem_access :
      mem' -> (z -> perm_kind -> permission option) PMap.t **)
  
  let mem_access x = x.mem_access
  
  (** val nextblock : mem' -> block **)
  
  let nextblock x = x.nextblock
  
  type mem = mem'
  
  (** val perm_order_dec : permission -> permission -> sumbool **)
  
  let perm_order_dec p1 p2 =
    match p1 with
    | Freeable -> Left
    | Writable ->
      (match p2 with
       | Freeable -> Right
       | _ -> Left)
    | Readable ->
      (match p2 with
       | Freeable -> Right
       | Writable -> Right
       | _ -> Left)
    | Nonempty ->
      (match p2 with
       | Nonempty -> Left
       | _ -> Right)
  
  (** val perm_order'_dec : permission option -> permission -> sumbool **)
  
  let perm_order'_dec op p =
    match op with
    | Some p0 -> perm_order_dec p0 p
    | None -> Right
  
  (** val perm_dec :
      mem -> block -> z -> perm_kind -> permission -> sumbool **)
  
  let perm_dec m0 b ofs k p =
    perm_order'_dec (PMap.get b m0.mem_access ofs k) p
  
  (** val range_perm_dec :
      mem -> block -> z -> z -> perm_kind -> permission -> sumbool **)
  
  let rec range_perm_dec m0 b lo hi k p =
    let s = zlt lo hi in
    (match s with
     | Left ->
       let s0 = perm_dec m0 b lo k p in
       (match s0 with
        | Left -> let y = Z.add lo (Zpos XH) in range_perm_dec m0 b y hi k p
        | Right -> Right)
     | Right -> Left)
  
  (** val valid_access_dec :
      mem -> memory_chunk -> block -> z -> permission -> sumbool **)
  
  let valid_access_dec m0 chunk b ofs p =
    let s = range_perm_dec m0 b ofs (Z.add ofs (size_chunk chunk)) Cur p in
    (match s with
     | Left -> zdivide_dec (align_chunk chunk) ofs
     | Right -> Right)
  
  (** val valid_pointer : mem -> block -> z -> bool **)
  
  let valid_pointer m0 b ofs =
    proj_sumbool (perm_dec m0 b ofs Cur Nonempty)
  
  (** val weak_valid_pointer : mem -> block -> z -> bool **)
  
  let weak_valid_pointer m0 b ofs =
    match valid_pointer m0 b ofs with
    | True -> True
    | False -> valid_pointer m0 b (Z.sub ofs (Zpos XH))
  
  (** val empty : mem **)
  
  let empty =
    { mem_contents = (PMap.init (ZMap.init Undef)); mem_access =
      (PMap.init (fun ofs k -> None)); nextblock = XH }
  
  (** val alloc : mem -> z -> z -> (mem', block) prod **)
  
  let alloc m0 lo hi =
    Pair ({ mem_contents =
      (PMap.set m0.nextblock (ZMap.init Undef) m0.mem_contents); mem_access =
      (PMap.set m0.nextblock (fun ofs k ->
        match match proj_sumbool (zle lo ofs) with
              | True -> proj_sumbool (zlt ofs hi)
              | False -> False with
        | True -> Some Freeable
        | False -> None) m0.mem_access); nextblock =
      (Coq_Pos.succ m0.nextblock) }, m0.nextblock)
  
  (** val unchecked_free : mem -> block -> z -> z -> mem **)
  
  let unchecked_free m0 b lo hi =
    { mem_contents = m0.mem_contents; mem_access =
      (PMap.set b (fun ofs k ->
        match match proj_sumbool (zle lo ofs) with
              | True -> proj_sumbool (zlt ofs hi)
              | False -> False with
        | True -> None
        | False -> PMap.get b m0.mem_access ofs k) m0.mem_access);
      nextblock = m0.nextblock }
  
  (** val free : mem -> block -> z -> z -> mem option **)
  
  let free m0 b lo hi =
    match range_perm_dec m0 b lo hi Cur Freeable with
    | Left -> Some (unchecked_free m0 b lo hi)
    | Right -> None
  
  (** val free_list : mem -> ((block, z) prod, z) prod list -> mem option **)
  
  let rec free_list m0 = function
  | Nil -> Some m0
  | Cons (p, l') ->
    let Pair (p0, hi) = p in
    let Pair (b, lo) = p0 in
    (match free m0 b lo hi with
     | Some m' -> free_list m' l'
     | None -> None)
  
  (** val getN : nat -> z -> memval ZMap.t -> memval list **)
  
  let rec getN n0 p c =
    match n0 with
    | O -> Nil
    | S n' -> Cons ((ZMap.get p c), (getN n' (Z.add p (Zpos XH)) c))
  
  (** val load : memory_chunk -> mem -> block -> z -> val0 option **)
  
  let load chunk m0 b ofs =
    match valid_access_dec m0 chunk b ofs Readable with
    | Left ->
      Some
        (decode_val chunk
          (getN (size_chunk_nat chunk) ofs (PMap.get b m0.mem_contents)))
    | Right -> None
  
  (** val loadv : memory_chunk -> mem -> val0 -> val0 option **)
  
  let loadv chunk m0 = function
  | Vptr (b, ofs) -> load chunk m0 b (Int.unsigned ofs)
  | _ -> None
  
  (** val loadbytes : mem -> block -> z -> z -> memval list option **)
  
  let loadbytes m0 b ofs n0 =
    match range_perm_dec m0 b ofs (Z.add ofs n0) Cur Readable with
    | Left -> Some (getN (nat_of_Z n0) ofs (PMap.get b m0.mem_contents))
    | Right -> None
  
  (** val setN : memval list -> z -> memval ZMap.t -> memval ZMap.t **)
  
  let rec setN vl p c =
    match vl with
    | Nil -> c
    | Cons (v, vl') -> setN vl' (Z.add p (Zpos XH)) (ZMap.set p v c)
  
  (** val store : memory_chunk -> mem -> block -> z -> val0 -> mem option **)
  
  let store chunk m0 b ofs v =
    match valid_access_dec m0 chunk b ofs Writable with
    | Left ->
      Some { mem_contents =
        (PMap.set b
          (setN (encode_val chunk v) ofs (PMap.get b m0.mem_contents))
          m0.mem_contents); mem_access = m0.mem_access; nextblock =
        m0.nextblock }
    | Right -> None
  
  (** val storev : memory_chunk -> mem -> val0 -> val0 -> mem option **)
  
  let storev chunk m0 addr v =
    match addr with
    | Vptr (b, ofs) -> store chunk m0 b (Int.unsigned ofs) v
    | _ -> None
  
  (** val storebytes : mem -> block -> z -> memval list -> mem option **)
  
  let storebytes m0 b ofs bytes =
    match range_perm_dec m0 b ofs (Z.add ofs (Z.of_nat (length bytes))) Cur
            Writable with
    | Left ->
      Some { mem_contents =
        (PMap.set b (setN bytes ofs (PMap.get b m0.mem_contents))
          m0.mem_contents); mem_access = m0.mem_access; nextblock =
        m0.nextblock }
    | Right -> None
  
  (** val drop_perm : mem -> block -> z -> z -> permission -> mem option **)
  
  let drop_perm m0 b lo hi p =
    match range_perm_dec m0 b lo hi Cur Freeable with
    | Left ->
      Some { mem_contents = m0.mem_contents; mem_access =
        (PMap.set b (fun ofs k ->
          match match proj_sumbool (zle lo ofs) with
                | True -> proj_sumbool (zlt ofs hi)
                | False -> False with
          | True -> Some p
          | False -> PMap.get b m0.mem_access ofs k) m0.mem_access);
        nextblock = m0.nextblock }
    | Right -> None
  
  (** val valid_access_store :
      mem -> memory_chunk -> block -> z -> val0 -> mem **)
  
  let valid_access_store m1 chunk b ofs v =
    let s = valid_access_dec m1 chunk b ofs Writable in
    (match s with
     | Left ->
       { mem_contents =
         (PMap.set b
           (setN (encode_val chunk v) ofs (PMap.get b m1.mem_contents))
           m1.mem_contents); mem_access = m1.mem_access; nextblock =
         m1.nextblock }
     | Right -> assert false (* absurd case *))
  
  (** val range_perm_storebytes : mem -> block -> z -> memval list -> mem **)
  
  let range_perm_storebytes m1 b ofs bytes =
    let s =
      range_perm_dec m1 b ofs (Z.add ofs (Z.of_nat (length bytes))) Cur
        Writable
    in
    (match s with
     | Left ->
       { mem_contents =
         (PMap.set b (setN bytes ofs (PMap.get b m1.mem_contents))
           m1.mem_contents); mem_access = m1.mem_access; nextblock =
         m1.nextblock }
     | Right -> assert false (* absurd case *))
  
  (** val range_perm_free : mem -> block -> z -> z -> mem **)
  
  let range_perm_free m1 b lo hi =
    unchecked_free m1 b lo hi
  
  (** val range_perm_drop_2 : mem -> block -> z -> z -> permission -> mem **)
  
  let range_perm_drop_2 m0 b lo hi p =
    let s = range_perm_dec m0 b lo hi Cur Freeable in
    (match s with
     | Left ->
       { mem_contents = m0.mem_contents; mem_access =
         (PMap.set b (fun ofs k ->
           match match proj_sumbool (zle lo ofs) with
                 | True -> proj_sumbool (zlt ofs hi)
                 | False -> False with
           | True -> Some p
           | False -> PMap.get b m0.mem_access ofs k) m0.mem_access);
         nextblock = m0.nextblock }
     | Right -> assert false (* absurd case *))
  
  (** val flat_inj : block -> Val.meminj **)
  
  let flat_inj thr b =
    match plt b thr with
    | Left -> Some (Pair (b, Z0))
    | Right -> None
 end

(** val store_zeros : Mem.mem -> block -> z -> z -> Mem.mem option **)

let rec store_zeros m0 b p n0 =
  match zle n0 Z0 with
  | Left -> Some m0
  | Right ->
    (match Mem.store Mint8unsigned m0 b p vzero with
     | Some m' -> store_zeros m' b (Z.add p (Zpos XH)) (Z.sub n0 (Zpos XH))
     | None -> None)

module Senv = 
 struct 
  type t = { find_symbol : (ident -> block option);
             public_symbol : (ident -> bool);
             invert_symbol : (block -> ident option);
             block_is_volatile : (block -> bool); nextblock : block }
  
  (** val find_symbol : t -> ident -> block option **)
  
  let find_symbol x = x.find_symbol
  
  (** val public_symbol : t -> ident -> bool **)
  
  let public_symbol x = x.public_symbol
  
  (** val invert_symbol : t -> block -> ident option **)
  
  let invert_symbol x = x.invert_symbol
  
  (** val block_is_volatile : t -> block -> bool **)
  
  let block_is_volatile x = x.block_is_volatile
  
  (** val nextblock : t -> block **)
  
  let nextblock x = x.nextblock
  
  (** val symbol_address : t -> ident -> Int.int -> val0 **)
  
  let symbol_address ge id ofs =
    match ge.find_symbol id with
    | Some b -> Vptr (b, ofs)
    | None -> Vundef
 end

module Genv = 
 struct 
  type ('f, 'v) t = { genv_public : ident list; genv_symb : block PTree.t;
                      genv_funs : 'f PTree.t; genv_vars : 'v globvar PTree.t;
                      genv_next : block }
  
  (** val genv_public : ('a1, 'a2) t -> ident list **)
  
  let genv_public x = x.genv_public
  
  (** val genv_symb : ('a1, 'a2) t -> block PTree.t **)
  
  let genv_symb x = x.genv_symb
  
  (** val genv_funs : ('a1, 'a2) t -> 'a1 PTree.t **)
  
  let genv_funs x = x.genv_funs
  
  (** val genv_vars : ('a1, 'a2) t -> 'a2 globvar PTree.t **)
  
  let genv_vars x = x.genv_vars
  
  (** val genv_next : ('a1, 'a2) t -> block **)
  
  let genv_next x = x.genv_next
  
  (** val find_symbol : ('a1, 'a2) t -> ident -> block option **)
  
  let find_symbol ge id =
    PTree.get id ge.genv_symb
  
  (** val symbol_address : ('a1, 'a2) t -> ident -> Int.int -> val0 **)
  
  let symbol_address ge id ofs =
    match find_symbol ge id with
    | Some b -> Vptr (b, ofs)
    | None -> Vundef
  
  (** val public_symbol : ('a1, 'a2) t -> ident -> bool **)
  
  let public_symbol ge id =
    match find_symbol ge id with
    | Some b -> proj_sumbool (in_dec ident_eq id ge.genv_public)
    | None -> False
  
  (** val find_funct_ptr : ('a1, 'a2) t -> block -> 'a1 option **)
  
  let find_funct_ptr ge b =
    PTree.get b ge.genv_funs
  
  (** val find_funct : ('a1, 'a2) t -> val0 -> 'a1 option **)
  
  let find_funct ge = function
  | Vptr (b, ofs) ->
    (match Int.eq_dec ofs Int.zero with
     | Left -> find_funct_ptr ge b
     | Right -> None)
  | _ -> None
  
  (** val invert_symbol : ('a1, 'a2) t -> block -> ident option **)
  
  let invert_symbol ge b =
    PTree.fold (fun res2 id b' ->
      match eq_block b b' with
      | Left -> Some id
      | Right -> res2) ge.genv_symb None
  
  (** val find_var_info : ('a1, 'a2) t -> block -> 'a2 globvar option **)
  
  let find_var_info ge b =
    PTree.get b ge.genv_vars
  
  (** val block_is_volatile : ('a1, 'a2) t -> block -> bool **)
  
  let block_is_volatile ge b =
    match find_var_info ge b with
    | Some gv -> gv.gvar_volatile
    | None -> False
  
  (** val add_global :
      ('a1, 'a2) t -> (ident, ('a1, 'a2) globdef) prod -> ('a1, 'a2) t **)
  
  let add_global ge idg =
    { genv_public = ge.genv_public; genv_symb =
      (PTree.set (fst idg) ge.genv_next ge.genv_symb); genv_funs =
      (let filtered_var = snd idg in
       match filtered_var with
       | Gfun f -> PTree.set ge.genv_next f ge.genv_funs
       | Gvar v -> ge.genv_funs); genv_vars =
      (let filtered_var = snd idg in
       match filtered_var with
       | Gfun f -> ge.genv_vars
       | Gvar v -> PTree.set ge.genv_next v ge.genv_vars); genv_next =
      (Coq_Pos.succ ge.genv_next) }
  
  (** val add_globals :
      ('a1, 'a2) t -> (ident, ('a1, 'a2) globdef) prod list -> ('a1, 'a2) t **)
  
  let add_globals ge gl =
    fold_left add_global gl ge
  
  (** val empty_genv : ident list -> ('a1, 'a2) t **)
  
  let empty_genv pub =
    { genv_public = pub; genv_symb = PTree.empty; genv_funs = PTree.empty;
      genv_vars = PTree.empty; genv_next = XH }
  
  (** val globalenv : ('a1, 'a2) program -> ('a1, 'a2) t **)
  
  let globalenv p =
    add_globals (empty_genv p.prog_public) p.prog_defs
  
  (** val advance_next :
      (ident, ('a1, 'a2) globdef) prod list -> positive -> positive **)
  
  let advance_next gl x =
    fold_left (fun n0 g -> Coq_Pos.succ n0) gl x
  
  (** val to_senv : ('a1, 'a2) t -> Senv.t **)
  
  let to_senv ge =
    { Senv.find_symbol = (find_symbol ge); Senv.public_symbol =
      (public_symbol ge); Senv.invert_symbol = (invert_symbol ge);
      Senv.block_is_volatile = (block_is_volatile ge); Senv.nextblock =
      ge.genv_next }
  
  (** val init_data_size : init_data -> z **)
  
  let init_data_size = function
  | Init_int8 i0 -> Zpos XH
  | Init_int16 i0 -> Zpos (XO XH)
  | Init_int64 i0 -> Zpos (XO (XO (XO XH)))
  | Init_float64 f -> Zpos (XO (XO (XO XH)))
  | Init_space n0 -> Z.max n0 Z0
  | _ -> Zpos (XO (XO XH))
  
  (** val store_init_data :
      ('a1, 'a2) t -> Mem.mem -> block -> z -> init_data -> Mem.mem option **)
  
  let store_init_data ge m0 b p = function
  | Init_int8 n0 -> Mem.store Mint8unsigned m0 b p (Vint n0)
  | Init_int16 n0 -> Mem.store Mint16unsigned m0 b p (Vint n0)
  | Init_int32 n0 -> Mem.store Mint32 m0 b p (Vint n0)
  | Init_int64 n0 -> Mem.store Mint64 m0 b p (Vlong n0)
  | Init_float32 n0 -> Mem.store Mfloat32 m0 b p (Vsingle n0)
  | Init_float64 n0 -> Mem.store Mfloat64 m0 b p (Vfloat n0)
  | Init_space n0 -> Some m0
  | Init_addrof (symb, ofs) ->
    (match find_symbol ge symb with
     | Some b' -> Mem.store Mint32 m0 b p (Vptr (b', ofs))
     | None -> None)
  
  (** val store_init_data_list :
      ('a1, 'a2) t -> Mem.mem -> block -> z -> init_data list -> Mem.mem
      option **)
  
  let rec store_init_data_list ge m0 b p = function
  | Nil -> Some m0
  | Cons (id, idl') ->
    (match store_init_data ge m0 b p id with
     | Some m' ->
       store_init_data_list ge m' b (Z.add p (init_data_size id)) idl'
     | None -> None)
  
  (** val init_data_list_size : init_data list -> z **)
  
  let rec init_data_list_size = function
  | Nil -> Z0
  | Cons (i, il') -> Z.add (init_data_size i) (init_data_list_size il')
  
  (** val perm_globvar : 'a1 globvar -> permission **)
  
  let perm_globvar gv =
    match gv.gvar_volatile with
    | True -> Nonempty
    | False ->
      (match gv.gvar_readonly with
       | True -> Readable
       | False -> Writable)
  
  (** val alloc_global :
      ('a1, 'a2) t -> Mem.mem -> (ident, ('a1, 'a2) globdef) prod -> Mem.mem
      option **)
  
  let alloc_global ge m0 = function
  | Pair (id, g) ->
    (match g with
     | Gfun f ->
       let Pair (m1, b) = Mem.alloc m0 Z0 (Zpos XH) in
       Mem.drop_perm m1 b Z0 (Zpos XH) Nonempty
     | Gvar v ->
       let init0 = v.gvar_init in
       let sz = init_data_list_size init0 in
       let Pair (m1, b) = Mem.alloc m0 Z0 sz in
       (match store_zeros m1 b Z0 sz with
        | Some m2 ->
          (match store_init_data_list ge m2 b Z0 init0 with
           | Some m3 -> Mem.drop_perm m3 b Z0 sz (perm_globvar v)
           | None -> None)
        | None -> None))
  
  (** val alloc_globals :
      ('a1, 'a2) t -> Mem.mem -> (ident, ('a1, 'a2) globdef) prod list ->
      Mem.mem option **)
  
  let rec alloc_globals ge m0 = function
  | Nil -> Some m0
  | Cons (g, gl') ->
    (match alloc_global ge m0 g with
     | Some m' -> alloc_globals ge m' gl'
     | None -> None)
  
  (** val init_mem : ('a1, 'a2) program -> Mem.mem option **)
  
  let init_mem p =
    alloc_globals (globalenv p) Mem.empty p.prog_defs
 end

type signedness =
| Signed
| Unsigned

type intsize =
| I8
| I16
| I32
| IBool

type floatsize =
| F32
| F64

type attr = { attr_volatile : bool; attr_alignas : n option }

(** val attr_alignas : attr -> n option **)

let attr_alignas x = x.attr_alignas

(** val noattr : attr **)

let noattr =
  { attr_volatile = False; attr_alignas = None }

type type0 =
| Tvoid
| Tint0 of intsize * signedness * attr
| Tlong0 of signedness * attr
| Tfloat0 of floatsize * attr
| Tpointer of type0 * attr
| Tarray of type0 * z * attr
| Tfunction of typelist * type0 * calling_convention
| Tstruct of ident * attr
| Tunion of ident * attr
and typelist =
| Tnil
| Tcons of type0 * typelist

(** val attr_of_type : type0 -> attr **)

let attr_of_type = function
| Tint0 (sz, si, a) -> a
| Tlong0 (si, a) -> a
| Tfloat0 (sz, a) -> a
| Tpointer (elt0, a) -> a
| Tarray (elt0, sz, a) -> a
| Tstruct (id, a) -> a
| Tunion (id, a) -> a
| _ -> noattr

(** val change_attributes : (attr -> attr) -> type0 -> type0 **)

let change_attributes f ty = match ty with
| Tint0 (sz, si, a) -> Tint0 (sz, si, (f a))
| Tlong0 (si, a) -> Tlong0 (si, (f a))
| Tfloat0 (sz, a) -> Tfloat0 (sz, (f a))
| Tpointer (elt0, a) -> Tpointer (elt0, (f a))
| Tarray (elt0, sz, a) -> Tarray (elt0, sz, (f a))
| Tstruct (id, a) -> Tstruct (id, (f a))
| Tunion (id, a) -> Tunion (id, (f a))
| _ -> ty

(** val remove_attributes : type0 -> type0 **)

let remove_attributes ty =
  change_attributes (fun x -> noattr) ty

type struct_or_union =
| Struct
| Union

type members = (ident, type0) prod list

type composite_definition =
| Composite of ident * struct_or_union * members * attr

type composite = { co_su : struct_or_union; co_members : members;
                   co_attr : attr; co_sizeof : z; co_alignof : z;
                   co_rank : nat }

(** val co_members : composite -> members **)

let co_members x = x.co_members

(** val co_sizeof : composite -> z **)

let co_sizeof x = x.co_sizeof

(** val co_alignof : composite -> z **)

let co_alignof x = x.co_alignof

type composite_env = composite PTree.t

(** val typeconv : type0 -> type0 **)

let typeconv ty = match ty with
| Tint0 (i, s, a) ->
  (match i with
   | I32 -> remove_attributes ty
   | _ -> Tint0 (I32, Signed, noattr))
| Tarray (t1, sz, a) -> Tpointer (t1, noattr)
| Tfunction (t1, t2, c) -> Tpointer (ty, noattr)
| _ -> remove_attributes ty

(** val default_argument_conversion : type0 -> type0 **)

let default_argument_conversion ty = match ty with
| Tint0 (i, s, a) ->
  (match i with
   | I32 -> remove_attributes ty
   | _ -> Tint0 (I32, Signed, noattr))
| Tfloat0 (f, a) -> Tfloat0 (F64, noattr)
| Tarray (t1, sz, a) -> Tpointer (t1, noattr)
| Tfunction (t1, t2, c) -> Tpointer (ty, noattr)
| _ -> remove_attributes ty

(** val align_attr : attr -> z -> z **)

let align_attr a al =
  match a.attr_alignas with
  | Some l -> two_p (Z.of_N l)
  | None -> al

(** val alignof : composite_env -> type0 -> z **)

let rec alignof env t1 =
  align_attr (attr_of_type t1)
    (match t1 with
     | Tvoid -> Zpos XH
     | Tint0 (i, s, a) ->
       (match i with
        | I16 -> Zpos (XO XH)
        | I32 -> Zpos (XO (XO XH))
        | _ -> Zpos XH)
     | Tarray (t'0, z0, a) -> alignof env t'0
     | Tfunction (t2, t3, c) -> Zpos XH
     | Tstruct (id, a) ->
       (match PTree.get id env with
        | Some co -> co.co_alignof
        | None -> Zpos XH)
     | Tunion (id, a) ->
       (match PTree.get id env with
        | Some co -> co.co_alignof
        | None -> Zpos XH)
     | _ -> Zpos (XO (XO XH)))

(** val sizeof : composite_env -> type0 -> z **)

let rec sizeof env = function
| Tint0 (i, s, a) ->
  (match i with
   | I16 -> Zpos (XO XH)
   | I32 -> Zpos (XO (XO XH))
   | _ -> Zpos XH)
| Tlong0 (s, a) -> Zpos (XO (XO (XO XH)))
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> Zpos (XO (XO XH))
   | F64 -> Zpos (XO (XO (XO XH))))
| Tpointer (t2, a) -> Zpos (XO (XO XH))
| Tarray (t'0, n0, a) -> Z.mul (sizeof env t'0) (Z.max Z0 n0)
| Tstruct (id, a) ->
  (match PTree.get id env with
   | Some co -> co.co_sizeof
   | None -> Z0)
| Tunion (id, a) ->
  (match PTree.get id env with
   | Some co -> co.co_sizeof
   | None -> Z0)
| _ -> Zpos XH

(** val field_offset_rec :
    composite_env -> ident -> members -> z -> z res **)

let rec field_offset_rec env id fld pos =
  match fld with
  | Nil ->
    Error (Cons ((MSG (String ((Ascii (True, False, True, False, True, False,
      True, False)), (String ((Ascii (False, True, True, True, False, True,
      True, False)), (String ((Ascii (True, True, False, True, False, True,
      True, False)), (String ((Ascii (False, True, True, True, False, True,
      True, False)), (String ((Ascii (True, True, True, True, False, True,
      True, False)), (String ((Ascii (True, True, True, False, True, True,
      True, False)), (String ((Ascii (False, True, True, True, False, True,
      True, False)), (String ((Ascii (False, False, False, False, False,
      True, False, False)), (String ((Ascii (False, True, True, False, False,
      True, True, False)), (String ((Ascii (True, False, False, True, False,
      True, True, False)), (String ((Ascii (True, False, True, False, False,
      True, True, False)), (String ((Ascii (False, False, True, True, False,
      True, True, False)), (String ((Ascii (False, False, True, False, False,
      True, True, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), EmptyString))))))))))))))))))))))))))))),
      (Cons ((CTX id), Nil))))
  | Cons (p, fld') ->
    let Pair (id', t1) = p in
    (match ident_eq id id' with
     | Left -> OK (align pos (alignof env t1))
     | Right ->
       field_offset_rec env id fld'
         (Z.add (align pos (alignof env t1)) (sizeof env t1)))

(** val field_offset : composite_env -> ident -> members -> z res **)

let field_offset env id fld =
  field_offset_rec env id fld Z0

type mode0 =
| By_value of memory_chunk
| By_reference
| By_copy
| By_nothing

(** val access_mode : type0 -> mode0 **)

let access_mode = function
| Tvoid -> By_nothing
| Tint0 (i, s, a) ->
  (match i with
   | I8 ->
     (match s with
      | Signed -> By_value Mint8signed
      | Unsigned -> By_value Mint8unsigned)
   | I16 ->
     (match s with
      | Signed -> By_value Mint16signed
      | Unsigned -> By_value Mint16unsigned)
   | I32 -> By_value Mint32
   | IBool -> By_value Mint8unsigned)
| Tlong0 (s, a) -> By_value Mint64
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> By_value Mfloat32
   | F64 -> By_value Mfloat64)
| Tpointer (t1, a) -> By_value Mint32
| Tarray (t1, z0, a) -> By_reference
| Tfunction (t1, t2, c) -> By_reference
| _ -> By_copy

(** val alignof_blockcopy : composite_env -> type0 -> z **)

let rec alignof_blockcopy env = function
| Tint0 (i, s, a) ->
  (match i with
   | I16 -> Zpos (XO XH)
   | I32 -> Zpos (XO (XO XH))
   | _ -> Zpos XH)
| Tlong0 (s, a) -> Zpos (XO (XO (XO XH)))
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> Zpos (XO (XO XH))
   | F64 -> Zpos (XO (XO (XO XH))))
| Tpointer (t2, a) -> Zpos (XO (XO XH))
| Tarray (t'0, z0, a) -> alignof_blockcopy env t'0
| Tstruct (id, a) ->
  (match PTree.get id env with
   | Some co -> Z.min (Zpos (XO (XO (XO XH)))) co.co_alignof
   | None -> Zpos XH)
| Tunion (id, a) ->
  (match PTree.get id env with
   | Some co -> Z.min (Zpos (XO (XO (XO XH)))) co.co_alignof
   | None -> Zpos XH)
| _ -> Zpos XH

(** val typ_of_type : type0 -> typ **)

let typ_of_type = function
| Tlong0 (s, a) -> Tlong
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> Tsingle
   | F64 -> Tfloat)
| _ -> Tint

(** val opttyp_of_type : type0 -> typ option **)

let opttyp_of_type = function
| Tvoid -> None
| Tlong0 (s, a) -> Some Tlong
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> Some Tsingle
   | F64 -> Some Tfloat)
| _ -> Some Tint

(** val typlist_of_typelist : typelist -> typ list **)

let rec typlist_of_typelist = function
| Tnil -> Nil
| Tcons (hd0, tl1) -> Cons ((typ_of_type hd0), (typlist_of_typelist tl1))

(** val signature_of_type :
    typelist -> type0 -> calling_convention -> signature **)

let signature_of_type args res2 cc =
  { sig_args = (typlist_of_typelist args); sig_res = (opttyp_of_type res2);
    sig_cc = cc }

type unary_operation =
| Onotbool
| Onotint
| Oneg
| Oabsfloat

type binary_operation =
| Oadd
| Osub
| Omul
| Odiv
| Omod
| Oand
| Oor
| Oxor
| Oshl
| Oshr
| Oeq
| One
| Olt
| Ogt
| Ole
| Oge

type classify_cast_cases =
| Cast_case_neutral
| Cast_case_i2i of intsize * signedness
| Cast_case_f2f
| Cast_case_s2s
| Cast_case_f2s
| Cast_case_s2f
| Cast_case_i2f of signedness
| Cast_case_i2s of signedness
| Cast_case_f2i of intsize * signedness
| Cast_case_s2i of intsize * signedness
| Cast_case_l2l
| Cast_case_i2l of signedness
| Cast_case_l2i of intsize * signedness
| Cast_case_l2f of signedness
| Cast_case_l2s of signedness
| Cast_case_f2l of signedness
| Cast_case_s2l of signedness
| Cast_case_f2bool
| Cast_case_s2bool
| Cast_case_l2bool
| Cast_case_p2bool
| Cast_case_struct of ident * ident
| Cast_case_union of ident * ident
| Cast_case_void
| Cast_case_default

(** val classify_cast : type0 -> type0 -> classify_cast_cases **)

let classify_cast tfrom = function
| Tvoid -> Cast_case_void
| Tint0 (sz2, si2, a) ->
  (match sz2 with
   | I32 ->
     (match tfrom with
      | Tvoid -> Cast_case_default
      | Tlong0 (s, a0) -> Cast_case_l2i (sz2, si2)
      | Tfloat0 (f, a0) ->
        (match f with
         | F32 -> Cast_case_s2i (sz2, si2)
         | F64 -> Cast_case_f2i (sz2, si2))
      | Tstruct (i, a0) -> Cast_case_default
      | Tunion (i, a0) -> Cast_case_default
      | _ -> Cast_case_neutral)
   | IBool ->
     (match tfrom with
      | Tvoid -> Cast_case_default
      | Tint0 (sz1, si1, a0) -> Cast_case_i2i (sz2, si2)
      | Tlong0 (s, a0) -> Cast_case_l2bool
      | Tfloat0 (f, a0) ->
        (match f with
         | F32 -> Cast_case_s2bool
         | F64 -> Cast_case_f2bool)
      | Tstruct (i, a0) -> Cast_case_default
      | Tunion (i, a0) -> Cast_case_default
      | _ -> Cast_case_p2bool)
   | _ ->
     (match tfrom with
      | Tint0 (sz1, si1, a0) -> Cast_case_i2i (sz2, si2)
      | Tlong0 (s, a0) -> Cast_case_l2i (sz2, si2)
      | Tfloat0 (f, a0) ->
        (match f with
         | F32 -> Cast_case_s2i (sz2, si2)
         | F64 -> Cast_case_f2i (sz2, si2))
      | _ -> Cast_case_default))
| Tlong0 (si2, a) ->
  (match tfrom with
   | Tint0 (sz1, si1, a0) -> Cast_case_i2l si1
   | Tlong0 (s, a0) -> Cast_case_l2l
   | Tfloat0 (f, a0) ->
     (match f with
      | F32 -> Cast_case_s2l si2
      | F64 -> Cast_case_f2l si2)
   | Tpointer (t1, a0) -> Cast_case_i2l si2
   | Tarray (t1, z0, a0) -> Cast_case_i2l si2
   | Tfunction (t1, t2, c) -> Cast_case_i2l si2
   | _ -> Cast_case_default)
| Tfloat0 (f, a) ->
  (match f with
   | F32 ->
     (match tfrom with
      | Tint0 (sz1, si1, a0) -> Cast_case_i2s si1
      | Tlong0 (si1, a0) -> Cast_case_l2s si1
      | Tfloat0 (f0, a0) ->
        (match f0 with
         | F32 -> Cast_case_s2s
         | F64 -> Cast_case_f2s)
      | _ -> Cast_case_default)
   | F64 ->
     (match tfrom with
      | Tint0 (sz1, si1, a0) -> Cast_case_i2f si1
      | Tlong0 (si1, a0) -> Cast_case_l2f si1
      | Tfloat0 (f0, a0) ->
        (match f0 with
         | F32 -> Cast_case_s2f
         | F64 -> Cast_case_f2f)
      | _ -> Cast_case_default))
| Tpointer (t1, a) ->
  (match tfrom with
   | Tint0 (i, s, a0) -> Cast_case_neutral
   | Tlong0 (s, a0) -> Cast_case_l2i (I32, Unsigned)
   | Tpointer (t2, a0) -> Cast_case_neutral
   | Tarray (t2, z0, a0) -> Cast_case_neutral
   | Tfunction (t2, t3, c) -> Cast_case_neutral
   | _ -> Cast_case_default)
| Tstruct (id2, a) ->
  (match tfrom with
   | Tstruct (id1, a0) -> Cast_case_struct (id1, id2)
   | _ -> Cast_case_default)
| Tunion (id2, a) ->
  (match tfrom with
   | Tunion (id1, a0) -> Cast_case_union (id1, id2)
   | _ -> Cast_case_default)
| _ -> Cast_case_default

type classify_bool_cases =
| Bool_case_i
| Bool_case_f
| Bool_case_s
| Bool_case_p
| Bool_case_l
| Bool_default

(** val classify_bool : type0 -> classify_bool_cases **)

let classify_bool ty =
  match typeconv ty with
  | Tint0 (i, s, a) -> Bool_case_i
  | Tlong0 (s, a) -> Bool_case_l
  | Tfloat0 (f, a) ->
    (match f with
     | F32 -> Bool_case_s
     | F64 -> Bool_case_f)
  | Tpointer (t1, a) -> Bool_case_p
  | _ -> Bool_default

type classify_neg_cases =
| Neg_case_i of signedness
| Neg_case_f
| Neg_case_s
| Neg_case_l of signedness
| Neg_default

(** val classify_neg : type0 -> classify_neg_cases **)

let classify_neg = function
| Tint0 (i, s, a) ->
  (match i with
   | I32 -> Neg_case_i s
   | _ -> Neg_case_i Signed)
| Tlong0 (si, a) -> Neg_case_l si
| Tfloat0 (f, a) ->
  (match f with
   | F32 -> Neg_case_s
   | F64 -> Neg_case_f)
| _ -> Neg_default

type classify_notint_cases =
| Notint_case_i of signedness
| Notint_case_l of signedness
| Notint_default

(** val classify_notint : type0 -> classify_notint_cases **)

let classify_notint = function
| Tint0 (i, s, a) ->
  (match i with
   | I32 -> Notint_case_i s
   | _ -> Notint_case_i Signed)
| Tlong0 (si, a) -> Notint_case_l si
| _ -> Notint_default

type binarith_cases =
| Bin_case_i of signedness
| Bin_case_l of signedness
| Bin_case_f
| Bin_case_s
| Bin_default

(** val classify_binarith : type0 -> type0 -> binarith_cases **)

let classify_binarith ty1 ty2 =
  match ty1 with
  | Tint0 (i, s, a) ->
    (match i with
     | I32 ->
       (match s with
        | Signed ->
          (match ty2 with
           | Tint0 (i0, s0, a0) ->
             (match i0 with
              | I32 -> Bin_case_i s0
              | _ -> Bin_case_i Signed)
           | Tlong0 (sg, a0) -> Bin_case_l sg
           | Tfloat0 (f, a0) ->
             (match f with
              | F32 -> Bin_case_s
              | F64 -> Bin_case_f)
           | _ -> Bin_default)
        | Unsigned ->
          (match ty2 with
           | Tint0 (i0, s0, a0) -> Bin_case_i Unsigned
           | Tlong0 (sg, a0) -> Bin_case_l sg
           | Tfloat0 (f, a0) ->
             (match f with
              | F32 -> Bin_case_s
              | F64 -> Bin_case_f)
           | _ -> Bin_default))
     | _ ->
       (match ty2 with
        | Tint0 (i0, s0, a0) ->
          (match i0 with
           | I32 -> Bin_case_i s0
           | _ -> Bin_case_i Signed)
        | Tlong0 (sg, a0) -> Bin_case_l sg
        | Tfloat0 (f, a0) ->
          (match f with
           | F32 -> Bin_case_s
           | F64 -> Bin_case_f)
        | _ -> Bin_default))
  | Tlong0 (sg, a) ->
    (match sg with
     | Signed ->
       (match ty2 with
        | Tint0 (i, s, a0) -> Bin_case_l sg
        | Tlong0 (s, a0) -> Bin_case_l s
        | Tfloat0 (f, a0) ->
          (match f with
           | F32 -> Bin_case_s
           | F64 -> Bin_case_f)
        | _ -> Bin_default)
     | Unsigned ->
       (match ty2 with
        | Tint0 (i, s, a0) -> Bin_case_l sg
        | Tlong0 (s, a0) -> Bin_case_l Unsigned
        | Tfloat0 (f, a0) ->
          (match f with
           | F32 -> Bin_case_s
           | F64 -> Bin_case_f)
        | _ -> Bin_default))
  | Tfloat0 (f, a) ->
    (match f with
     | F32 ->
       (match ty2 with
        | Tint0 (i, s, a0) -> Bin_case_s
        | Tlong0 (s, a0) -> Bin_case_s
        | Tfloat0 (f0, a0) ->
          (match f0 with
           | F32 -> Bin_case_s
           | F64 -> Bin_case_f)
        | _ -> Bin_default)
     | F64 ->
       (match ty2 with
        | Tint0 (i, s, a0) -> Bin_case_f
        | Tlong0 (s, a0) -> Bin_case_f
        | Tfloat0 (f0, a0) -> Bin_case_f
        | _ -> Bin_default))
  | _ -> Bin_default

(** val binarith_type : binarith_cases -> type0 **)

let binarith_type = function
| Bin_case_i sg -> Tint0 (I32, sg, noattr)
| Bin_case_l sg -> Tlong0 (sg, noattr)
| Bin_case_f -> Tfloat0 (F64, noattr)
| Bin_case_s -> Tfloat0 (F32, noattr)
| Bin_default -> Tvoid

type classify_add_cases =
| Add_case_pi of type0
| Add_case_ip of type0
| Add_case_pl of type0
| Add_case_lp of type0
| Add_default

(** val classify_add : type0 -> type0 -> classify_add_cases **)

let classify_add ty1 ty2 =
  match typeconv ty1 with
  | Tint0 (i, s, a) ->
    (match typeconv ty2 with
     | Tpointer (ty, a0) -> Add_case_ip ty
     | _ -> Add_default)
  | Tlong0 (s, a) ->
    (match typeconv ty2 with
     | Tpointer (ty, a0) -> Add_case_lp ty
     | _ -> Add_default)
  | Tpointer (ty, a) ->
    (match typeconv ty2 with
     | Tint0 (i, s, a0) -> Add_case_pi ty
     | Tlong0 (s, a0) -> Add_case_pl ty
     | _ -> Add_default)
  | _ -> Add_default

type classify_sub_cases =
| Sub_case_pi of type0
| Sub_case_pp of type0
| Sub_case_pl of type0
| Sub_default

(** val classify_sub : type0 -> type0 -> classify_sub_cases **)

let classify_sub ty1 ty2 =
  match typeconv ty1 with
  | Tpointer (ty, a) ->
    (match typeconv ty2 with
     | Tint0 (i, s, a0) -> Sub_case_pi ty
     | Tlong0 (s, a0) -> Sub_case_pl ty
     | Tpointer (t1, a0) -> Sub_case_pp ty
     | _ -> Sub_default)
  | _ -> Sub_default

type classify_shift_cases =
| Shift_case_ii of signedness
| Shift_case_ll of signedness
| Shift_case_il of signedness
| Shift_case_li of signedness
| Shift_default

(** val classify_shift : type0 -> type0 -> classify_shift_cases **)

let classify_shift ty1 ty2 =
  match typeconv ty1 with
  | Tint0 (i, s, a) ->
    (match i with
     | I32 ->
       (match typeconv ty2 with
        | Tint0 (i0, s0, a0) -> Shift_case_ii s
        | Tlong0 (s0, a0) -> Shift_case_il s
        | _ -> Shift_default)
     | _ ->
       (match typeconv ty2 with
        | Tint0 (i0, s0, a0) -> Shift_case_ii Signed
        | Tlong0 (s0, a0) -> Shift_case_il Signed
        | _ -> Shift_default))
  | Tlong0 (s, a) ->
    (match typeconv ty2 with
     | Tint0 (i, s0, a0) -> Shift_case_li s
     | Tlong0 (s0, a0) -> Shift_case_ll s
     | _ -> Shift_default)
  | _ -> Shift_default

type classify_cmp_cases =
| Cmp_case_pp
| Cmp_case_pl
| Cmp_case_lp
| Cmp_default

(** val classify_cmp : type0 -> type0 -> classify_cmp_cases **)

let classify_cmp ty1 ty2 =
  match typeconv ty1 with
  | Tint0 (i, s, a) ->
    (match typeconv ty2 with
     | Tpointer (t1, a0) -> Cmp_case_pp
     | _ -> Cmp_default)
  | Tlong0 (s, a) ->
    (match typeconv ty2 with
     | Tpointer (t1, a0) -> Cmp_case_lp
     | _ -> Cmp_default)
  | Tpointer (t1, a) ->
    (match typeconv ty2 with
     | Tint0 (i, s, a0) -> Cmp_case_pp
     | Tlong0 (s, a0) -> Cmp_case_pl
     | Tpointer (t2, a0) -> Cmp_case_pp
     | _ -> Cmp_default)
  | _ -> Cmp_default

type classify_fun_cases =
| Fun_case_f of typelist * type0 * calling_convention
| Fun_default

(** val classify_fun : type0 -> classify_fun_cases **)

let classify_fun = function
| Tpointer (t1, a) ->
  (match t1 with
   | Tfunction (args, res2, cc) -> Fun_case_f (args, res2, cc)
   | _ -> Fun_default)
| Tfunction (args, res2, cc) -> Fun_case_f (args, res2, cc)
| _ -> Fun_default

type classify_switch_cases =
| Switch_case_i
| Switch_case_l
| Switch_default

(** val classify_switch : type0 -> classify_switch_cases **)

let classify_switch = function
| Tint0 (i, s, a) -> Switch_case_i
| Tlong0 (s, a) -> Switch_case_l
| _ -> Switch_default

type expr =
| Econst_int of Int.int * type0
| Econst_float of float * type0
| Econst_single of float32 * type0
| Econst_long of Int64.int * type0
| Evar of ident * type0
| Etempvar of ident * type0
| Ederef of expr * type0
| Eaddrof of expr * type0
| Eunop of unary_operation * expr * type0
| Ebinop of binary_operation * expr * expr * type0
| Ecast of expr * type0
| Efield of expr * ident * type0
| Esizeof of type0 * type0
| Ealignof of type0 * type0

(** val typeof : expr -> type0 **)

let typeof = function
| Econst_int (i, ty) -> ty
| Econst_float (f, ty) -> ty
| Econst_single (f, ty) -> ty
| Econst_long (i, ty) -> ty
| Evar (i, ty) -> ty
| Etempvar (i, ty) -> ty
| Ederef (e0, ty) -> ty
| Eaddrof (e0, ty) -> ty
| Eunop (u, e0, ty) -> ty
| Ebinop (b, e0, e1, ty) -> ty
| Ecast (e0, ty) -> ty
| Efield (e0, i, ty) -> ty
| Esizeof (t1, ty) -> ty
| Ealignof (t1, ty) -> ty

type label = ident

type statement =
| Sskip
| Sassign of expr * expr
| Sset of ident * expr
| Scall of ident option * expr * expr list
| Sbuiltin of ident option * external_function * typelist * expr list
| Ssequence of statement * statement
| Sifthenelse of expr * statement * statement
| Sloop of statement * statement
| Sbreak
| Scontinue
| Sreturn of expr option
| Sswitch of expr * labeled_statements
| Slabel of label * statement
| Sgoto of label
and labeled_statements =
| LSnil
| LScons of z option * statement * labeled_statements

type function0 = { fn_return : type0; fn_callconv : calling_convention;
                   fn_params : (ident, type0) prod list;
                   fn_vars : (ident, type0) prod list;
                   fn_temps : (ident, type0) prod list; fn_body : statement }

(** val fn_return : function0 -> type0 **)

let fn_return x = x.fn_return

(** val fn_callconv : function0 -> calling_convention **)

let fn_callconv x = x.fn_callconv

(** val fn_params : function0 -> (ident, type0) prod list **)

let fn_params x = x.fn_params

(** val fn_vars : function0 -> (ident, type0) prod list **)

let fn_vars x = x.fn_vars

(** val fn_temps : function0 -> (ident, type0) prod list **)

let fn_temps x = x.fn_temps

(** val fn_body : function0 -> statement **)

let fn_body x = x.fn_body

(** val var_names : (ident, type0) prod list -> ident list **)

let var_names vars =
  map fst vars

type fundef0 =
| Internal0 of function0
| External0 of external_function * typelist * type0 * calling_convention

type program0 = { prog_defs0 : (ident, (fundef0, type0) globdef) prod list;
                  prog_public0 : ident list; prog_main0 : ident;
                  prog_types : composite_definition list;
                  prog_comp_env : composite_env }

(** val prog_defs0 :
    program0 -> (ident, (fundef0, type0) globdef) prod list **)

let prog_defs0 x = x.prog_defs0

(** val prog_public0 : program0 -> ident list **)

let prog_public0 x = x.prog_public0

(** val prog_main0 : program0 -> ident **)

let prog_main0 x = x.prog_main0

(** val prog_types : program0 -> composite_definition list **)

let prog_types x = x.prog_types

(** val prog_comp_env : program0 -> composite_env **)

let prog_comp_env x = x.prog_comp_env

(** val program_of_program : program0 -> (fundef0, type0) program **)

let program_of_program p =
  { prog_defs = p.prog_defs0; prog_public = p.prog_public0; prog_main =
    p.prog_main0 }

type table = (z, nat) prod list

type comptree =
| CTaction of nat
| CTifeq of z * nat * comptree
| CTiflt of z * comptree * comptree
| CTjumptable of z * z * nat list * comptree

(** val split_lt : z -> table -> (table, table) prod **)

let rec split_lt pivot = function
| Nil -> Pair (Nil, Nil)
| Cons (p, rem0) ->
  let Pair (key, act) = p in
  let Pair (l, r) = split_lt pivot rem0 in
  (match zlt key pivot with
   | Left -> Pair ((Cons ((Pair (key, act)), l)), r)
   | Right -> Pair (l, (Cons ((Pair (key, act)), r))))

(** val split_eq : z -> table -> (nat option, table) prod **)

let rec split_eq pivot = function
| Nil -> Pair (None, Nil)
| Cons (p, rem0) ->
  let Pair (key, act) = p in
  let Pair (same, others) = split_eq pivot rem0 in
  (match zeq key pivot with
   | Left -> Pair ((Some act), others)
   | Right -> Pair (same, (Cons ((Pair (key, act)), others))))

(** val split_between :
    z -> nat -> z -> z -> table -> (nat ZMap.t, table) prod **)

let rec split_between modulus0 dfl ofs sz = function
| Nil -> Pair ((ZMap.init dfl), Nil)
| Cons (p, rem0) ->
  let Pair (key, act) = p in
  let Pair (inside, outside) = split_between modulus0 dfl ofs sz rem0 in
  (match zlt (Z.modulo (Z.sub key ofs) modulus0) sz with
   | Left -> Pair ((ZMap.set key act inside), outside)
   | Right -> Pair (inside, (Cons ((Pair (key, act)), outside))))

(** val refine_low_bound : z -> z -> z **)

let refine_low_bound v lo =
  match zeq v lo with
  | Left -> Z.add lo (Zpos XH)
  | Right -> lo

(** val refine_high_bound : z -> z -> z **)

let refine_high_bound v hi =
  match zeq v hi with
  | Left -> Z.sub hi (Zpos XH)
  | Right -> hi

(** val validate_jumptable : nat ZMap.t -> nat list -> z -> bool **)

let rec validate_jumptable cases tbl n0 =
  match tbl with
  | Nil -> True
  | Cons (act, rem0) ->
    (match beq_nat act (ZMap.get n0 cases) with
     | True -> validate_jumptable cases rem0 (Z.succ n0)
     | False -> False)

(** val validate : z -> nat -> table -> comptree -> z -> z -> bool **)

let rec validate modulus0 default0 cases t1 lo hi =
  match t1 with
  | CTaction act ->
    (match cases with
     | Nil -> beq_nat act default0
     | Cons (p, l) ->
       let Pair (key1, act1) = p in
       (match match proj_sumbool (zeq key1 lo) with
              | True -> proj_sumbool (zeq lo hi)
              | False -> False with
        | True -> beq_nat act act1
        | False -> False))
  | CTifeq (pivot, act, t'0) ->
    (match match proj_sumbool (zle Z0 pivot) with
           | True -> proj_sumbool (zlt pivot modulus0)
           | False -> False with
     | True ->
       let Pair (o, others) = split_eq pivot cases in
       (match o with
        | Some act' ->
          (match beq_nat act act' with
           | True ->
             validate modulus0 default0 others t'0
               (refine_low_bound pivot lo) (refine_high_bound pivot hi)
           | False -> False)
        | None -> False)
     | False -> False)
  | CTiflt (pivot, t2, t3) ->
    (match match proj_sumbool (zle Z0 pivot) with
           | True -> proj_sumbool (zlt pivot modulus0)
           | False -> False with
     | True ->
       let Pair (lcases, rcases) = split_lt pivot cases in
       (match validate modulus0 default0 lcases t2 lo (Z.sub pivot (Zpos XH)) with
        | True -> validate modulus0 default0 rcases t3 pivot hi
        | False -> False)
     | False -> False)
  | CTjumptable (ofs, sz, tbl, t'0) ->
    let tbl_len = list_length_z tbl in
    (match match match match match match match proj_sumbool (zle Z0 ofs) with
                                         | True ->
                                           proj_sumbool (zlt ofs modulus0)
                                         | False -> False with
                                   | True -> proj_sumbool (zle Z0 sz)
                                   | False -> False with
                             | True -> proj_sumbool (zlt sz modulus0)
                             | False -> False with
                       | True -> proj_sumbool (zle (Z.add ofs sz) modulus0)
                       | False -> False with
                 | True -> proj_sumbool (zle sz tbl_len)
                 | False -> False with
           | True -> proj_sumbool (zlt sz Int.modulus)
           | False -> False with
     | True ->
       let Pair (inside, outside) =
         split_between modulus0 default0 ofs sz cases
       in
       (match validate_jumptable inside tbl ofs with
        | True -> validate modulus0 default0 outside t'0 lo hi
        | False -> False)
     | False -> False)

(** val validate_switch : z -> nat -> table -> comptree -> bool **)

let validate_switch modulus0 default0 cases t1 =
  validate modulus0 default0 cases t1 Z0 (Z.sub modulus0 (Zpos XH))

type constant =
| Ointconst of Int.int
| Ofloatconst of float
| Osingleconst of float32
| Olongconst of Int64.int
| Oaddrsymbol of ident * Int.int
| Oaddrstack of Int.int

type unary_operation0 =
| Ocast8unsigned
| Ocast8signed
| Ocast16unsigned
| Ocast16signed
| Onegint
| Onotint0
| Onegf
| Oabsf
| Onegfs
| Oabsfs
| Osingleoffloat
| Ofloatofsingle
| Ointoffloat
| Ointuoffloat
| Ofloatofint
| Ofloatofintu
| Ointofsingle
| Ointuofsingle
| Osingleofint
| Osingleofintu
| Onegl
| Onotl
| Ointoflong
| Olongofint
| Olongofintu
| Olongoffloat
| Olonguoffloat
| Ofloatoflong
| Ofloatoflongu
| Olongofsingle
| Olonguofsingle
| Osingleoflong
| Osingleoflongu

type binary_operation0 =
| Oadd0
| Osub0
| Omul0
| Odiv0
| Odivu
| Omod0
| Omodu
| Oand0
| Oor0
| Oxor0
| Oshl0
| Oshr0
| Oshru
| Oaddf
| Osubf
| Omulf
| Odivf
| Oaddfs
| Osubfs
| Omulfs
| Odivfs
| Oaddl
| Osubl
| Omull
| Odivl
| Odivlu
| Omodl
| Omodlu
| Oandl
| Oorl
| Oxorl
| Oshll
| Oshrl
| Oshrlu
| Ocmp of comparison0
| Ocmpu of comparison0
| Ocmpf of comparison0
| Ocmpfs of comparison0
| Ocmpl of comparison0
| Ocmplu of comparison0

type expr0 =
| Evar0 of ident
| Econst of constant
| Eunop0 of unary_operation0 * expr0
| Ebinop0 of binary_operation0 * expr0 * expr0
| Eload of memory_chunk * expr0

type label0 = ident

type stmt =
| Sskip0
| Sassign0 of ident * expr0
| Sstore of memory_chunk * expr0 * expr0
| Scall0 of ident option * signature * expr0 * expr0 list
| Stailcall of signature * expr0 * expr0 list
| Sbuiltin0 of ident option * external_function * expr0 list
| Sseq of stmt * stmt
| Sifthenelse0 of expr0 * stmt * stmt
| Sloop0 of stmt
| Sblock of stmt
| Sexit of nat
| Sswitch0 of bool * expr0 * (z, nat) prod list * nat
| Sreturn0 of expr0 option
| Slabel0 of label0 * stmt
| Sgoto0 of label0

type function1 = { fn_sig : signature; fn_params0 : ident list;
                   fn_vars0 : ident list; fn_stackspace : z; fn_body0 : 
                   stmt }

(** val fn_sig : function1 -> signature **)

let fn_sig x = x.fn_sig

(** val fn_params0 : function1 -> ident list **)

let fn_params0 x = x.fn_params0

(** val fn_vars0 : function1 -> ident list **)

let fn_vars0 x = x.fn_vars0

(** val fn_stackspace : function1 -> z **)

let fn_stackspace x = x.fn_stackspace

(** val fn_body0 : function1 -> stmt **)

let fn_body0 x = x.fn_body0

type fundef1 = function1 fundef

type program1 = (fundef1, unit0) program

type genv = (fundef1, unit0) Genv.t

type constant0 =
| Ointconst0 of Int.int
| Ofloatconst0 of float
| Osingleconst0 of float32
| Olongconst0 of Int64.int

type unary_operation1 = unary_operation0

type binary_operation1 = binary_operation0

type expr1 =
| Evar1 of ident
| Eaddrof0 of ident
| Econst0 of constant0
| Eunop1 of unary_operation1 * expr1
| Ebinop1 of binary_operation1 * expr1 * expr1
| Eload0 of memory_chunk * expr1

type label1 = ident

type stmt0 =
| Sskip1
| Sset0 of ident * expr1
| Sstore0 of memory_chunk * expr1 * expr1
| Scall1 of ident option * signature * expr1 * expr1 list
| Sbuiltin1 of ident option * external_function * expr1 list
| Sseq0 of stmt0 * stmt0
| Sifthenelse1 of expr1 * stmt0 * stmt0
| Sloop1 of stmt0
| Sblock0 of stmt0
| Sexit0 of nat
| Sswitch1 of bool * expr1 * lbl_stmt
| Sreturn1 of expr1 option
| Slabel1 of label1 * stmt0
| Sgoto1 of label1
and lbl_stmt =
| LSnil0
| LScons0 of z option * stmt0 * lbl_stmt

type function2 = { fn_sig0 : signature; fn_params1 : ident list;
                   fn_vars1 : (ident, z) prod list; fn_temps0 : ident list;
                   fn_body1 : stmt0 }

(** val fn_sig0 : function2 -> signature **)

let fn_sig0 x = x.fn_sig0

(** val fn_params1 : function2 -> ident list **)

let fn_params1 x = x.fn_params1

(** val fn_vars1 : function2 -> (ident, z) prod list **)

let fn_vars1 x = x.fn_vars1

(** val fn_temps0 : function2 -> ident list **)

let fn_temps0 x = x.fn_temps0

(** val fn_body1 : function2 -> stmt0 **)

let fn_body1 x = x.fn_body1

type fundef2 = function2 fundef

type program2 = (fundef2, unit0) program

type condition =
| Ccomp of comparison0
| Ccompu of comparison0
| Ccompimm of comparison0 * Int.int
| Ccompuimm of comparison0 * Int.int
| Ccompf of comparison0
| Cnotcompf of comparison0
| Ccompfs of comparison0
| Cnotcompfs of comparison0
| Cmaskzero of Int.int
| Cmasknotzero of Int.int

type addressing =
| Aindexed of Int.int
| Aindexed2 of Int.int
| Ascaled of Int.int * Int.int
| Aindexed2scaled of Int.int * Int.int
| Aglobal of ident * Int.int
| Abased of ident * Int.int
| Abasedscaled of Int.int * ident * Int.int
| Ainstack of Int.int

type operation =
| Omove
| Ointconst1 of Int.int
| Ofloatconst1 of float
| Osingleconst1 of float32
| Oindirectsymbol of ident
| Ocast8signed0
| Ocast8unsigned0
| Ocast16signed0
| Ocast16unsigned0
| Oneg0
| Osub1
| Omul1
| Omulimm of Int.int
| Omulhs
| Omulhu
| Odiv1
| Odivu0
| Omod1
| Omodu0
| Oand1
| Oandimm of Int.int
| Oor1
| Oorimm of Int.int
| Oxor1
| Oxorimm of Int.int
| Onot
| Oshl1
| Oshlimm of Int.int
| Oshr1
| Oshrimm of Int.int
| Oshrximm of Int.int
| Oshru0
| Oshruimm of Int.int
| Ororimm of Int.int
| Oshldimm of Int.int
| Olea of addressing
| Onegf0
| Oabsf0
| Oaddf0
| Osubf0
| Omulf0
| Odivf0
| Onegfs0
| Oabsfs0
| Oaddfs0
| Osubfs0
| Omulfs0
| Odivfs0
| Osingleoffloat0
| Ofloatofsingle0
| Ointoffloat0
| Ofloatofint0
| Ointofsingle0
| Osingleofint0
| Omakelong
| Olowlong
| Ohighlong
| Ocmp0 of condition

(** val oaddrsymbol : ident -> Int.int -> operation **)

let oaddrsymbol id ofs =
  Olea (Aglobal (id, ofs))

(** val oaddrstack : Int.int -> operation **)

let oaddrstack ofs =
  Olea (Ainstack ofs)

(** val eq_condition : condition -> condition -> sumbool **)

let eq_condition x y =
  let h0 = fun x0 y0 ->
    match x0 with
    | Ceq ->
      (match y0 with
       | Ceq -> Left
       | _ -> Right)
    | Cne ->
      (match y0 with
       | Cne -> Left
       | _ -> Right)
    | Clt ->
      (match y0 with
       | Clt -> Left
       | _ -> Right)
    | Cle ->
      (match y0 with
       | Cle -> Left
       | _ -> Right)
    | Cgt ->
      (match y0 with
       | Cgt -> Left
       | _ -> Right)
    | Cge ->
      (match y0 with
       | Cge -> Left
       | _ -> Right)
  in
  (match x with
   | Ccomp x0 ->
     (match y with
      | Ccomp c0 -> h0 x0 c0
      | _ -> Right)
   | Ccompu x0 ->
     (match y with
      | Ccompu c0 -> h0 x0 c0
      | _ -> Right)
   | Ccompimm (x0, x1) ->
     (match y with
      | Ccompimm (c0, i0) ->
        (match h0 x0 c0 with
         | Left -> Int.eq_dec x1 i0
         | Right -> Right)
      | _ -> Right)
   | Ccompuimm (x0, x1) ->
     (match y with
      | Ccompuimm (c0, i0) ->
        (match h0 x0 c0 with
         | Left -> Int.eq_dec x1 i0
         | Right -> Right)
      | _ -> Right)
   | Ccompf x0 ->
     (match y with
      | Ccompf c0 -> h0 x0 c0
      | _ -> Right)
   | Cnotcompf x0 ->
     (match y with
      | Cnotcompf c0 -> h0 x0 c0
      | _ -> Right)
   | Ccompfs x0 ->
     (match y with
      | Ccompfs c0 -> h0 x0 c0
      | _ -> Right)
   | Cnotcompfs x0 ->
     (match y with
      | Cnotcompfs c0 -> h0 x0 c0
      | _ -> Right)
   | Cmaskzero x0 ->
     (match y with
      | Cmaskzero i0 -> Int.eq_dec x0 i0
      | _ -> Right)
   | Cmasknotzero x0 ->
     (match y with
      | Cmasknotzero i0 -> Int.eq_dec x0 i0
      | _ -> Right))

(** val eq_addressing : addressing -> addressing -> sumbool **)

let eq_addressing x y =
  match x with
  | Aindexed x0 ->
    (match y with
     | Aindexed i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Aindexed2 x0 ->
    (match y with
     | Aindexed2 i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Ascaled (x0, x1) ->
    (match y with
     | Ascaled (i1, i2) ->
       (match Int.eq_dec x0 i1 with
        | Left -> Int.eq_dec x1 i2
        | Right -> Right)
     | _ -> Right)
  | Aindexed2scaled (x0, x1) ->
    (match y with
     | Aindexed2scaled (i1, i2) ->
       (match Int.eq_dec x0 i1 with
        | Left -> Int.eq_dec x1 i2
        | Right -> Right)
     | _ -> Right)
  | Aglobal (x0, x1) ->
    (match y with
     | Aglobal (i1, i2) ->
       (match peq x0 i1 with
        | Left -> Int.eq_dec x1 i2
        | Right -> Right)
     | _ -> Right)
  | Abased (x0, x1) ->
    (match y with
     | Abased (i1, i2) ->
       (match peq x0 i1 with
        | Left -> Int.eq_dec x1 i2
        | Right -> Right)
     | _ -> Right)
  | Abasedscaled (x0, x1, x2) ->
    (match y with
     | Abasedscaled (i2, i3, i4) ->
       (match Int.eq_dec x0 i2 with
        | Left ->
          (match peq x1 i3 with
           | Left -> Int.eq_dec x2 i4
           | Right -> Right)
        | Right -> Right)
     | _ -> Right)
  | Ainstack x0 ->
    (match y with
     | Ainstack i0 -> Int.eq_dec x0 i0
     | _ -> Right)

(** val eq_operation : operation -> operation -> sumbool **)

let eq_operation x y =
  match x with
  | Omove ->
    (match y with
     | Omove -> Left
     | _ -> Right)
  | Ointconst1 x0 ->
    (match y with
     | Ointconst1 i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Ofloatconst1 x0 ->
    (match y with
     | Ofloatconst1 f0 -> Float.eq_dec x0 f0
     | _ -> Right)
  | Osingleconst1 x0 ->
    (match y with
     | Osingleconst1 f0 -> Float32.eq_dec x0 f0
     | _ -> Right)
  | Oindirectsymbol x0 ->
    (match y with
     | Oindirectsymbol i0 -> peq x0 i0
     | _ -> Right)
  | Ocast8signed0 ->
    (match y with
     | Ocast8signed0 -> Left
     | _ -> Right)
  | Ocast8unsigned0 ->
    (match y with
     | Ocast8unsigned0 -> Left
     | _ -> Right)
  | Ocast16signed0 ->
    (match y with
     | Ocast16signed0 -> Left
     | _ -> Right)
  | Ocast16unsigned0 ->
    (match y with
     | Ocast16unsigned0 -> Left
     | _ -> Right)
  | Oneg0 ->
    (match y with
     | Oneg0 -> Left
     | _ -> Right)
  | Osub1 ->
    (match y with
     | Osub1 -> Left
     | _ -> Right)
  | Omul1 ->
    (match y with
     | Omul1 -> Left
     | _ -> Right)
  | Omulimm x0 ->
    (match y with
     | Omulimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Omulhs ->
    (match y with
     | Omulhs -> Left
     | _ -> Right)
  | Omulhu ->
    (match y with
     | Omulhu -> Left
     | _ -> Right)
  | Odiv1 ->
    (match y with
     | Odiv1 -> Left
     | _ -> Right)
  | Odivu0 ->
    (match y with
     | Odivu0 -> Left
     | _ -> Right)
  | Omod1 ->
    (match y with
     | Omod1 -> Left
     | _ -> Right)
  | Omodu0 ->
    (match y with
     | Omodu0 -> Left
     | _ -> Right)
  | Oand1 ->
    (match y with
     | Oand1 -> Left
     | _ -> Right)
  | Oandimm x0 ->
    (match y with
     | Oandimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oor1 ->
    (match y with
     | Oor1 -> Left
     | _ -> Right)
  | Oorimm x0 ->
    (match y with
     | Oorimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oxor1 ->
    (match y with
     | Oxor1 -> Left
     | _ -> Right)
  | Oxorimm x0 ->
    (match y with
     | Oxorimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Onot ->
    (match y with
     | Onot -> Left
     | _ -> Right)
  | Oshl1 ->
    (match y with
     | Oshl1 -> Left
     | _ -> Right)
  | Oshlimm x0 ->
    (match y with
     | Oshlimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oshr1 ->
    (match y with
     | Oshr1 -> Left
     | _ -> Right)
  | Oshrimm x0 ->
    (match y with
     | Oshrimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oshrximm x0 ->
    (match y with
     | Oshrximm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oshru0 ->
    (match y with
     | Oshru0 -> Left
     | _ -> Right)
  | Oshruimm x0 ->
    (match y with
     | Oshruimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Ororimm x0 ->
    (match y with
     | Ororimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Oshldimm x0 ->
    (match y with
     | Oshldimm i0 -> Int.eq_dec x0 i0
     | _ -> Right)
  | Olea x0 ->
    (match y with
     | Olea a0 -> eq_addressing x0 a0
     | _ -> Right)
  | Onegf0 ->
    (match y with
     | Onegf0 -> Left
     | _ -> Right)
  | Oabsf0 ->
    (match y with
     | Oabsf0 -> Left
     | _ -> Right)
  | Oaddf0 ->
    (match y with
     | Oaddf0 -> Left
     | _ -> Right)
  | Osubf0 ->
    (match y with
     | Osubf0 -> Left
     | _ -> Right)
  | Omulf0 ->
    (match y with
     | Omulf0 -> Left
     | _ -> Right)
  | Odivf0 ->
    (match y with
     | Odivf0 -> Left
     | _ -> Right)
  | Onegfs0 ->
    (match y with
     | Onegfs0 -> Left
     | _ -> Right)
  | Oabsfs0 ->
    (match y with
     | Oabsfs0 -> Left
     | _ -> Right)
  | Oaddfs0 ->
    (match y with
     | Oaddfs0 -> Left
     | _ -> Right)
  | Osubfs0 ->
    (match y with
     | Osubfs0 -> Left
     | _ -> Right)
  | Omulfs0 ->
    (match y with
     | Omulfs0 -> Left
     | _ -> Right)
  | Odivfs0 ->
    (match y with
     | Odivfs0 -> Left
     | _ -> Right)
  | Osingleoffloat0 ->
    (match y with
     | Osingleoffloat0 -> Left
     | _ -> Right)
  | Ofloatofsingle0 ->
    (match y with
     | Ofloatofsingle0 -> Left
     | _ -> Right)
  | Ointoffloat0 ->
    (match y with
     | Ointoffloat0 -> Left
     | _ -> Right)
  | Ofloatofint0 ->
    (match y with
     | Ofloatofint0 -> Left
     | _ -> Right)
  | Ointofsingle0 ->
    (match y with
     | Ointofsingle0 -> Left
     | _ -> Right)
  | Osingleofint0 ->
    (match y with
     | Osingleofint0 -> Left
     | _ -> Right)
  | Omakelong ->
    (match y with
     | Omakelong -> Left
     | _ -> Right)
  | Olowlong ->
    (match y with
     | Olowlong -> Left
     | _ -> Right)
  | Ohighlong ->
    (match y with
     | Ohighlong -> Left
     | _ -> Right)
  | Ocmp0 x0 ->
    (match y with
     | Ocmp0 c0 -> eq_condition x0 c0
     | _ -> Right)

(** val type_of_condition : condition -> typ list **)

let type_of_condition = function
| Ccomp c0 -> Cons (Tint, (Cons (Tint, Nil)))
| Ccompu c0 -> Cons (Tint, (Cons (Tint, Nil)))
| Ccompf c0 -> Cons (Tfloat, (Cons (Tfloat, Nil)))
| Cnotcompf c0 -> Cons (Tfloat, (Cons (Tfloat, Nil)))
| Ccompfs c0 -> Cons (Tsingle, (Cons (Tsingle, Nil)))
| Cnotcompfs c0 -> Cons (Tsingle, (Cons (Tsingle, Nil)))
| _ -> Cons (Tint, Nil)

(** val type_of_addressing : addressing -> typ list **)

let type_of_addressing = function
| Aindexed2 i -> Cons (Tint, (Cons (Tint, Nil)))
| Aindexed2scaled (i, i0) -> Cons (Tint, (Cons (Tint, Nil)))
| Aglobal (i, i0) -> Nil
| Ainstack i -> Nil
| _ -> Cons (Tint, Nil)

(** val type_of_operation : operation -> (typ list, typ) prod **)

let type_of_operation = function
| Omove -> Pair (Nil, Tint)
| Ointconst1 i -> Pair (Nil, Tint)
| Ofloatconst1 f -> Pair (Nil, Tfloat)
| Osingleconst1 f -> Pair (Nil, Tsingle)
| Oindirectsymbol i -> Pair (Nil, Tint)
| Ocast8signed0 -> Pair ((Cons (Tint, Nil)), Tint)
| Ocast8unsigned0 -> Pair ((Cons (Tint, Nil)), Tint)
| Ocast16signed0 -> Pair ((Cons (Tint, Nil)), Tint)
| Ocast16unsigned0 -> Pair ((Cons (Tint, Nil)), Tint)
| Oneg0 -> Pair ((Cons (Tint, Nil)), Tint)
| Omulimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oandimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oorimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oxorimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Onot -> Pair ((Cons (Tint, Nil)), Tint)
| Oshlimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oshrimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oshrximm i -> Pair ((Cons (Tint, Nil)), Tint)
| Oshruimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Ororimm i -> Pair ((Cons (Tint, Nil)), Tint)
| Olea addr -> Pair ((type_of_addressing addr), Tint)
| Onegf0 -> Pair ((Cons (Tfloat, Nil)), Tfloat)
| Oabsf0 -> Pair ((Cons (Tfloat, Nil)), Tfloat)
| Oaddf0 -> Pair ((Cons (Tfloat, (Cons (Tfloat, Nil)))), Tfloat)
| Osubf0 -> Pair ((Cons (Tfloat, (Cons (Tfloat, Nil)))), Tfloat)
| Omulf0 -> Pair ((Cons (Tfloat, (Cons (Tfloat, Nil)))), Tfloat)
| Odivf0 -> Pair ((Cons (Tfloat, (Cons (Tfloat, Nil)))), Tfloat)
| Onegfs0 -> Pair ((Cons (Tsingle, Nil)), Tsingle)
| Oabsfs0 -> Pair ((Cons (Tsingle, Nil)), Tsingle)
| Oaddfs0 -> Pair ((Cons (Tsingle, (Cons (Tsingle, Nil)))), Tsingle)
| Osubfs0 -> Pair ((Cons (Tsingle, (Cons (Tsingle, Nil)))), Tsingle)
| Omulfs0 -> Pair ((Cons (Tsingle, (Cons (Tsingle, Nil)))), Tsingle)
| Odivfs0 -> Pair ((Cons (Tsingle, (Cons (Tsingle, Nil)))), Tsingle)
| Osingleoffloat0 -> Pair ((Cons (Tfloat, Nil)), Tsingle)
| Ofloatofsingle0 -> Pair ((Cons (Tsingle, Nil)), Tfloat)
| Ointoffloat0 -> Pair ((Cons (Tfloat, Nil)), Tint)
| Ofloatofint0 -> Pair ((Cons (Tint, Nil)), Tfloat)
| Ointofsingle0 -> Pair ((Cons (Tsingle, Nil)), Tint)
| Osingleofint0 -> Pair ((Cons (Tint, Nil)), Tsingle)
| Omakelong -> Pair ((Cons (Tint, (Cons (Tint, Nil)))), Tlong)
| Olowlong -> Pair ((Cons (Tlong, Nil)), Tint)
| Ohighlong -> Pair ((Cons (Tlong, Nil)), Tint)
| Ocmp0 c -> Pair ((type_of_condition c), Tint)
| _ -> Pair ((Cons (Tint, (Cons (Tint, Nil)))), Tint)

(** val is_move_operation : operation -> 'a1 list -> 'a1 option **)

let is_move_operation op args =
  match op with
  | Omove ->
    (match args with
     | Nil -> None
     | Cons (arg, l) ->
       (match l with
        | Nil -> Some arg
        | Cons (a, l0) -> None))
  | _ -> None

(** val negate_condition : condition -> condition **)

let negate_condition = function
| Ccomp c -> Ccomp (negate_comparison c)
| Ccompu c -> Ccompu (negate_comparison c)
| Ccompimm (c, n0) -> Ccompimm ((negate_comparison c), n0)
| Ccompuimm (c, n0) -> Ccompuimm ((negate_comparison c), n0)
| Ccompf c -> Cnotcompf c
| Cnotcompf c -> Ccompf c
| Ccompfs c -> Cnotcompfs c
| Cnotcompfs c -> Ccompfs c
| Cmaskzero n0 -> Cmasknotzero n0
| Cmasknotzero n0 -> Cmaskzero n0

(** val shift_stack_addressing : Int.int -> addressing -> addressing **)

let shift_stack_addressing delta addr = match addr with
| Ainstack ofs -> Ainstack (Int.add delta ofs)
| _ -> addr

(** val shift_stack_operation : Int.int -> operation -> operation **)

let shift_stack_operation delta op = match op with
| Olea addr -> Olea (shift_stack_addressing delta addr)
| _ -> op

(** val offset_addressing_total : addressing -> Int.int -> addressing **)

let offset_addressing_total addr delta =
  match addr with
  | Aindexed n0 -> Aindexed (Int.add n0 delta)
  | Aindexed2 n0 -> Aindexed2 (Int.add n0 delta)
  | Ascaled (sc, n0) -> Ascaled (sc, (Int.add n0 delta))
  | Aindexed2scaled (sc, n0) -> Aindexed2scaled (sc, (Int.add n0 delta))
  | Aglobal (s, n0) -> Aglobal (s, (Int.add n0 delta))
  | Abased (s, n0) -> Abased (s, (Int.add n0 delta))
  | Abasedscaled (sc, s, n0) -> Abasedscaled (sc, s, (Int.add n0 delta))
  | Ainstack n0 -> Ainstack (Int.add n0 delta)

(** val offset_addressing : addressing -> Int.int -> addressing option **)

let offset_addressing addr delta =
  Some (offset_addressing_total addr delta)

(** val is_trivial_op : operation -> bool **)

let is_trivial_op = function
| Omove -> True
| Ointconst1 i -> True
| Olea a ->
  (match a with
   | Aglobal (i, i0) -> True
   | Ainstack i -> True
   | _ -> False)
| _ -> False

(** val op_depends_on_memory : operation -> bool **)

let op_depends_on_memory = function
| Ocmp0 c ->
  (match c with
   | Ccompu c0 -> True
   | Ccompuimm (c0, i) -> True
   | _ -> False)
| _ -> False

(** val globals_addressing : addressing -> ident list **)

let globals_addressing = function
| Aglobal (s, n0) -> Cons (s, Nil)
| Abased (s, n0) -> Cons (s, Nil)
| Abasedscaled (sc, s, n0) -> Cons (s, Nil)
| _ -> Nil

(** val globals_operation : operation -> ident list **)

let globals_operation = function
| Oindirectsymbol s -> Cons (s, Nil)
| Olea addr -> globals_addressing addr
| _ -> Nil

type expr2 =
| Evar2 of ident
| Eop of operation * exprlist
| Eload1 of memory_chunk * addressing * exprlist
| Econdition of condexpr * expr2 * expr2
| Elet of expr2 * expr2
| Eletvar of nat
| Ebuiltin of external_function * exprlist
| Eexternal of ident * signature * exprlist
and exprlist =
| Enil
| Econs of expr2 * exprlist
and condexpr =
| CEcond of condition * exprlist
| CEcondition of condexpr * condexpr * condexpr
| CElet of expr2 * condexpr

type exitexpr =
| XEexit of nat
| XEjumptable of expr2 * nat list
| XEcondition of condexpr * exitexpr * exitexpr
| XElet of expr2 * exitexpr

type stmt1 =
| Sskip2
| Sassign1 of ident * expr2
| Sstore1 of memory_chunk * addressing * exprlist * expr2
| Scall2 of ident option * signature * (expr2, ident) sum * exprlist
| Stailcall0 of signature * (expr2, ident) sum * exprlist
| Sbuiltin2 of ident builtin_res * external_function * expr2 builtin_arg list
| Sseq1 of stmt1 * stmt1
| Sifthenelse2 of condexpr * stmt1 * stmt1
| Sloop2 of stmt1
| Sblock1 of stmt1
| Sexit1 of nat
| Sswitch2 of exitexpr
| Sreturn2 of expr2 option
| Slabel2 of label0 * stmt1
| Sgoto2 of label0

type function3 = { fn_sig1 : signature; fn_params2 : ident list;
                   fn_vars2 : ident list; fn_stackspace0 : z;
                   fn_body2 : stmt1 }

(** val fn_sig1 : function3 -> signature **)

let fn_sig1 x = x.fn_sig1

(** val fn_params2 : function3 -> ident list **)

let fn_params2 x = x.fn_params2

(** val fn_vars2 : function3 -> ident list **)

let fn_vars2 x = x.fn_vars2

(** val fn_stackspace0 : function3 -> z **)

let fn_stackspace0 x = x.fn_stackspace0

(** val fn_body2 : function3 -> stmt1 **)

let fn_body2 x = x.fn_body2

type fundef3 = function3 fundef

type program3 = (fundef3, unit0) program

(** val lift_expr : nat -> expr2 -> expr2 **)

let rec lift_expr p = function
| Evar2 id -> Evar2 id
| Eop (op, bl) -> Eop (op, (lift_exprlist p bl))
| Eload1 (chunk, addr, bl) -> Eload1 (chunk, addr, (lift_exprlist p bl))
| Econdition (a0, b, c) ->
  Econdition ((lift_condexpr p a0), (lift_expr p b), (lift_expr p c))
| Elet (b, c) -> Elet ((lift_expr p b), (lift_expr (S p) c))
| Eletvar n0 ->
  (match le_gt_dec p n0 with
   | Left -> Eletvar (S n0)
   | Right -> Eletvar n0)
| Ebuiltin (ef, bl) -> Ebuiltin (ef, (lift_exprlist p bl))
| Eexternal (id, sg, bl) -> Eexternal (id, sg, (lift_exprlist p bl))

(** val lift_exprlist : nat -> exprlist -> exprlist **)

and lift_exprlist p = function
| Enil -> Enil
| Econs (b, cl) -> Econs ((lift_expr p b), (lift_exprlist p cl))

(** val lift_condexpr : nat -> condexpr -> condexpr **)

and lift_condexpr p = function
| CEcond (c, al) -> CEcond (c, (lift_exprlist p al))
| CEcondition (a0, b, c) ->
  CEcondition ((lift_condexpr p a0), (lift_condexpr p b),
    (lift_condexpr p c))
| CElet (a0, b) -> CElet ((lift_expr p a0), (lift_condexpr (S p) b))

(** val lift : expr2 -> expr2 **)

let lift a =
  lift_expr O a

type 'x compare0 =
| LT
| EQ
| GT

module type Coq_OrderedType = 
 sig 
  type t 
  
  val compare : t -> t -> t compare0
  
  val eq_dec : t -> t -> sumbool
 end

module type DecidableType = 
 DecidableTypeOrig

module type WS = 
 sig 
  module E : 
   DecidableType
  
  type elt = E.t
  
  type t 
  
  val empty : t
  
  val is_empty : t -> bool
  
  val mem : elt -> t -> bool
  
  val add : elt -> t -> t
  
  val singleton : elt -> t
  
  val remove : elt -> t -> t
  
  val union : t -> t -> t
  
  val inter : t -> t -> t
  
  val diff : t -> t -> t
  
  val eq_dec : t -> t -> sumbool
  
  val equal : t -> t -> bool
  
  val subset : t -> t -> bool
  
  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1
  
  val for_all : (elt -> bool) -> t -> bool
  
  val exists_ : (elt -> bool) -> t -> bool
  
  val filter : (elt -> bool) -> t -> t
  
  val partition : (elt -> bool) -> t -> (t, t) prod
  
  val cardinal : t -> nat
  
  val elements : t -> elt list
  
  val choose : t -> elt option
 end

module MakeListOrdering = 
 functor (O:OrderedType) ->
 struct 
  module MO = OrderedTypeFacts(O)
 end

module type OrderedTypeOrig = 
 Coq_OrderedType

module Update_OT = 
 functor (O:OrderedTypeOrig) ->
 struct 
  type t = O.t
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    O.eq_dec
  
  (** val compare : O.t -> O.t -> comparison **)
  
  let compare x y =
    match O.compare x y with
    | LT -> Lt
    | EQ -> Eq
    | GT -> Gt
 end

module type Coq_Int = 
 sig 
  type t 
  
  val i2z : t -> z
  
  val _0 : t
  
  val _1 : t
  
  val _2 : t
  
  val _3 : t
  
  val plus : t -> t -> t
  
  val opp : t -> t
  
  val minus : t -> t -> t
  
  val mult : t -> t -> t
  
  val max : t -> t -> t
  
  val gt_le_dec : t -> t -> sumbool
  
  val ge_lt_dec : t -> t -> sumbool
  
  val eq_dec : t -> t -> sumbool
 end

module Z_as_Int = 
 struct 
  type t = z
  
  (** val _0 : z **)
  
  let _0 =
    Z0
  
  (** val _1 : z **)
  
  let _1 =
    Zpos XH
  
  (** val _2 : z **)
  
  let _2 =
    Zpos (XO XH)
  
  (** val _3 : z **)
  
  let _3 =
    Zpos (XI XH)
  
  (** val plus : z -> z -> z **)
  
  let plus =
    Z.add
  
  (** val opp : z -> z **)
  
  let opp =
    Z.opp
  
  (** val minus : z -> z -> z **)
  
  let minus =
    Z.sub
  
  (** val mult : z -> z -> z **)
  
  let mult =
    Z.mul
  
  (** val max : z -> z -> z **)
  
  let max =
    Z.max
  
  (** val gt_le_dec : z -> z -> sumbool **)
  
  let gt_le_dec =
    z_gt_le_dec
  
  (** val ge_lt_dec : z -> z -> sumbool **)
  
  let ge_lt_dec =
    z_ge_lt_dec
  
  (** val eq_dec : z -> z -> sumbool **)
  
  let eq_dec =
    Z.eq_dec
  
  (** val i2z : t -> z **)
  
  let i2z n0 =
    n0
 end

module MakeRaw = 
 functor (I:Coq_Int) ->
 functor (X:OrderedType) ->
 struct 
  type elt = X.t
  
  type tree =
  | Leaf
  | Node of I.t * tree * X.t * tree
  
  (** val empty : tree **)
  
  let empty =
    Leaf
  
  (** val is_empty : tree -> bool **)
  
  let is_empty = function
  | Leaf -> True
  | Node (t2, t3, t4, t5) -> False
  
  (** val mem : X.t -> tree -> bool **)
  
  let rec mem x = function
  | Leaf -> False
  | Node (t2, l, k, r) ->
    (match X.compare x k with
     | Eq -> True
     | Lt -> mem x l
     | Gt -> mem x r)
  
  (** val min_elt : tree -> elt option **)
  
  let rec min_elt = function
  | Leaf -> None
  | Node (t2, l, x, r) ->
    (match l with
     | Leaf -> Some x
     | Node (t3, t4, t5, t6) -> min_elt l)
  
  (** val max_elt : tree -> elt option **)
  
  let rec max_elt = function
  | Leaf -> None
  | Node (t2, l, x, r) ->
    (match r with
     | Leaf -> Some x
     | Node (t3, t4, t5, t6) -> max_elt r)
  
  (** val choose : tree -> elt option **)
  
  let choose =
    min_elt
  
  (** val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1 **)
  
  let rec fold f t1 base =
    match t1 with
    | Leaf -> base
    | Node (t2, l, x, r) -> fold f r (f x (fold f l base))
  
  (** val elements_aux : X.t list -> tree -> X.t list **)
  
  let rec elements_aux acc = function
  | Leaf -> acc
  | Node (t1, l, x, r) -> elements_aux (Cons (x, (elements_aux acc r))) l
  
  (** val elements : tree -> X.t list **)
  
  let elements =
    elements_aux Nil
  
  (** val rev_elements_aux : X.t list -> tree -> X.t list **)
  
  let rec rev_elements_aux acc = function
  | Leaf -> acc
  | Node (t1, l, x, r) ->
    rev_elements_aux (Cons (x, (rev_elements_aux acc l))) r
  
  (** val rev_elements : tree -> X.t list **)
  
  let rev_elements =
    rev_elements_aux Nil
  
  (** val cardinal : tree -> nat **)
  
  let rec cardinal = function
  | Leaf -> O
  | Node (t1, l, t2, r) -> S (plus (cardinal l) (cardinal r))
  
  (** val maxdepth : tree -> nat **)
  
  let rec maxdepth = function
  | Leaf -> O
  | Node (t1, l, t2, r) -> S (max (maxdepth l) (maxdepth r))
  
  (** val mindepth : tree -> nat **)
  
  let rec mindepth = function
  | Leaf -> O
  | Node (t1, l, t2, r) -> S (min (mindepth l) (mindepth r))
  
  (** val for_all : (elt -> bool) -> tree -> bool **)
  
  let rec for_all f = function
  | Leaf -> True
  | Node (t1, l, x, r) ->
    (match match f x with
           | True -> for_all f l
           | False -> False with
     | True -> for_all f r
     | False -> False)
  
  (** val exists_ : (elt -> bool) -> tree -> bool **)
  
  let rec exists_ f = function
  | Leaf -> False
  | Node (t1, l, x, r) ->
    (match match f x with
           | True -> True
           | False -> exists_ f l with
     | True -> True
     | False -> exists_ f r)
  
  type enumeration =
  | End
  | More of elt * tree * enumeration
  
  (** val cons : tree -> enumeration -> enumeration **)
  
  let rec cons s e =
    match s with
    | Leaf -> e
    | Node (t1, l, x, r) -> cons l (More (x, r, e))
  
  (** val compare_more :
      X.t -> (enumeration -> comparison) -> enumeration -> comparison **)
  
  let compare_more x1 cont = function
  | End -> Gt
  | More (x2, r2, e3) ->
    (match X.compare x1 x2 with
     | Eq -> cont (cons r2 e3)
     | x -> x)
  
  (** val compare_cont :
      tree -> (enumeration -> comparison) -> enumeration -> comparison **)
  
  let rec compare_cont s1 cont e2 =
    match s1 with
    | Leaf -> cont e2
    | Node (t1, l1, x1, r1) ->
      compare_cont l1 (compare_more x1 (compare_cont r1 cont)) e2
  
  (** val compare_end : enumeration -> comparison **)
  
  let compare_end = function
  | End -> Eq
  | More (e, t1, e0) -> Lt
  
  (** val compare : tree -> tree -> comparison **)
  
  let compare s1 s2 =
    compare_cont s1 compare_end (cons s2 End)
  
  (** val equal : tree -> tree -> bool **)
  
  let equal s1 s2 =
    match compare s1 s2 with
    | Eq -> True
    | _ -> False
  
  (** val subsetl : (tree -> bool) -> X.t -> tree -> bool **)
  
  let rec subsetl subset_l1 x1 s2 = match s2 with
  | Leaf -> False
  | Node (t1, l2, x2, r2) ->
    (match X.compare x1 x2 with
     | Eq -> subset_l1 l2
     | Lt -> subsetl subset_l1 x1 l2
     | Gt ->
       (match mem x1 r2 with
        | True -> subset_l1 s2
        | False -> False))
  
  (** val subsetr : (tree -> bool) -> X.t -> tree -> bool **)
  
  let rec subsetr subset_r1 x1 s2 = match s2 with
  | Leaf -> False
  | Node (t1, l2, x2, r2) ->
    (match X.compare x1 x2 with
     | Eq -> subset_r1 r2
     | Lt ->
       (match mem x1 l2 with
        | True -> subset_r1 s2
        | False -> False)
     | Gt -> subsetr subset_r1 x1 r2)
  
  (** val subset : tree -> tree -> bool **)
  
  let rec subset s1 s2 =
    match s1 with
    | Leaf -> True
    | Node (t1, l1, x1, r1) ->
      (match s2 with
       | Leaf -> False
       | Node (t2, l2, x2, r2) ->
         (match X.compare x1 x2 with
          | Eq ->
            (match subset l1 l2 with
             | True -> subset r1 r2
             | False -> False)
          | Lt ->
            (match subsetl (subset l1) x1 l2 with
             | True -> subset r1 s2
             | False -> False)
          | Gt ->
            (match subsetr (subset r1) x1 r2 with
             | True -> subset l1 s2
             | False -> False)))
  
  type t = tree
  
  (** val height : t -> I.t **)
  
  let height = function
  | Leaf -> I._0
  | Node (h, t1, t2, t3) -> h
  
  (** val singleton : X.t -> tree **)
  
  let singleton x =
    Node (I._1, Leaf, x, Leaf)
  
  (** val create : t -> X.t -> t -> tree **)
  
  let create l x r =
    Node ((I.plus (I.max (height l) (height r)) I._1), l, x, r)
  
  (** val assert_false : t -> X.t -> t -> tree **)
  
  let assert_false =
    create
  
  (** val bal : t -> X.t -> t -> tree **)
  
  let bal l x r =
    let hl = height l in
    let hr = height r in
    (match I.gt_le_dec hl (I.plus hr I._2) with
     | Left ->
       (match l with
        | Leaf -> assert_false l x r
        | Node (t1, ll, lx, lr) ->
          (match I.ge_lt_dec (height ll) (height lr) with
           | Left -> create ll lx (create lr x r)
           | Right ->
             (match lr with
              | Leaf -> assert_false l x r
              | Node (t2, lrl, lrx, lrr) ->
                create (create ll lx lrl) lrx (create lrr x r))))
     | Right ->
       (match I.gt_le_dec hr (I.plus hl I._2) with
        | Left ->
          (match r with
           | Leaf -> assert_false l x r
           | Node (t1, rl, rx, rr) ->
             (match I.ge_lt_dec (height rr) (height rl) with
              | Left -> create (create l x rl) rx rr
              | Right ->
                (match rl with
                 | Leaf -> assert_false l x r
                 | Node (t2, rll, rlx, rlr) ->
                   create (create l x rll) rlx (create rlr rx rr))))
        | Right -> create l x r))
  
  (** val add : X.t -> tree -> tree **)
  
  let rec add x = function
  | Leaf -> Node (I._1, Leaf, x, Leaf)
  | Node (h, l, y, r) ->
    (match X.compare x y with
     | Eq -> Node (h, l, y, r)
     | Lt -> bal (add x l) y r
     | Gt -> bal l y (add x r))
  
  (** val join : tree -> elt -> t -> t **)
  
  let rec join l = match l with
  | Leaf -> add
  | Node (lh, ll, lx, lr) ->
    (fun x ->
      let rec join_aux r = match r with
      | Leaf -> add x l
      | Node (rh, rl, rx, rr) ->
        (match I.gt_le_dec lh (I.plus rh I._2) with
         | Left -> bal ll lx (join lr x r)
         | Right ->
           (match I.gt_le_dec rh (I.plus lh I._2) with
            | Left -> bal (join_aux rl) rx rr
            | Right -> create l x r))
      in join_aux)
  
  (** val remove_min : tree -> elt -> t -> (t, elt) prod **)
  
  let rec remove_min l x r =
    match l with
    | Leaf -> Pair (r, x)
    | Node (lh, ll, lx, lr) ->
      let Pair (l', m0) = remove_min ll lx lr in Pair ((bal l' x r), m0)
  
  (** val merge : tree -> tree -> tree **)
  
  let merge s1 s2 =
    match s1 with
    | Leaf -> s2
    | Node (t1, t2, t3, t4) ->
      (match s2 with
       | Leaf -> s1
       | Node (t5, l2, x2, r2) ->
         let Pair (s2', m0) = remove_min l2 x2 r2 in bal s1 m0 s2')
  
  (** val remove : X.t -> tree -> tree **)
  
  let rec remove x = function
  | Leaf -> Leaf
  | Node (t1, l, y, r) ->
    (match X.compare x y with
     | Eq -> merge l r
     | Lt -> bal (remove x l) y r
     | Gt -> bal l y (remove x r))
  
  (** val concat : tree -> tree -> tree **)
  
  let concat s1 s2 =
    match s1 with
    | Leaf -> s2
    | Node (t1, t2, t3, t4) ->
      (match s2 with
       | Leaf -> s1
       | Node (t5, l2, x2, r2) ->
         let Pair (s2', m0) = remove_min l2 x2 r2 in join s1 m0 s2')
  
  type triple = { t_left : t; t_in : bool; t_right : t }
  
  (** val t_left : triple -> t **)
  
  let t_left t1 =
    t1.t_left
  
  (** val t_in : triple -> bool **)
  
  let t_in t1 =
    t1.t_in
  
  (** val t_right : triple -> t **)
  
  let t_right t1 =
    t1.t_right
  
  (** val split : X.t -> tree -> triple **)
  
  let rec split x = function
  | Leaf -> { t_left = Leaf; t_in = False; t_right = Leaf }
  | Node (t1, l, y, r) ->
    (match X.compare x y with
     | Eq -> { t_left = l; t_in = True; t_right = r }
     | Lt ->
       let { t_left = ll; t_in = b; t_right = rl } = split x l in
       { t_left = ll; t_in = b; t_right = (join rl y r) }
     | Gt ->
       let { t_left = rl; t_in = b; t_right = rr } = split x r in
       { t_left = (join l y rl); t_in = b; t_right = rr })
  
  (** val inter : tree -> tree -> tree **)
  
  let rec inter s1 s2 =
    match s1 with
    | Leaf -> Leaf
    | Node (t1, l1, x1, r1) ->
      (match s2 with
       | Leaf -> Leaf
       | Node (t2, t3, t4, t5) ->
         let { t_left = l2'; t_in = pres; t_right = r2' } = split x1 s2 in
         (match pres with
          | True -> join (inter l1 l2') x1 (inter r1 r2')
          | False -> concat (inter l1 l2') (inter r1 r2')))
  
  (** val diff : tree -> tree -> tree **)
  
  let rec diff s1 s2 =
    match s1 with
    | Leaf -> Leaf
    | Node (t1, l1, x1, r1) ->
      (match s2 with
       | Leaf -> s1
       | Node (t2, t3, t4, t5) ->
         let { t_left = l2'; t_in = pres; t_right = r2' } = split x1 s2 in
         (match pres with
          | True -> concat (diff l1 l2') (diff r1 r2')
          | False -> join (diff l1 l2') x1 (diff r1 r2')))
  
  (** val union : tree -> tree -> tree **)
  
  let rec union s1 s2 =
    match s1 with
    | Leaf -> s2
    | Node (t1, l1, x1, r1) ->
      (match s2 with
       | Leaf -> s1
       | Node (t2, t3, t4, t5) ->
         let { t_left = l2'; t_in = x; t_right = r2' } = split x1 s2 in
         join (union l1 l2') x1 (union r1 r2'))
  
  (** val filter : (elt -> bool) -> tree -> tree **)
  
  let rec filter f = function
  | Leaf -> Leaf
  | Node (t1, l, x, r) ->
    let l' = filter f l in
    let r' = filter f r in
    (match f x with
     | True -> join l' x r'
     | False -> concat l' r')
  
  (** val partition : (elt -> bool) -> t -> (t, t) prod **)
  
  let rec partition f = function
  | Leaf -> Pair (Leaf, Leaf)
  | Node (t1, l, x, r) ->
    let Pair (l1, l2) = partition f l in
    let Pair (r1, r2) = partition f r in
    (match f x with
     | True -> Pair ((join l1 x r1), (concat l2 r2))
     | False -> Pair ((concat l1 r1), (join l2 x r2)))
  
  (** val ltb_tree : X.t -> tree -> bool **)
  
  let rec ltb_tree x = function
  | Leaf -> True
  | Node (t1, l, y, r) ->
    (match X.compare x y with
     | Gt ->
       (match ltb_tree x l with
        | True -> ltb_tree x r
        | False -> False)
     | _ -> False)
  
  (** val gtb_tree : X.t -> tree -> bool **)
  
  let rec gtb_tree x = function
  | Leaf -> True
  | Node (t1, l, y, r) ->
    (match X.compare x y with
     | Lt ->
       (match gtb_tree x l with
        | True -> gtb_tree x r
        | False -> False)
     | _ -> False)
  
  (** val isok : tree -> bool **)
  
  let rec isok = function
  | Leaf -> True
  | Node (t1, l, x, r) ->
    (match match match isok l with
                 | True -> isok r
                 | False -> False with
           | True -> ltb_tree x l
           | False -> False with
     | True -> gtb_tree x r
     | False -> False)
  
  module MX = OrderedTypeFacts(X)
  
  type coq_R_min_elt =
  | R_min_elt_0 of tree
  | R_min_elt_1 of tree * I.t * tree * X.t * tree
  | R_min_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_min_elt
  
  type coq_R_max_elt =
  | R_max_elt_0 of tree
  | R_max_elt_1 of tree * I.t * tree * X.t * tree
  | R_max_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_max_elt
  
  module L = MakeListOrdering(X)
  
  (** val flatten_e : enumeration -> elt list **)
  
  let rec flatten_e = function
  | End -> Nil
  | More (x, t1, r) -> Cons (x, (app (elements t1) (flatten_e r)))
  
  type coq_R_bal =
  | R_bal_0 of t * X.t * t
  | R_bal_1 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_2 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_3 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t
     * tree
  | R_bal_4 of t * X.t * t
  | R_bal_5 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_6 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_7 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t
     * tree
  | R_bal_8 of t * X.t * t
  
  type coq_R_remove_min =
  | R_remove_min_0 of tree * elt * t
  | R_remove_min_1 of tree * elt * t * I.t * tree * X.t * tree
     * (t, elt) prod * coq_R_remove_min * t * elt
  
  type coq_R_merge =
  | R_merge_0 of tree * tree
  | R_merge_1 of tree * tree * I.t * tree * X.t * tree
  | R_merge_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt
  
  type coq_R_concat =
  | R_concat_0 of tree * tree
  | R_concat_1 of tree * tree * I.t * tree * X.t * tree
  | R_concat_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt
  
  type coq_R_inter =
  | R_inter_0 of tree * tree
  | R_inter_1 of tree * tree * I.t * tree * X.t * tree
  | R_inter_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
  | R_inter_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
  
  type coq_R_diff =
  | R_diff_0 of tree * tree
  | R_diff_1 of tree * tree * I.t * tree * X.t * tree
  | R_diff_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
  | R_diff_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
  
  type coq_R_union =
  | R_union_0 of tree * tree
  | R_union_1 of tree * tree * I.t * tree * X.t * tree
  | R_union_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_union * tree * coq_R_union
 end

module IntMake = 
 functor (I:Coq_Int) ->
 functor (X:OrderedType) ->
 struct 
  module Raw = MakeRaw(I)(X)
  
  module E = 
   struct 
    type t = X.t
    
    (** val compare : t -> t -> comparison **)
    
    let compare =
      X.compare
    
    (** val eq_dec : t -> t -> sumbool **)
    
    let eq_dec =
      X.eq_dec
   end
  
  type elt = X.t
  
  type t_ =
    Raw.t
    (* singleton inductive, whose constructor was Mkt *)
  
  (** val this : t_ -> Raw.t **)
  
  let this t1 =
    t1
  
  type t = t_
  
  (** val mem : elt -> t -> bool **)
  
  let mem x s =
    Raw.mem x (this s)
  
  (** val add : elt -> t -> t **)
  
  let add x s =
    Raw.add x (this s)
  
  (** val remove : elt -> t -> t **)
  
  let remove x s =
    Raw.remove x (this s)
  
  (** val singleton : elt -> t **)
  
  let singleton x =
    Raw.singleton x
  
  (** val union : t -> t -> t **)
  
  let union s s' =
    Raw.union (this s) (this s')
  
  (** val inter : t -> t -> t **)
  
  let inter s s' =
    Raw.inter (this s) (this s')
  
  (** val diff : t -> t -> t **)
  
  let diff s s' =
    Raw.diff (this s) (this s')
  
  (** val equal : t -> t -> bool **)
  
  let equal s s' =
    Raw.equal (this s) (this s')
  
  (** val subset : t -> t -> bool **)
  
  let subset s s' =
    Raw.subset (this s) (this s')
  
  (** val empty : t **)
  
  let empty =
    Raw.empty
  
  (** val is_empty : t -> bool **)
  
  let is_empty s =
    Raw.is_empty (this s)
  
  (** val elements : t -> elt list **)
  
  let elements s =
    Raw.elements (this s)
  
  (** val choose : t -> elt option **)
  
  let choose s =
    Raw.choose (this s)
  
  (** val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1 **)
  
  let fold f s =
    Raw.fold f (this s)
  
  (** val cardinal : t -> nat **)
  
  let cardinal s =
    Raw.cardinal (this s)
  
  (** val filter : (elt -> bool) -> t -> t **)
  
  let filter f s =
    Raw.filter f (this s)
  
  (** val for_all : (elt -> bool) -> t -> bool **)
  
  let for_all f s =
    Raw.for_all f (this s)
  
  (** val exists_ : (elt -> bool) -> t -> bool **)
  
  let exists_ f s =
    Raw.exists_ f (this s)
  
  (** val partition : (elt -> bool) -> t -> (t, t) prod **)
  
  let partition f s =
    let p = Raw.partition f (this s) in Pair ((fst p), (snd p))
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec s s' =
    let b = Raw.equal s s' in
    (match b with
     | True -> Left
     | False -> Right)
  
  (** val compare : t -> t -> comparison **)
  
  let compare s s' =
    Raw.compare (this s) (this s')
  
  (** val min_elt : t -> elt option **)
  
  let min_elt s =
    Raw.min_elt (this s)
  
  (** val max_elt : t -> elt option **)
  
  let max_elt s =
    Raw.max_elt (this s)
 end

module Coq_IntMake = 
 functor (I:Coq_Int) ->
 functor (X:Coq_OrderedType) ->
 struct 
  module X' = Update_OT(X)
  
  module MSet = IntMake(I)(X')
  
  type elt = X.t
  
  type t = MSet.t
  
  (** val empty : t **)
  
  let empty =
    MSet.empty
  
  (** val is_empty : t -> bool **)
  
  let is_empty =
    MSet.is_empty
  
  (** val mem : elt -> t -> bool **)
  
  let mem =
    MSet.mem
  
  (** val add : elt -> t -> t **)
  
  let add =
    MSet.add
  
  (** val singleton : elt -> t **)
  
  let singleton =
    MSet.singleton
  
  (** val remove : elt -> t -> t **)
  
  let remove =
    MSet.remove
  
  (** val union : t -> t -> t **)
  
  let union =
    MSet.union
  
  (** val inter : t -> t -> t **)
  
  let inter =
    MSet.inter
  
  (** val diff : t -> t -> t **)
  
  let diff =
    MSet.diff
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    MSet.eq_dec
  
  (** val equal : t -> t -> bool **)
  
  let equal =
    MSet.equal
  
  (** val subset : t -> t -> bool **)
  
  let subset =
    MSet.subset
  
  (** val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1 **)
  
  let fold x x0 x1 =
    MSet.fold x x0 x1
  
  (** val for_all : (elt -> bool) -> t -> bool **)
  
  let for_all =
    MSet.for_all
  
  (** val exists_ : (elt -> bool) -> t -> bool **)
  
  let exists_ =
    MSet.exists_
  
  (** val filter : (elt -> bool) -> t -> t **)
  
  let filter =
    MSet.filter
  
  (** val partition : (elt -> bool) -> t -> (t, t) prod **)
  
  let partition =
    MSet.partition
  
  (** val cardinal : t -> nat **)
  
  let cardinal =
    MSet.cardinal
  
  (** val elements : t -> elt list **)
  
  let elements =
    MSet.elements
  
  (** val choose : t -> elt option **)
  
  let choose =
    MSet.choose
  
  module MF = 
   struct 
    (** val eqb : X.t -> X.t -> bool **)
    
    let eqb x y =
      match MSet.E.eq_dec x y with
      | Left -> True
      | Right -> False
   end
  
  (** val min_elt : t -> elt option **)
  
  let min_elt =
    MSet.min_elt
  
  (** val max_elt : t -> elt option **)
  
  let max_elt =
    MSet.max_elt
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare s s' =
    let c = compSpec2Type s s' (MSet.compare s s') in
    (match c with
     | CompEqT -> EQ
     | CompLtT -> LT
     | CompGtT -> GT)
  
  module E = 
   struct 
    type t = X.t
    
    (** val compare : t -> t -> t compare0 **)
    
    let compare =
      X.compare
    
    (** val eq_dec : t -> t -> sumbool **)
    
    let eq_dec =
      X.eq_dec
   end
 end

module Coq_Make = 
 functor (X:Coq_OrderedType) ->
 Coq_IntMake(Z_as_Int)(X)

module OrderedPositive = 
 struct 
  type t = positive
  
  (** val compare : t -> t -> positive compare0 **)
  
  let compare x y =
    let c = Coq_Pos.compare x y in
    (match c with
     | Eq -> EQ
     | Lt -> LT
     | Gt -> GT)
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    peq
 end

module OrderedZ = 
 struct 
  type t = z
  
  (** val compare : t -> t -> z compare0 **)
  
  let compare x y =
    let c = Z.compare x y in
    (match c with
     | Eq -> EQ
     | Lt -> LT
     | Gt -> GT)
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    zeq
 end

module OrderedIndexed = 
 functor (A:INDEXED_TYPE) ->
 struct 
  type t = A.t
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare x y =
    match OrderedPositive.compare (A.index x) (A.index y) with
    | LT -> LT
    | EQ -> EQ
    | GT -> GT
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec x y =
    peq (A.index x) (A.index y)
 end

type reg = positive

module Reg = 
 struct 
  (** val eq : positive -> positive -> sumbool **)
  
  let eq =
    peq
  
  type typenv = typ PMap.t
 end

module Regset = Coq_Make(OrderedPositive)

type node = positive

type instruction =
| Inop of node
| Iop of operation * reg list * reg * node
| Iload of memory_chunk * addressing * reg list * reg * node
| Istore of memory_chunk * addressing * reg list * reg * node
| Icall of signature * (reg, ident) sum * reg list * reg * node
| Itailcall of signature * (reg, ident) sum * reg list
| Ibuiltin of external_function * reg builtin_arg list * reg builtin_res
   * node
| Icond of condition * reg list * node * node
| Ijumptable of reg * node list
| Ireturn of reg option

type code = instruction PTree.t

type function4 = { fn_sig2 : signature; fn_params3 : reg list;
                   fn_stacksize : z; fn_code : code; fn_entrypoint : 
                   node }

(** val fn_sig2 : function4 -> signature **)

let fn_sig2 x = x.fn_sig2

(** val fn_params3 : function4 -> reg list **)

let fn_params3 x = x.fn_params3

(** val fn_stacksize : function4 -> z **)

let fn_stacksize x = x.fn_stacksize

(** val fn_code : function4 -> code **)

let fn_code x = x.fn_code

(** val fn_entrypoint : function4 -> node **)

let fn_entrypoint x = x.fn_entrypoint

type fundef4 = function4 fundef

type program4 = (fundef4, unit0) program

(** val transf_function :
    (node -> instruction -> instruction) -> function4 -> function4 **)

let transf_function transf f =
  { fn_sig2 = f.fn_sig2; fn_params3 = f.fn_params3; fn_stacksize =
    f.fn_stacksize; fn_code = (PTree.map transf f.fn_code); fn_entrypoint =
    f.fn_entrypoint }

(** val successors_instr : instruction -> node list **)

let successors_instr = function
| Inop s -> Cons (s, Nil)
| Iop (op, args, res2, s) -> Cons (s, Nil)
| Iload (chunk, addr, args, dst, s) -> Cons (s, Nil)
| Istore (chunk, addr, args, src, s) -> Cons (s, Nil)
| Icall (sig1, ros, args, res2, s) -> Cons (s, Nil)
| Ibuiltin (ef, args, res2, s) -> Cons (s, Nil)
| Icond (cond, args, ifso, ifnot) -> Cons (ifso, (Cons (ifnot, Nil)))
| Ijumptable (arg, tbl) -> tbl
| _ -> Nil

(** val successors_map : function4 -> node list PTree.t **)

let successors_map f =
  PTree.map1 successors_instr f.fn_code

(** val instr_uses : instruction -> reg list **)

let instr_uses = function
| Inop s -> Nil
| Iop (op, args, res2, s) -> args
| Iload (chunk, addr, args, dst, s) -> args
| Istore (chunk, addr, args, src, s) -> Cons (src, args)
| Icall (sig1, s0, args, res2, s) ->
  (match s0 with
   | Inl r -> Cons (r, args)
   | Inr id -> args)
| Itailcall (sig1, s, args) ->
  (match s with
   | Inl r -> Cons (r, args)
   | Inr id -> args)
| Ibuiltin (ef, args, res2, s) -> params_of_builtin_args args
| Icond (cond, args, ifso, ifnot) -> args
| Ijumptable (arg, tbl) -> Cons (arg, Nil)
| Ireturn o ->
  (match o with
   | Some arg -> Cons (arg, Nil)
   | None -> Nil)

(** val instr_defs : instruction -> reg option **)

let instr_defs = function
| Iop (op, args, res2, s) -> Some res2
| Iload (chunk, addr, args, dst, s) -> Some dst
| Icall (sig1, ros, args, res2, s) -> Some res2
| Ibuiltin (ef, args, res2, s) ->
  (match res2 with
   | BR r -> Some r
   | _ -> None)
| _ -> None

(** val max_pc_function : function4 -> positive **)

let max_pc_function f =
  PTree.fold (fun m0 pc i -> Coq_Pos.max m0 pc) f.fn_code XH

(** val max_reg_instr : positive -> node -> instruction -> positive **)

let max_reg_instr m0 pc = function
| Inop s -> m0
| Iop (op, args, res2, s) -> fold_left Coq_Pos.max args (Coq_Pos.max res2 m0)
| Iload (chunk, addr, args, dst, s) ->
  fold_left Coq_Pos.max args (Coq_Pos.max dst m0)
| Istore (chunk, addr, args, src, s) ->
  fold_left Coq_Pos.max args (Coq_Pos.max src m0)
| Icall (sig1, s0, args, res2, s) ->
  (match s0 with
   | Inl r ->
     fold_left Coq_Pos.max args (Coq_Pos.max r (Coq_Pos.max res2 m0))
   | Inr id -> fold_left Coq_Pos.max args (Coq_Pos.max res2 m0))
| Itailcall (sig1, s, args) ->
  (match s with
   | Inl r -> fold_left Coq_Pos.max args (Coq_Pos.max r m0)
   | Inr id -> fold_left Coq_Pos.max args m0)
| Ibuiltin (ef, args, res2, s) ->
  fold_left Coq_Pos.max (params_of_builtin_args args)
    (fold_left Coq_Pos.max (params_of_builtin_res res2) m0)
| Icond (cond, args, ifso, ifnot) -> fold_left Coq_Pos.max args m0
| Ijumptable (arg, tbl) -> Coq_Pos.max arg m0
| Ireturn o ->
  (match o with
   | Some arg -> Coq_Pos.max arg m0
   | None -> m0)

(** val max_reg_function : function4 -> positive **)

let max_reg_function f =
  Coq_Pos.max (PTree.fold max_reg_instr f.fn_code XH)
    (fold_left Coq_Pos.max f.fn_params3 XH)

type mreg =
| AX
| BX
| CX
| DX
| SI
| DI
| BP
| X0
| X1
| X2
| X3
| X4
| X5
| X6
| X7
| FP0

(** val mreg_eq : mreg -> mreg -> sumbool **)

let mreg_eq r1 r2 =
  match r1 with
  | AX ->
    (match r2 with
     | AX -> Left
     | _ -> Right)
  | BX ->
    (match r2 with
     | BX -> Left
     | _ -> Right)
  | CX ->
    (match r2 with
     | CX -> Left
     | _ -> Right)
  | DX ->
    (match r2 with
     | DX -> Left
     | _ -> Right)
  | SI ->
    (match r2 with
     | SI -> Left
     | _ -> Right)
  | DI ->
    (match r2 with
     | DI -> Left
     | _ -> Right)
  | BP ->
    (match r2 with
     | BP -> Left
     | _ -> Right)
  | X0 ->
    (match r2 with
     | X0 -> Left
     | _ -> Right)
  | X1 ->
    (match r2 with
     | X1 -> Left
     | _ -> Right)
  | X2 ->
    (match r2 with
     | X2 -> Left
     | _ -> Right)
  | X3 ->
    (match r2 with
     | X3 -> Left
     | _ -> Right)
  | X4 ->
    (match r2 with
     | X4 -> Left
     | _ -> Right)
  | X5 ->
    (match r2 with
     | X5 -> Left
     | _ -> Right)
  | X6 ->
    (match r2 with
     | X6 -> Left
     | _ -> Right)
  | X7 ->
    (match r2 with
     | X7 -> Left
     | _ -> Right)
  | FP0 ->
    (match r2 with
     | FP0 -> Left
     | _ -> Right)

(** val mreg_type : mreg -> typ **)

let mreg_type = function
| AX -> Tany32
| BX -> Tany32
| CX -> Tany32
| DX -> Tany32
| SI -> Tany32
| DI -> Tany32
| BP -> Tany32
| _ -> Tany64

module IndexedMreg = 
 struct 
  type t = mreg
  
  (** val eq : mreg -> mreg -> sumbool **)
  
  let eq =
    mreg_eq
  
  (** val index : mreg -> positive **)
  
  let index = function
  | AX -> XH
  | BX -> XO XH
  | CX -> XI XH
  | DX -> XO (XO XH)
  | SI -> XI (XO XH)
  | DI -> XO (XI XH)
  | BP -> XI (XI XH)
  | X0 -> XO (XO (XO XH))
  | X1 -> XI (XO (XO XH))
  | X2 -> XO (XI (XO XH))
  | X3 -> XI (XI (XO XH))
  | X4 -> XO (XO (XI XH))
  | X5 -> XI (XO (XI XH))
  | X6 -> XO (XI (XI XH))
  | X7 -> XI (XI (XI XH))
  | FP0 -> XO (XO (XO (XO XH)))
 end

(** val register_names : (string, mreg) prod list **)

let register_names =
  Cons ((Pair ((String ((Ascii (True, False, True, False, False, False, True,
    False)), (String ((Ascii (True, False, False, False, False, False, True,
    False)), (String ((Ascii (False, False, False, True, True, False, True,
    False)), EmptyString)))))), AX)), (Cons ((Pair ((String ((Ascii (True,
    False, True, False, False, False, True, False)), (String ((Ascii (False,
    True, False, False, False, False, True, False)), (String ((Ascii (False,
    False, False, True, True, False, True, False)), EmptyString)))))), BX)),
    (Cons ((Pair ((String ((Ascii (True, False, True, False, False, False,
    True, False)), (String ((Ascii (True, True, False, False, False, False,
    True, False)), (String ((Ascii (False, False, False, True, True, False,
    True, False)), EmptyString)))))), CX)), (Cons ((Pair ((String ((Ascii
    (True, False, True, False, False, False, True, False)), (String ((Ascii
    (False, False, True, False, False, False, True, False)), (String ((Ascii
    (False, False, False, True, True, False, True, False)),
    EmptyString)))))), DX)), (Cons ((Pair ((String ((Ascii (True, False,
    True, False, False, False, True, False)), (String ((Ascii (True, True,
    False, False, True, False, True, False)), (String ((Ascii (True, False,
    False, True, False, False, True, False)), EmptyString)))))), SI)), (Cons
    ((Pair ((String ((Ascii (True, False, True, False, False, False, True,
    False)), (String ((Ascii (False, False, True, False, False, False, True,
    False)), (String ((Ascii (True, False, False, True, False, False, True,
    False)), EmptyString)))))), DI)), (Cons ((Pair ((String ((Ascii (True,
    False, True, False, False, False, True, False)), (String ((Ascii (False,
    True, False, False, False, False, True, False)), (String ((Ascii (False,
    False, False, False, True, False, True, False)), EmptyString)))))), BP)),
    (Cons ((Pair ((String ((Ascii (False, False, False, True, True, False,
    True, False)), (String ((Ascii (True, False, True, True, False, False,
    True, False)), (String ((Ascii (True, False, True, True, False, False,
    True, False)), (String ((Ascii (False, False, False, False, True, True,
    False, False)), EmptyString)))))))), X0)), (Cons ((Pair ((String ((Ascii
    (False, False, False, True, True, False, True, False)), (String ((Ascii
    (True, False, True, True, False, False, True, False)), (String ((Ascii
    (True, False, True, True, False, False, True, False)), (String ((Ascii
    (True, False, False, False, True, True, False, False)),
    EmptyString)))))))), X1)), (Cons ((Pair ((String ((Ascii (False, False,
    False, True, True, False, True, False)), (String ((Ascii (True, False,
    True, True, False, False, True, False)), (String ((Ascii (True, False,
    True, True, False, False, True, False)), (String ((Ascii (False, True,
    False, False, True, True, False, False)), EmptyString)))))))), X2)),
    (Cons ((Pair ((String ((Ascii (False, False, False, True, True, False,
    True, False)), (String ((Ascii (True, False, True, True, False, False,
    True, False)), (String ((Ascii (True, False, True, True, False, False,
    True, False)), (String ((Ascii (True, True, False, False, True, True,
    False, False)), EmptyString)))))))), X3)), (Cons ((Pair ((String ((Ascii
    (False, False, False, True, True, False, True, False)), (String ((Ascii
    (True, False, True, True, False, False, True, False)), (String ((Ascii
    (True, False, True, True, False, False, True, False)), (String ((Ascii
    (False, False, True, False, True, True, False, False)),
    EmptyString)))))))), X4)), (Cons ((Pair ((String ((Ascii (False, False,
    False, True, True, False, True, False)), (String ((Ascii (True, False,
    True, True, False, False, True, False)), (String ((Ascii (True, False,
    True, True, False, False, True, False)), (String ((Ascii (True, False,
    True, False, True, True, False, False)), EmptyString)))))))), X5)), (Cons
    ((Pair ((String ((Ascii (False, False, False, True, True, False, True,
    False)), (String ((Ascii (True, False, True, True, False, False, True,
    False)), (String ((Ascii (True, False, True, True, False, False, True,
    False)), (String ((Ascii (False, True, True, False, True, True, False,
    False)), EmptyString)))))))), X6)), (Cons ((Pair ((String ((Ascii (False,
    False, False, True, True, False, True, False)), (String ((Ascii (True,
    False, True, True, False, False, True, False)), (String ((Ascii (True,
    False, True, True, False, False, True, False)), (String ((Ascii (True,
    True, True, False, True, True, False, False)), EmptyString)))))))), X7)),
    (Cons ((Pair ((String ((Ascii (True, True, False, False, True, False,
    True, False)), (String ((Ascii (False, False, True, False, True, False,
    True, False)), (String ((Ascii (False, False, False, False, True, True,
    False, False)), EmptyString)))))), FP0)),
    Nil)))))))))))))))))))))))))))))))

(** val register_by_name : string -> mreg option **)

let register_by_name s =
  let rec assoc = function
  | Nil -> None
  | Cons (p, l') ->
    let Pair (s1, r1) = p in
    (match string_dec s s1 with
     | Left -> Some r1
     | Right -> assoc l')
  in assoc register_names

(** val destroyed_by_op : operation -> mreg list **)

let destroyed_by_op = function
| Ocast8signed0 -> Cons (AX, Nil)
| Ocast8unsigned0 -> Cons (AX, Nil)
| Ocast16signed0 -> Cons (AX, Nil)
| Ocast16unsigned0 -> Cons (AX, Nil)
| Omulhs -> Cons (AX, (Cons (DX, Nil)))
| Omulhu -> Cons (AX, (Cons (DX, Nil)))
| Odiv1 -> Cons (AX, (Cons (DX, Nil)))
| Odivu0 -> Cons (AX, (Cons (DX, Nil)))
| Omod1 -> Cons (AX, (Cons (DX, Nil)))
| Omodu0 -> Cons (AX, (Cons (DX, Nil)))
| Oshrximm i -> Cons (CX, Nil)
| Ocmp0 c -> Cons (AX, (Cons (CX, Nil)))
| _ -> Nil

(** val destroyed_by_load : memory_chunk -> addressing -> mreg list **)

let destroyed_by_load chunk addr =
  Nil

(** val destroyed_by_store : memory_chunk -> addressing -> mreg list **)

let destroyed_by_store chunk addr =
  match chunk with
  | Mint8signed -> Cons (AX, (Cons (CX, Nil)))
  | Mint8unsigned -> Cons (AX, (Cons (CX, Nil)))
  | _ -> Nil

(** val destroyed_by_cond : condition -> mreg list **)

let destroyed_by_cond cond =
  Nil

(** val destroyed_by_jumptable : mreg list **)

let destroyed_by_jumptable =
  Nil

(** val destroyed_by_clobber : string list -> mreg list **)

let rec destroyed_by_clobber = function
| Nil -> Nil
| Cons (c1, cl0) ->
  (match register_by_name c1 with
   | Some r -> Cons (r, (destroyed_by_clobber cl0))
   | None -> destroyed_by_clobber cl0)

(** val destroyed_by_builtin : external_function -> mreg list **)

let destroyed_by_builtin = function
| EF_builtin (name, sg) ->
  (match match proj_sumbool
                 (string_dec name (String ((Ascii (True, True, True, True,
                   True, False, True, False)), (String ((Ascii (True, True,
                   True, True, True, False, True, False)), (String ((Ascii
                   (False, True, False, False, False, True, True, False)),
                   (String ((Ascii (True, False, True, False, True, True,
                   True, False)), (String ((Ascii (True, False, False, True,
                   False, True, True, False)), (String ((Ascii (False, False,
                   True, True, False, True, True, False)), (String ((Ascii
                   (False, False, True, False, True, True, True, False)),
                   (String ((Ascii (True, False, False, True, False, True,
                   True, False)), (String ((Ascii (False, True, True, True,
                   False, True, True, False)), (String ((Ascii (True, True,
                   True, True, True, False, True, False)), (String ((Ascii
                   (True, True, True, False, True, True, True, False)),
                   (String ((Ascii (False, True, False, False, True, True,
                   True, False)), (String ((Ascii (True, False, False, True,
                   False, True, True, False)), (String ((Ascii (False, False,
                   True, False, True, True, True, False)), (String ((Ascii
                   (True, False, True, False, False, True, True, False)),
                   (String ((Ascii (True, False, False, False, True, True,
                   False, False)), (String ((Ascii (False, True, True, False,
                   True, True, False, False)), (String ((Ascii (True, True,
                   True, True, True, False, True, False)), (String ((Ascii
                   (False, True, False, False, True, True, True, False)),
                   (String ((Ascii (True, False, True, False, False, True,
                   True, False)), (String ((Ascii (False, True, True, False,
                   True, True, True, False)), (String ((Ascii (True, False,
                   True, False, False, True, True, False)), (String ((Ascii
                   (False, True, False, False, True, True, True, False)),
                   (String ((Ascii (True, True, False, False, True, True,
                   True, False)), (String ((Ascii (True, False, True, False,
                   False, True, True, False)), (String ((Ascii (False, False,
                   True, False, False, True, True, False)),
                   EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))) with
         | True -> True
         | False ->
           proj_sumbool
             (string_dec name (String ((Ascii (True, True, True, True, True,
               False, True, False)), (String ((Ascii (True, True, True, True,
               True, False, True, False)), (String ((Ascii (False, True,
               False, False, False, True, True, False)), (String ((Ascii
               (True, False, True, False, True, True, True, False)), (String
               ((Ascii (True, False, False, True, False, True, True, False)),
               (String ((Ascii (False, False, True, True, False, True, True,
               False)), (String ((Ascii (False, False, True, False, True,
               True, True, False)), (String ((Ascii (True, False, False,
               True, False, True, True, False)), (String ((Ascii (False,
               True, True, True, False, True, True, False)), (String ((Ascii
               (True, True, True, True, True, False, True, False)), (String
               ((Ascii (True, True, True, False, True, True, True, False)),
               (String ((Ascii (False, True, False, False, True, True, True,
               False)), (String ((Ascii (True, False, False, True, False,
               True, True, False)), (String ((Ascii (False, False, True,
               False, True, True, True, False)), (String ((Ascii (True,
               False, True, False, False, True, True, False)), (String
               ((Ascii (True, True, False, False, True, True, False, False)),
               (String ((Ascii (False, True, False, False, True, True, False,
               False)), (String ((Ascii (True, True, True, True, True, False,
               True, False)), (String ((Ascii (False, True, False, False,
               True, True, True, False)), (String ((Ascii (True, False, True,
               False, False, True, True, False)), (String ((Ascii (False,
               True, True, False, True, True, True, False)), (String ((Ascii
               (True, False, True, False, False, True, True, False)), (String
               ((Ascii (False, True, False, False, True, True, True, False)),
               (String ((Ascii (True, True, False, False, True, True, True,
               False)), (String ((Ascii (True, False, True, False, False,
               True, True, False)), (String ((Ascii (False, False, True,
               False, False, True, True, False)),
               EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))) with
   | True -> Cons (CX, (Cons (DX, Nil)))
   | False -> Nil)
| EF_vstore chunk ->
  (match chunk with
   | Mint8signed -> Cons (AX, (Cons (CX, Nil)))
   | Mint8unsigned -> Cons (AX, (Cons (CX, Nil)))
   | _ -> Nil)
| EF_memcpy (sz, al) ->
  (match zle sz (Zpos (XO (XO (XO (XO (XO XH)))))) with
   | Left -> Cons (CX, (Cons (X7, Nil)))
   | Right -> Cons (CX, (Cons (SI, (Cons (DI, Nil))))))
| EF_inline_asm (txt, sg, clob) -> destroyed_by_clobber clob
| _ -> Nil

(** val destroyed_at_function_entry : mreg list **)

let destroyed_at_function_entry =
  Cons (DX, (Cons (FP0, Nil)))

(** val destroyed_by_setstack : typ -> mreg list **)

let destroyed_by_setstack = function
| Tfloat -> Cons (FP0, Nil)
| Tsingle -> Cons (FP0, Nil)
| _ -> Nil

(** val temp_for_parent_frame : mreg **)

let temp_for_parent_frame =
  DX

(** val builtin_constraints :
    external_function -> builtin_arg_constraint list **)

let builtin_constraints = function
| EF_vload chunk -> Cons (OK_addrany, Nil)
| EF_vstore chunk -> Cons (OK_addrany, (Cons (OK_default, Nil)))
| EF_memcpy (sz, al) -> Cons (OK_addrany, (Cons (OK_addrany, Nil)))
| EF_annot (txt, targs) -> map (fun x -> OK_all) targs
| EF_debug (kind, txt, targs) -> map (fun x -> OK_all) targs
| _ -> Nil

type slot =
| Local
| Incoming
| Outgoing

(** val slot_eq : slot -> slot -> sumbool **)

let slot_eq p q =
  match p with
  | Local ->
    (match q with
     | Local -> Left
     | _ -> Right)
  | Incoming ->
    (match q with
     | Incoming -> Left
     | _ -> Right)
  | Outgoing ->
    (match q with
     | Outgoing -> Left
     | _ -> Right)

(** val typesize : typ -> z **)

let typesize = function
| Tfloat -> Zpos (XO XH)
| Tlong -> Zpos (XO XH)
| Tany64 -> Zpos (XO XH)
| _ -> Zpos XH

type loc =
| R of mreg
| S0 of slot * z * typ

module Loc = 
 struct 
  (** val coq_type : loc -> typ **)
  
  let coq_type = function
  | R r -> mreg_type r
  | S0 (sl, pos, ty) -> ty
  
  (** val eq : loc -> loc -> sumbool **)
  
  let eq p q =
    match p with
    | R x ->
      (match q with
       | R r0 -> mreg_eq x r0
       | S0 (sl, pos, ty) -> Right)
    | S0 (x, x0, x1) ->
      (match q with
       | R r -> Right
       | S0 (sl0, pos0, ty0) ->
         (match slot_eq x sl0 with
          | Left ->
            (match zeq x0 pos0 with
             | Left -> typ_eq x1 ty0
             | Right -> Right)
          | Right -> Right))
  
  (** val diff_dec : loc -> loc -> sumbool **)
  
  let diff_dec l1 l2 =
    match l1 with
    | R r ->
      (match l2 with
       | R r0 ->
         let s = mreg_eq r r0 in
         (match s with
          | Left -> Right
          | Right -> Left)
       | S0 (sl, pos, ty) -> Left)
    | S0 (sl, pos, ty) ->
      (match l2 with
       | R r -> Left
       | S0 (sl0, pos0, ty0) ->
         let s = slot_eq sl sl0 in
         (match s with
          | Left ->
            let s0 = zle (Z.add pos (typesize ty)) pos0 in
            (match s0 with
             | Left -> Left
             | Right -> zle (Z.add pos0 (typesize ty0)) pos)
          | Right -> Left))
  
  (** val notin_dec : loc -> loc list -> sumbool **)
  
  let rec notin_dec l = function
  | Nil -> Left
  | Cons (y, l0) ->
    let s = diff_dec l y in
    (match s with
     | Left -> notin_dec l l0
     | Right -> Right)
  
  (** val norepet_dec : loc list -> sumbool **)
  
  let rec norepet_dec = function
  | Nil -> Left
  | Cons (y, l0) ->
    let s = notin_dec y l0 in
    (match s with
     | Left -> norepet_dec l0
     | Right -> Right)
 end

module IndexedTyp = 
 struct 
  type t = typ
  
  (** val index : t -> positive **)
  
  let index = function
  | Tint -> XO XH
  | Tfloat -> XI (XO XH)
  | Tlong -> XO (XI XH)
  | Tsingle -> XI XH
  | Tany32 -> XH
  | Tany64 -> XO (XO XH)
  
  (** val eq : typ -> typ -> sumbool **)
  
  let eq =
    typ_eq
 end

module OrderedTyp = OrderedIndexed(IndexedTyp)

module IndexedSlot = 
 struct 
  type t = slot
  
  (** val index : t -> positive **)
  
  let index = function
  | Local -> XH
  | Incoming -> XO XH
  | Outgoing -> XI XH
  
  (** val eq : slot -> slot -> sumbool **)
  
  let eq =
    slot_eq
 end

module OrderedSlot = OrderedIndexed(IndexedSlot)

module OrderedLoc = 
 struct 
  type t = loc
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare x y =
    match x with
    | R r ->
      (match y with
       | R r0 ->
         let c =
           OrderedPositive.compare (IndexedMreg.index r)
             (IndexedMreg.index r0)
         in
         (match c with
          | LT -> LT
          | EQ -> EQ
          | GT -> GT)
       | S0 (sl, pos, ty) -> LT)
    | S0 (sl, pos, ty) ->
      (match y with
       | R r -> GT
       | S0 (sl0, pos0, ty0) ->
         let c = OrderedSlot.compare sl sl0 in
         (match c with
          | LT -> LT
          | EQ ->
            let c0 = OrderedZ.compare pos pos0 in
            (match c0 with
             | LT -> LT
             | EQ ->
               let c1 = OrderedTyp.compare ty ty0 in
               (match c1 with
                | LT -> LT
                | EQ -> EQ
                | GT -> GT)
             | GT -> GT)
          | GT -> GT))
  
  (** val eq_dec : loc -> loc -> sumbool **)
  
  let eq_dec =
    Loc.eq
  
  (** val diff_low_bound : loc -> loc **)
  
  let diff_low_bound l = match l with
  | R mr -> l
  | S0 (sl, ofs, ty) -> S0 (sl, (Z.sub ofs (Zpos XH)), Tany64)
  
  (** val diff_high_bound : loc -> loc **)
  
  let diff_high_bound l = match l with
  | R mr -> l
  | S0 (sl, ofs, ty) ->
    S0 (sl, (Z.sub (Z.add ofs (typesize ty)) (Zpos XH)), Tlong)
 end

(** val int_caller_save_regs : mreg list **)

let int_caller_save_regs =
  Cons (AX, (Cons (CX, (Cons (DX, Nil)))))

(** val float_caller_save_regs : mreg list **)

let float_caller_save_regs =
  Cons (X0, (Cons (X1, (Cons (X2, (Cons (X3, (Cons (X4, (Cons (X5, (Cons (X6,
    (Cons (X7, Nil)))))))))))))))

(** val int_callee_save_regs : mreg list **)

let int_callee_save_regs =
  Cons (BX, (Cons (SI, (Cons (DI, (Cons (BP, Nil)))))))

(** val float_callee_save_regs : mreg list **)

let float_callee_save_regs =
  Nil

(** val destroyed_at_call : mreg list **)

let destroyed_at_call =
  Cons (FP0, (app int_caller_save_regs float_caller_save_regs))

(** val index_int_callee_save : mreg -> z **)

let index_int_callee_save = function
| BX -> Z0
| SI -> Zpos XH
| DI -> Zpos (XO XH)
| BP -> Zpos (XI XH)
| _ -> Zneg XH

(** val index_float_callee_save : mreg -> z **)

let index_float_callee_save r =
  Zneg XH

(** val loc_result : signature -> mreg list **)

let loc_result s =
  match s.sig_res with
  | Some t1 ->
    (match t1 with
     | Tint -> Cons (AX, Nil)
     | Tlong -> Cons (DX, (Cons (AX, Nil)))
     | Tany32 -> Cons (AX, Nil)
     | Tany64 -> Cons (X0, Nil)
     | _ -> Cons (FP0, Nil))
  | None -> Cons (AX, Nil)

(** val loc_arguments_rec : typ list -> z -> loc list **)

let rec loc_arguments_rec tyl ofs =
  match tyl with
  | Nil -> Nil
  | Cons (t1, tys) ->
    (match t1 with
     | Tfloat ->
       Cons ((S0 (Outgoing, ofs, Tfloat)),
         (loc_arguments_rec tys (Z.add ofs (Zpos (XO XH)))))
     | Tlong ->
       Cons ((S0 (Outgoing, (Z.add ofs (Zpos XH)), Tint)), (Cons ((S0
         (Outgoing, ofs, Tint)),
         (loc_arguments_rec tys (Z.add ofs (Zpos (XO XH)))))))
     | Tany64 ->
       Cons ((S0 (Outgoing, ofs, Tany64)),
         (loc_arguments_rec tys (Z.add ofs (Zpos (XO XH)))))
     | x ->
       Cons ((S0 (Outgoing, ofs, x)),
         (loc_arguments_rec tys (Z.add ofs (Zpos XH)))))

(** val loc_arguments : signature -> loc list **)

let loc_arguments s =
  loc_arguments_rec s.sig_args Z0

(** val size_arguments_rec : typ list -> z -> z **)

let rec size_arguments_rec tyl ofs =
  match tyl with
  | Nil -> ofs
  | Cons (ty, tys) -> size_arguments_rec tys (Z.add ofs (typesize ty))

(** val size_arguments : signature -> z **)

let size_arguments s =
  size_arguments_rec s.sig_args Z0

(** val parameter_of_argument : loc -> loc **)

let parameter_of_argument l = match l with
| R r -> l
| S0 (sl, n0, ty) ->
  (match sl with
   | Outgoing -> S0 (Incoming, n0, ty)
   | _ -> l)

(** val loc_parameters : signature -> loc list **)

let loc_parameters s =
  map parameter_of_argument (loc_arguments s)

(** val tailcall_is_possible : signature -> bool **)

let tailcall_is_possible sg =
  let rec tcisp = function
  | Nil -> True
  | Cons (l0, l') ->
    (match l0 with
     | R r -> tcisp l'
     | S0 (sl, pos, ty) -> False)
  in tcisp (loc_arguments sg)

type node0 = positive

type instruction0 =
| Lop of operation * mreg list * mreg
| Lload of memory_chunk * addressing * mreg list * mreg
| Lgetstack of slot * z * typ * mreg
| Lsetstack of mreg * slot * z * typ
| Lstore of memory_chunk * addressing * mreg list * mreg
| Lcall of signature * (mreg, ident) sum
| Ltailcall of signature * (mreg, ident) sum
| Lbuiltin of external_function * loc builtin_arg list * mreg builtin_res
| Lbranch of node0
| Lcond of condition * mreg list * node0 * node0
| Ljumptable of mreg * node0 list
| Lreturn

type bblock = instruction0 list

type code0 = bblock PTree.t

type function5 = { fn_sig3 : signature; fn_stacksize0 : z; fn_code0 : 
                   code0; fn_entrypoint0 : node0 }

(** val fn_sig3 : function5 -> signature **)

let fn_sig3 x = x.fn_sig3

(** val fn_stacksize0 : function5 -> z **)

let fn_stacksize0 x = x.fn_stacksize0

(** val fn_code0 : function5 -> code0 **)

let fn_code0 x = x.fn_code0

(** val fn_entrypoint0 : function5 -> node0 **)

let fn_entrypoint0 x = x.fn_entrypoint0

type fundef5 = function5 fundef

type program5 = (fundef5, unit0) program

(** val destroyed_by_getstack : slot -> mreg list **)

let destroyed_by_getstack = function
| Incoming -> Cons (temp_for_parent_frame, Nil)
| _ -> Nil

(** val successors_block : bblock -> node0 list **)

let rec successors_block = function
| Nil -> Nil
| Cons (instr, b') ->
  (match instr with
   | Ltailcall (sg, ros) -> Nil
   | Lbranch s -> Cons (s, Nil)
   | Lcond (cond, args, s1, s2) -> Cons (s1, (Cons (s2, Nil)))
   | Ljumptable (arg, tbl) -> tbl
   | Lreturn -> Nil
   | _ -> successors_block b')

type label2 = positive

type instruction1 =
| Lgetstack0 of slot * z * typ * mreg
| Lsetstack0 of mreg * slot * z * typ
| Lop0 of operation * mreg list * mreg
| Lload0 of memory_chunk * addressing * mreg list * mreg
| Lstore0 of memory_chunk * addressing * mreg list * mreg
| Lcall0 of signature * (mreg, ident) sum
| Ltailcall0 of signature * (mreg, ident) sum
| Lbuiltin0 of external_function * loc builtin_arg list * mreg builtin_res
| Llabel of label2
| Lgoto of label2
| Lcond0 of condition * mreg list * label2
| Ljumptable0 of mreg * label2 list
| Lreturn0

type code1 = instruction1 list

type function6 = { fn_sig4 : signature; fn_stacksize1 : z; fn_code1 : code1 }

(** val fn_sig4 : function6 -> signature **)

let fn_sig4 x = x.fn_sig4

(** val fn_stacksize1 : function6 -> z **)

let fn_stacksize1 x = x.fn_stacksize1

(** val fn_code1 : function6 -> code1 **)

let fn_code1 x = x.fn_code1

type fundef6 = function6 fundef

type program6 = (fundef6, unit0) program

type bounds = { bound_local : z; bound_int_callee_save : z;
                bound_float_callee_save : z; bound_outgoing : z;
                bound_stack_data : z }

(** val bound_local : bounds -> z **)

let bound_local x = x.bound_local

(** val bound_int_callee_save : bounds -> z **)

let bound_int_callee_save x = x.bound_int_callee_save

(** val bound_float_callee_save : bounds -> z **)

let bound_float_callee_save x = x.bound_float_callee_save

(** val bound_outgoing : bounds -> z **)

let bound_outgoing x = x.bound_outgoing

(** val bound_stack_data : bounds -> z **)

let bound_stack_data x = x.bound_stack_data

(** val regs_of_instr : instruction1 -> mreg list **)

let regs_of_instr = function
| Lgetstack0 (sl, ofs, ty, r) -> Cons (r, Nil)
| Lsetstack0 (r, sl, ofs, ty) -> Cons (r, Nil)
| Lop0 (op, args, res2) -> Cons (res2, Nil)
| Lload0 (chunk, addr, args, dst) -> Cons (dst, Nil)
| Lbuiltin0 (ef, args, res2) ->
  app (params_of_builtin_res res2) (destroyed_by_builtin ef)
| _ -> Nil

(** val slots_of_locs : loc list -> ((slot, z) prod, typ) prod list **)

let rec slots_of_locs = function
| Nil -> Nil
| Cons (l0, l') ->
  (match l0 with
   | R r -> slots_of_locs l'
   | S0 (sl, ofs, ty) ->
     Cons ((Pair ((Pair (sl, ofs)), ty)), (slots_of_locs l')))

(** val slots_of_instr : instruction1 -> ((slot, z) prod, typ) prod list **)

let slots_of_instr = function
| Lgetstack0 (sl, ofs, ty, r) -> Cons ((Pair ((Pair (sl, ofs)), ty)), Nil)
| Lsetstack0 (r, sl, ofs, ty) -> Cons ((Pair ((Pair (sl, ofs)), ty)), Nil)
| Lbuiltin0 (ef, args, res2) -> slots_of_locs (params_of_builtin_args args)
| _ -> Nil

(** val max_over_list : ('a1 -> z) -> 'a1 list -> z **)

let max_over_list valu l =
  fold_left (fun m0 l0 -> Z.max m0 (valu l0)) l Z0

(** val max_over_instrs : function6 -> (instruction1 -> z) -> z **)

let max_over_instrs f valu =
  max_over_list valu f.fn_code1

(** val max_over_regs_of_instr : (mreg -> z) -> instruction1 -> z **)

let max_over_regs_of_instr valu i =
  max_over_list valu (regs_of_instr i)

(** val max_over_slots_of_instr :
    (((slot, z) prod, typ) prod -> z) -> instruction1 -> z **)

let max_over_slots_of_instr valu i =
  max_over_list valu (slots_of_instr i)

(** val max_over_regs_of_funct : function6 -> (mreg -> z) -> z **)

let max_over_regs_of_funct f valu =
  max_over_instrs f (max_over_regs_of_instr valu)

(** val max_over_slots_of_funct :
    function6 -> (((slot, z) prod, typ) prod -> z) -> z **)

let max_over_slots_of_funct f valu =
  max_over_instrs f (max_over_slots_of_instr valu)

(** val int_callee_save : mreg -> z **)

let int_callee_save r =
  Z.add (Zpos XH) (index_int_callee_save r)

(** val float_callee_save : mreg -> z **)

let float_callee_save r =
  Z.add (Zpos XH) (index_float_callee_save r)

(** val local_slot : ((slot, z) prod, typ) prod -> z **)

let local_slot = function
| Pair (p, ty) ->
  let Pair (s0, ofs) = p in
  (match s0 with
   | Local -> Z.add ofs (typesize ty)
   | _ -> Z0)

(** val outgoing_slot : ((slot, z) prod, typ) prod -> z **)

let outgoing_slot = function
| Pair (p, ty) ->
  let Pair (s0, ofs) = p in
  (match s0 with
   | Outgoing -> Z.add ofs (typesize ty)
   | _ -> Z0)

(** val outgoing_space : instruction1 -> z **)

let outgoing_space = function
| Lcall0 (sig1, s) -> size_arguments sig1
| _ -> Z0

(** val function_bounds : function6 -> bounds **)

let function_bounds f =
  { bound_local = (max_over_slots_of_funct f local_slot);
    bound_int_callee_save = (max_over_regs_of_funct f int_callee_save);
    bound_float_callee_save = (max_over_regs_of_funct f float_callee_save);
    bound_outgoing =
    (Z.max (max_over_instrs f outgoing_space)
      (max_over_slots_of_funct f outgoing_slot)); bound_stack_data =
    (Z.max f.fn_stacksize1 Z0) }

(** val fe_ofs_arg : z **)

let fe_ofs_arg =
  Z0

type frame_env = { fe_size : z; fe_ofs_link : z; fe_ofs_retaddr : z;
                   fe_ofs_local : z; fe_ofs_int_callee_save : z;
                   fe_num_int_callee_save : z; fe_ofs_float_callee_save : 
                   z; fe_num_float_callee_save : z; fe_stack_data : z }

(** val fe_size : frame_env -> z **)

let fe_size x = x.fe_size

(** val fe_ofs_link : frame_env -> z **)

let fe_ofs_link x = x.fe_ofs_link

(** val fe_ofs_retaddr : frame_env -> z **)

let fe_ofs_retaddr x = x.fe_ofs_retaddr

(** val fe_ofs_local : frame_env -> z **)

let fe_ofs_local x = x.fe_ofs_local

(** val fe_ofs_int_callee_save : frame_env -> z **)

let fe_ofs_int_callee_save x = x.fe_ofs_int_callee_save

(** val fe_num_int_callee_save : frame_env -> z **)

let fe_num_int_callee_save x = x.fe_num_int_callee_save

(** val fe_ofs_float_callee_save : frame_env -> z **)

let fe_ofs_float_callee_save x = x.fe_ofs_float_callee_save

(** val fe_num_float_callee_save : frame_env -> z **)

let fe_num_float_callee_save x = x.fe_num_float_callee_save

(** val fe_stack_data : frame_env -> z **)

let fe_stack_data x = x.fe_stack_data

(** val make_env : bounds -> frame_env **)

let make_env b =
  let olink = Z.mul (Zpos (XO (XO XH))) b.bound_outgoing in
  let oics = Z.add olink (Zpos (XO (XO XH))) in
  let ofcs =
    align (Z.add oics (Z.mul (Zpos (XO (XO XH))) b.bound_int_callee_save))
      (Zpos (XO (XO (XO XH))))
  in
  let ol =
    Z.add ofcs (Z.mul (Zpos (XO (XO (XO XH)))) b.bound_float_callee_save)
  in
  let ostkdata =
    align (Z.add ol (Z.mul (Zpos (XO (XO XH))) b.bound_local)) (Zpos (XO (XO
      (XO XH))))
  in
  let oretaddr =
    align (Z.add ostkdata b.bound_stack_data) (Zpos (XO (XO XH)))
  in
  let sz = Z.add oretaddr (Zpos (XO (XO XH))) in
  { fe_size = sz; fe_ofs_link = olink; fe_ofs_retaddr = oretaddr;
  fe_ofs_local = ol; fe_ofs_int_callee_save = oics; fe_num_int_callee_save =
  b.bound_int_callee_save; fe_ofs_float_callee_save = ofcs;
  fe_num_float_callee_save = b.bound_float_callee_save; fe_stack_data =
  ostkdata }

type label3 = positive

type instruction2 =
| Mgetstack of Int.int * typ * mreg
| Msetstack of mreg * Int.int * typ
| Mgetparam of Int.int * typ * mreg
| Mop of operation * mreg list * mreg
| Mload of memory_chunk * addressing * mreg list * mreg
| Mstore of memory_chunk * addressing * mreg list * mreg
| Mcall of signature * (mreg, ident) sum
| Mtailcall of signature * (mreg, ident) sum
| Mbuiltin of external_function * mreg builtin_arg list * mreg builtin_res
| Mlabel of label3
| Mgoto of label3
| Mcond of condition * mreg list * label3
| Mjumptable of mreg * label3 list
| Mreturn

type code2 = instruction2 list

type function7 = { fn_sig5 : signature; fn_code2 : code2; fn_stacksize2 : 
                   z; fn_link_ofs : Int.int; fn_retaddr_ofs : Int.int }

(** val fn_sig5 : function7 -> signature **)

let fn_sig5 x = x.fn_sig5

(** val fn_code2 : function7 -> code2 **)

let fn_code2 x = x.fn_code2

(** val fn_stacksize2 : function7 -> z **)

let fn_stacksize2 x = x.fn_stacksize2

(** val fn_link_ofs : function7 -> Int.int **)

let fn_link_ofs x = x.fn_link_ofs

(** val fn_retaddr_ofs : function7 -> Int.int **)

let fn_retaddr_ofs x = x.fn_retaddr_ofs

type fundef7 = function7 fundef

type program7 = (fundef7, unit0) program

type ireg =
| EAX
| EBX
| ECX
| EDX
| ESI
| EDI
| EBP
| ESP

type freg =
| XMM0
| XMM1
| XMM2
| XMM3
| XMM4
| XMM5
| XMM6
| XMM7

(** val ireg_eq : ireg -> ireg -> sumbool **)

let ireg_eq x y =
  match x with
  | EAX ->
    (match y with
     | EAX -> Left
     | _ -> Right)
  | EBX ->
    (match y with
     | EBX -> Left
     | _ -> Right)
  | ECX ->
    (match y with
     | ECX -> Left
     | _ -> Right)
  | EDX ->
    (match y with
     | EDX -> Left
     | _ -> Right)
  | ESI ->
    (match y with
     | ESI -> Left
     | _ -> Right)
  | EDI ->
    (match y with
     | EDI -> Left
     | _ -> Right)
  | EBP ->
    (match y with
     | EBP -> Left
     | _ -> Right)
  | ESP ->
    (match y with
     | ESP -> Left
     | _ -> Right)

type crbit =
| ZF
| CF
| PF
| SF
| OF

type preg =
| PC
| IR of ireg
| FR of freg
| ST0
| CR of crbit
| RA

type label4 = positive

type addrmode =
| Addrmode of ireg option * (ireg, Int.int) prod option
   * (Int.int, (ident, Int.int) prod) sum

type testcond =
| Cond_e
| Cond_ne
| Cond_b
| Cond_be
| Cond_ae
| Cond_a
| Cond_l
| Cond_le
| Cond_ge
| Cond_g
| Cond_p
| Cond_np

type instruction3 =
| Pmov_rr of ireg * ireg
| Pmov_ri of ireg * Int.int
| Pmov_ra of ireg * ident
| Pmov_rm of ireg * addrmode
| Pmov_mr of addrmode * ireg
| Pmovsd_ff of freg * freg
| Pmovsd_fi of freg * float
| Pmovsd_fm of freg * addrmode
| Pmovsd_mf of addrmode * freg
| Pmovss_fi of freg * float32
| Pmovss_fm of freg * addrmode
| Pmovss_mf of addrmode * freg
| Pfldl_m of addrmode
| Pfstpl_m of addrmode
| Pflds_m of addrmode
| Pfstps_m of addrmode
| Pxchg_rr of ireg * ireg
| Pmovb_mr of addrmode * ireg
| Pmovw_mr of addrmode * ireg
| Pmovzb_rr of ireg * ireg
| Pmovzb_rm of ireg * addrmode
| Pmovsb_rr of ireg * ireg
| Pmovsb_rm of ireg * addrmode
| Pmovzw_rr of ireg * ireg
| Pmovzw_rm of ireg * addrmode
| Pmovsw_rr of ireg * ireg
| Pmovsw_rm of ireg * addrmode
| Pcvtsd2ss_ff of freg * freg
| Pcvtss2sd_ff of freg * freg
| Pcvttsd2si_rf of ireg * freg
| Pcvtsi2sd_fr of freg * ireg
| Pcvttss2si_rf of ireg * freg
| Pcvtsi2ss_fr of freg * ireg
| Plea of ireg * addrmode
| Pneg of ireg
| Psub_rr of ireg * ireg
| Pimul_rr of ireg * ireg
| Pimul_ri of ireg * Int.int
| Pimul_r of ireg
| Pmul_r of ireg
| Pdiv of ireg
| Pidiv of ireg
| Pand_rr of ireg * ireg
| Pand_ri of ireg * Int.int
| Por_rr of ireg * ireg
| Por_ri of ireg * Int.int
| Pxor_r of ireg
| Pxor_rr of ireg * ireg
| Pxor_ri of ireg * Int.int
| Pnot of ireg
| Psal_rcl of ireg
| Psal_ri of ireg * Int.int
| Pshr_rcl of ireg
| Pshr_ri of ireg * Int.int
| Psar_rcl of ireg
| Psar_ri of ireg * Int.int
| Pshld_ri of ireg * ireg * Int.int
| Pror_ri of ireg * Int.int
| Pcmp_rr of ireg * ireg
| Pcmp_ri of ireg * Int.int
| Ptest_rr of ireg * ireg
| Ptest_ri of ireg * Int.int
| Pcmov of testcond * ireg * ireg
| Psetcc of testcond * ireg
| Paddd_ff of freg * freg
| Psubd_ff of freg * freg
| Pmuld_ff of freg * freg
| Pdivd_ff of freg * freg
| Pnegd of freg
| Pabsd of freg
| Pcomisd_ff of freg * freg
| Pxorpd_f of freg
| Padds_ff of freg * freg
| Psubs_ff of freg * freg
| Pmuls_ff of freg * freg
| Pdivs_ff of freg * freg
| Pnegs of freg
| Pabss of freg
| Pcomiss_ff of freg * freg
| Pxorps_f of freg
| Pjmp_l of label4
| Pjmp_s of ident * signature
| Pjmp_r of ireg * signature
| Pjcc of testcond * label4
| Pjcc2 of testcond * testcond * label4
| Pjmptbl of ireg * label4 list
| Pcall_s of ident * signature
| Pcall_r of ireg * signature
| Pret
| Pmov_rm_a of ireg * addrmode
| Pmov_mr_a of addrmode * ireg
| Pmovsd_fm_a of freg * addrmode
| Pmovsd_mf_a of addrmode * freg
| Plabel of label4
| Pallocframe of z * Int.int * Int.int
| Pfreeframe of z * Int.int * Int.int
| Pbuiltin of external_function * preg builtin_arg list * preg builtin_res
| Padc_ri of ireg * Int.int
| Padc_rr of ireg * ireg
| Padd_mi of addrmode * Int.int
| Padd_ri of ireg * Int.int
| Padd_rr of ireg * ireg
| Pbsf of ireg * ireg
| Pbsr of ireg * ireg
| Pbswap of ireg
| Pbswap16 of ireg
| Pcfi_adjust of Int.int
| Pfmadd132 of freg * freg * freg
| Pfmadd213 of freg * freg * freg
| Pfmadd231 of freg * freg * freg
| Pfmsub132 of freg * freg * freg
| Pfmsub213 of freg * freg * freg
| Pfmsub231 of freg * freg * freg
| Pfnmadd132 of freg * freg * freg
| Pfnmadd213 of freg * freg * freg
| Pfnmadd231 of freg * freg * freg
| Pfnmsub132 of freg * freg * freg
| Pfnmsub213 of freg * freg * freg
| Pfnmsub231 of freg * freg * freg
| Pmaxsd of freg * freg
| Pminsd of freg * freg
| Pmovb_rm of ireg * addrmode
| Pmovq_mr of addrmode * freg
| Pmovq_rm of freg * addrmode
| Pmovsb
| Pmovsw
| Pmovw_rm of ireg * addrmode
| Prep_movsl
| Psbb_rr of ireg * ireg
| Psqrtsd of freg * freg
| Psub_ri of ireg * Int.int

type code3 = instruction3 list

type function8 = { fn_sig6 : signature; fn_code3 : code3 }

(** val fn_code3 : function8 -> code3 **)

let fn_code3 x = x.fn_code3

type fundef8 = function8 fundef

type program8 = (fundef8, unit0) program

(** val preg_of : mreg -> preg **)

let preg_of = function
| AX -> IR EAX
| BX -> IR EBX
| CX -> IR ECX
| DX -> IR EDX
| SI -> IR ESI
| DI -> IR EDI
| BP -> IR EBP
| X0 -> FR XMM0
| X1 -> FR XMM1
| X2 -> FR XMM2
| X3 -> FR XMM3
| X4 -> FR XMM4
| X5 -> FR XMM5
| X6 -> FR XMM6
| X7 -> FR XMM7
| FP0 -> ST0

(** val optim_for_size : unit0 -> bool **)

let optim_for_size =
  failwith "AXIOM TO BE REALIZED"

(** val propagate_float_constants : unit0 -> bool **)

let propagate_float_constants =
  failwith "AXIOM TO BE REALIZED"

(** val generate_float_constants : unit0 -> bool **)

let generate_float_constants =
  failwith "AXIOM TO BE REALIZED"

(** val va_strict : unit0 -> bool **)

let va_strict =
  failwith "AXIOM TO BE REALIZED"

(** val optim_tailcalls : unit0 -> bool **)

let optim_tailcalls =
  failwith "AXIOM TO BE REALIZED"

(** val optim_constprop : unit0 -> bool **)

let optim_constprop =
  failwith "AXIOM TO BE REALIZED"

(** val optim_CSE : unit0 -> bool **)

let optim_CSE =
  failwith "AXIOM TO BE REALIZED"

(** val optim_redundancy : unit0 -> bool **)

let optim_redundancy =
  failwith "AXIOM TO BE REALIZED"

(** val debug : unit0 -> bool **)

let debug =
  failwith "AXIOM TO BE REALIZED"

module VSet = Coq_Make(OrderedPositive)

type compilenv = VSet.t

(** val is_liftable_var : compilenv -> expr -> ident option **)

let is_liftable_var cenv = function
| Evar (id, ty) ->
  (match VSet.mem id cenv with
   | True -> Some id
   | False -> None)
| _ -> None

(** val make_cast : expr -> type0 -> expr **)

let make_cast a tto =
  match classify_cast (typeof a) tto with
  | Cast_case_neutral -> a
  | Cast_case_i2i (sz2, si2) ->
    (match sz2 with
     | I32 -> a
     | _ -> Ecast (a, tto))
  | Cast_case_f2f -> a
  | Cast_case_s2s -> a
  | Cast_case_l2l -> a
  | Cast_case_struct (id1, id2) -> a
  | Cast_case_union (id1, id2) -> a
  | Cast_case_void -> a
  | _ -> Ecast (a, tto)

(** val sdebug_temp : ident -> type0 -> statement **)

let sdebug_temp id ty =
  Sbuiltin (None, (EF_debug ((XO XH), id, (Cons ((typ_of_type ty), Nil)))),
    (Tcons ((typeconv ty), Tnil)), (Cons ((Etempvar (id, ty)), Nil)))

(** val sdebug_var : ident -> type0 -> statement **)

let sdebug_var id ty =
  Sbuiltin (None, (EF_debug ((XI (XO XH)), id, (Cons (Tint, Nil)))), (Tcons
    ((Tpointer (ty, noattr)), Tnil)), (Cons ((Eaddrof ((Evar (id, ty)),
    (Tpointer (ty, noattr)))), Nil)))

(** val sset_debug : ident -> type0 -> expr -> statement **)

let sset_debug id ty a =
  match debug Tt with
  | True -> Ssequence ((Sset (id, (make_cast a ty))), (sdebug_temp id ty))
  | False -> Sset (id, (make_cast a ty))

(** val simpl_expr : compilenv -> expr -> expr **)

let rec simpl_expr cenv a = match a with
| Evar (id, ty) ->
  (match VSet.mem id cenv with
   | True -> Etempvar (id, ty)
   | False -> Evar (id, ty))
| Etempvar (id, ty) -> Etempvar (id, ty)
| Ederef (a1, ty) -> Ederef ((simpl_expr cenv a1), ty)
| Eaddrof (a1, ty) -> Eaddrof ((simpl_expr cenv a1), ty)
| Eunop (op, a1, ty) -> Eunop (op, (simpl_expr cenv a1), ty)
| Ebinop (op, a1, a2, ty) ->
  Ebinop (op, (simpl_expr cenv a1), (simpl_expr cenv a2), ty)
| Ecast (a1, ty) -> Ecast ((simpl_expr cenv a1), ty)
| Efield (a1, fld, ty) -> Efield ((simpl_expr cenv a1), fld, ty)
| _ -> a

(** val simpl_exprlist : compilenv -> expr list -> expr list **)

let simpl_exprlist cenv al =
  map (simpl_expr cenv) al

(** val check_temp : compilenv -> ident -> unit0 res **)

let check_temp cenv id =
  match VSet.mem id cenv with
  | True ->
    Error (Cons ((MSG (String ((Ascii (False, True, False, False, False,
      True, True, False)), (String ((Ascii (True, False, False, False, False,
      True, True, False)), (String ((Ascii (False, False, True, False, False,
      True, True, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), (String ((Ascii (False, False, True,
      False, True, True, True, False)), (String ((Ascii (True, False, True,
      False, False, True, True, False)), (String ((Ascii (True, False, True,
      True, False, True, True, False)), (String ((Ascii (False, False, False,
      False, True, True, True, False)), (String ((Ascii (True, True, True,
      True, False, True, True, False)), (String ((Ascii (False, True, False,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      False, False, True, True, False)), (String ((Ascii (False, True, False,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      True, True, True, True, False)), (String ((Ascii (False, False, False,
      False, False, True, False, False)),
      EmptyString))))))))))))))))))))))))))))), (Cons ((CTX id), Nil))))
  | False -> OK Tt

(** val check_opttemp : compilenv -> ident option -> unit0 res **)

let check_opttemp cenv = function
| Some id -> check_temp cenv id
| None -> OK Tt

(** val simpl_stmt : compilenv -> statement -> statement res **)

let rec simpl_stmt cenv = function
| Sassign (a1, a2) ->
  (match is_liftable_var cenv a1 with
   | Some id -> OK (sset_debug id (typeof a1) (simpl_expr cenv a2))
   | None -> OK (Sassign ((simpl_expr cenv a1), (simpl_expr cenv a2))))
| Sset (id, a) ->
  bind (check_temp cenv id) (fun x -> OK (Sset (id, (simpl_expr cenv a))))
| Scall (optid, a, al) ->
  bind (check_opttemp cenv optid) (fun x -> OK (Scall (optid,
    (simpl_expr cenv a), (simpl_exprlist cenv al))))
| Sbuiltin (optid, ef, tyargs, al) ->
  bind (check_opttemp cenv optid) (fun x -> OK (Sbuiltin (optid, ef, tyargs,
    (simpl_exprlist cenv al))))
| Ssequence (s1, s2) ->
  bind (simpl_stmt cenv s1) (fun s1' ->
    bind (simpl_stmt cenv s2) (fun s2' -> OK (Ssequence (s1', s2'))))
| Sifthenelse (a, s1, s2) ->
  bind (simpl_stmt cenv s1) (fun s1' ->
    bind (simpl_stmt cenv s2) (fun s2' -> OK (Sifthenelse
      ((simpl_expr cenv a), s1', s2'))))
| Sloop (s1, s2) ->
  bind (simpl_stmt cenv s1) (fun s1' ->
    bind (simpl_stmt cenv s2) (fun s2' -> OK (Sloop (s1', s2'))))
| Sreturn opta -> OK (Sreturn (option_map (simpl_expr cenv) opta))
| Sswitch (a, ls) ->
  bind (simpl_lblstmt cenv ls) (fun ls' -> OK (Sswitch ((simpl_expr cenv a),
    ls')))
| Slabel (lbl, s0) ->
  bind (simpl_stmt cenv s0) (fun s' -> OK (Slabel (lbl, s')))
| x -> OK x

(** val simpl_lblstmt :
    compilenv -> labeled_statements -> labeled_statements res **)

and simpl_lblstmt cenv = function
| LSnil -> OK LSnil
| LScons (c, s, ls1) ->
  bind (simpl_stmt cenv s) (fun s' ->
    bind (simpl_lblstmt cenv ls1) (fun ls1' -> OK (LScons (c, s', ls1'))))

(** val store_params :
    compilenv -> (ident, type0) prod list -> statement -> statement **)

let rec store_params cenv params s =
  match params with
  | Nil -> s
  | Cons (p, params') ->
    let Pair (id, ty) = p in
    (match VSet.mem id cenv with
     | True -> store_params cenv params' s
     | False ->
       Ssequence ((Sassign ((Evar (id, ty)), (Etempvar (id, ty)))),
         (store_params cenv params' s)))

(** val addr_taken_expr : expr -> VSet.t **)

let rec addr_taken_expr = function
| Ederef (a1, ty) -> addr_taken_expr a1
| Eaddrof (a1, ty) ->
  (match a1 with
   | Evar (id, ty1) -> VSet.singleton id
   | _ -> addr_taken_expr a1)
| Eunop (op, a1, ty) -> addr_taken_expr a1
| Ebinop (op, a1, a2, ty) ->
  VSet.union (addr_taken_expr a1) (addr_taken_expr a2)
| Ecast (a1, ty) -> addr_taken_expr a1
| Efield (a1, fld, ty) -> addr_taken_expr a1
| _ -> VSet.empty

(** val addr_taken_exprlist : expr list -> VSet.t **)

let rec addr_taken_exprlist = function
| Nil -> VSet.empty
| Cons (a, l') -> VSet.union (addr_taken_expr a) (addr_taken_exprlist l')

(** val addr_taken_stmt : statement -> VSet.t **)

let rec addr_taken_stmt = function
| Sassign (a, b) -> VSet.union (addr_taken_expr a) (addr_taken_expr b)
| Sset (id, a) -> addr_taken_expr a
| Scall (optid, a, bl) ->
  VSet.union (addr_taken_expr a) (addr_taken_exprlist bl)
| Sbuiltin (optid, ef, tyargs, bl) -> addr_taken_exprlist bl
| Ssequence (s1, s2) -> VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2)
| Sifthenelse (a, s1, s2) ->
  VSet.union (addr_taken_expr a)
    (VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2))
| Sloop (s1, s2) -> VSet.union (addr_taken_stmt s1) (addr_taken_stmt s2)
| Sreturn o ->
  (match o with
   | Some a -> addr_taken_expr a
   | None -> VSet.empty)
| Sswitch (a, ls) -> VSet.union (addr_taken_expr a) (addr_taken_lblstmt ls)
| Slabel (lbl, s0) -> addr_taken_stmt s0
| _ -> VSet.empty

(** val addr_taken_lblstmt : labeled_statements -> VSet.t **)

and addr_taken_lblstmt = function
| LSnil -> VSet.empty
| LScons (c, s, ls') ->
  VSet.union (addr_taken_stmt s) (addr_taken_lblstmt ls')

(** val add_local_variable :
    VSet.t -> (ident, type0) prod -> compilenv -> compilenv **)

let add_local_variable atk id_ty cenv =
  let Pair (id, ty) = id_ty in
  (match access_mode ty with
   | By_value chunk ->
     (match VSet.mem id atk with
      | True -> cenv
      | False -> VSet.add id cenv)
   | _ -> cenv)

(** val cenv_for : function0 -> compilenv **)

let cenv_for f =
  let atk = addr_taken_stmt f.fn_body in
  fold_right (add_local_variable atk) VSet.empty (app f.fn_params f.fn_vars)

(** val add_debug_var : (ident, type0) prod -> statement -> statement **)

let add_debug_var id_ty s =
  let Pair (id, ty) = id_ty in Ssequence ((sdebug_var id ty), s)

(** val add_debug_vars :
    (ident, type0) prod list -> statement -> statement **)

let add_debug_vars vars s =
  match debug Tt with
  | True -> fold_right add_debug_var s vars
  | False -> s

(** val add_debug_param : (ident, type0) prod -> statement -> statement **)

let add_debug_param id_ty s =
  let Pair (id, ty) = id_ty in Ssequence ((sdebug_temp id ty), s)

(** val add_debug_params :
    (ident, type0) prod list -> statement -> statement **)

let add_debug_params params s =
  match debug Tt with
  | True -> fold_right add_debug_param s params
  | False -> s

(** val remove_lifted :
    compilenv -> (ident, type0) prod list -> (VSet.elt, type0) prod list **)

let remove_lifted cenv vars =
  filter (fun id_ty -> negb (VSet.mem (fst id_ty) cenv)) vars

(** val add_lifted :
    compilenv -> (ident, type0) prod list -> (ident, type0) prod list ->
    (VSet.elt, type0) prod list **)

let add_lifted cenv vars1 vars2 =
  app (filter (fun id_ty -> VSet.mem (fst id_ty) cenv) vars1) vars2

(** val transf_function0 : function0 -> function0 res **)

let transf_function0 f =
  let cenv = cenv_for f in
  (match list_disjoint_dec ident_eq (var_names f.fn_params)
           (var_names f.fn_temps) with
   | Left ->
     bind (simpl_stmt cenv f.fn_body) (fun body' ->
       let vars' = remove_lifted cenv (app f.fn_params f.fn_vars) in
       let temps' = add_lifted cenv f.fn_vars f.fn_temps in
       OK { fn_return = f.fn_return; fn_callconv = f.fn_callconv; fn_params =
       f.fn_params; fn_vars = vars'; fn_temps = temps'; fn_body =
       (add_debug_params f.fn_params
         (store_params cenv f.fn_params (add_debug_vars vars' body'))) })
   | Right -> assertion_failed)

(** val transf_fundef0 : fundef0 -> fundef0 res **)

let transf_fundef0 = function
| Internal0 f -> bind (transf_function0 f) (fun tf -> OK (Internal0 tf))
| External0 (ef, targs, tres, cconv) ->
  OK (External0 (ef, targs, tres, cconv))

(** val transf_program : program0 -> program0 res **)

let transf_program p =
  bind (transform_partial_program transf_fundef0 (program_of_program p))
    (fun p1 -> OK { prog_defs0 = p1.prog_defs; prog_public0 = p1.prog_public;
    prog_main0 = p1.prog_main; prog_types = p.prog_types; prog_comp_env =
    p.prog_comp_env })

(** val make_intconst : Int.int -> expr1 **)

let make_intconst n0 =
  Econst0 (Ointconst0 n0)

(** val make_longconst : Int64.int -> expr1 **)

let make_longconst f =
  Econst0 (Olongconst0 f)

(** val make_floatconst : float -> expr1 **)

let make_floatconst f =
  Econst0 (Ofloatconst0 f)

(** val make_singleconst : float32 -> expr1 **)

let make_singleconst f =
  Econst0 (Osingleconst0 f)

(** val make_singleoffloat : expr1 -> expr1 **)

let make_singleoffloat e =
  Eunop1 (Osingleoffloat, e)

(** val make_floatofsingle : expr1 -> expr1 **)

let make_floatofsingle e =
  Eunop1 (Ofloatofsingle, e)

(** val make_floatofint : expr1 -> signedness -> expr1 **)

let make_floatofint e = function
| Signed -> Eunop1 (Ofloatofint, e)
| Unsigned -> Eunop1 (Ofloatofintu, e)

(** val make_singleofint : expr1 -> signedness -> expr1 **)

let make_singleofint e = function
| Signed -> Eunop1 (Osingleofint, e)
| Unsigned -> Eunop1 (Osingleofintu, e)

(** val make_intoffloat : expr1 -> signedness -> expr1 **)

let make_intoffloat e = function
| Signed -> Eunop1 (Ointoffloat, e)
| Unsigned -> Eunop1 (Ointuoffloat, e)

(** val make_intofsingle : expr1 -> signedness -> expr1 **)

let make_intofsingle e = function
| Signed -> Eunop1 (Ointofsingle, e)
| Unsigned -> Eunop1 (Ointuofsingle, e)

(** val make_longofint : expr1 -> signedness -> expr1 **)

let make_longofint e = function
| Signed -> Eunop1 (Olongofint, e)
| Unsigned -> Eunop1 (Olongofintu, e)

(** val make_floatoflong : expr1 -> signedness -> expr1 **)

let make_floatoflong e = function
| Signed -> Eunop1 (Ofloatoflong, e)
| Unsigned -> Eunop1 (Ofloatoflongu, e)

(** val make_singleoflong : expr1 -> signedness -> expr1 **)

let make_singleoflong e = function
| Signed -> Eunop1 (Osingleoflong, e)
| Unsigned -> Eunop1 (Osingleoflongu, e)

(** val make_longoffloat : expr1 -> signedness -> expr1 **)

let make_longoffloat e = function
| Signed -> Eunop1 (Olongoffloat, e)
| Unsigned -> Eunop1 (Olonguoffloat, e)

(** val make_longofsingle : expr1 -> signedness -> expr1 **)

let make_longofsingle e = function
| Signed -> Eunop1 (Olongofsingle, e)
| Unsigned -> Eunop1 (Olonguofsingle, e)

(** val make_cmp_ne_zero : expr1 -> expr1 **)

let make_cmp_ne_zero e = match e with
| Ebinop1 (b, e1, e2) ->
  (match b with
   | Ocmp c -> e
   | Ocmpu c -> e
   | Ocmpf c -> e
   | Ocmpfs c -> e
   | Ocmpl c -> e
   | Ocmplu c -> e
   | _ -> Ebinop1 ((Ocmp Cne), e, (make_intconst Int.zero)))
| _ -> Ebinop1 ((Ocmp Cne), e, (make_intconst Int.zero))

(** val make_cast_int : expr1 -> intsize -> signedness -> expr1 **)

let make_cast_int e sz si =
  match sz with
  | I8 ->
    (match si with
     | Signed -> Eunop1 (Ocast8signed, e)
     | Unsigned -> Eunop1 (Ocast8unsigned, e))
  | I16 ->
    (match si with
     | Signed -> Eunop1 (Ocast16signed, e)
     | Unsigned -> Eunop1 (Ocast16unsigned, e))
  | I32 -> e
  | IBool -> make_cmp_ne_zero e

(** val make_cast0 : type0 -> type0 -> expr1 -> expr1 res **)

let make_cast0 from to0 e =
  match classify_cast from to0 with
  | Cast_case_i2i (sz2, si2) -> OK (make_cast_int e sz2 si2)
  | Cast_case_f2s -> OK (make_singleoffloat e)
  | Cast_case_s2f -> OK (make_floatofsingle e)
  | Cast_case_i2f si1 -> OK (make_floatofint e si1)
  | Cast_case_i2s si1 -> OK (make_singleofint e si1)
  | Cast_case_f2i (sz2, si2) ->
    OK (make_cast_int (make_intoffloat e si2) sz2 si2)
  | Cast_case_s2i (sz2, si2) ->
    OK (make_cast_int (make_intofsingle e si2) sz2 si2)
  | Cast_case_i2l si1 -> OK (make_longofint e si1)
  | Cast_case_l2i (sz2, si2) ->
    OK (make_cast_int (Eunop1 (Ointoflong, e)) sz2 si2)
  | Cast_case_l2f si1 -> OK (make_floatoflong e si1)
  | Cast_case_l2s si1 -> OK (make_singleoflong e si1)
  | Cast_case_f2l si2 -> OK (make_longoffloat e si2)
  | Cast_case_s2l si2 -> OK (make_longofsingle e si2)
  | Cast_case_f2bool ->
    OK (Ebinop1 ((Ocmpf Cne), e, (make_floatconst Float.zero)))
  | Cast_case_s2bool ->
    OK (Ebinop1 ((Ocmpfs Cne), e, (make_singleconst Float32.zero)))
  | Cast_case_l2bool ->
    OK (Ebinop1 ((Ocmpl Cne), e, (make_longconst Int64.zero)))
  | Cast_case_p2bool ->
    OK (Ebinop1 ((Ocmpu Cne), e, (make_intconst Int.zero)))
  | Cast_case_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (True, True, False, False, False, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (True, True, False, False, True, True, True, False)),
        (String ((Ascii (False, False, True, False, True, True, True,
        False)), EmptyString)))))))))))))))))))))))))))))))))))
  | _ -> OK e

(** val make_boolean : expr1 -> type0 -> expr1 **)

let make_boolean e ty =
  match classify_bool ty with
  | Bool_case_i -> make_cmp_ne_zero e
  | Bool_case_f -> Ebinop1 ((Ocmpf Cne), e, (make_floatconst Float.zero))
  | Bool_case_s -> Ebinop1 ((Ocmpfs Cne), e, (make_singleconst Float32.zero))
  | Bool_case_p -> Ebinop1 ((Ocmpu Cne), e, (make_intconst Int.zero))
  | Bool_case_l -> Ebinop1 ((Ocmpl Cne), e, (make_longconst Int64.zero))
  | Bool_default -> e

(** val make_notbool : expr1 -> type0 -> expr1 res **)

let make_notbool e ty =
  match classify_bool ty with
  | Bool_case_i -> OK (Ebinop1 ((Ocmp Ceq), e, (make_intconst Int.zero)))
  | Bool_case_f ->
    OK (Ebinop1 ((Ocmpf Ceq), e, (make_floatconst Float.zero)))
  | Bool_case_s ->
    OK (Ebinop1 ((Ocmpfs Ceq), e, (make_singleconst Float32.zero)))
  | Bool_case_p -> OK (Ebinop1 ((Ocmpu Ceq), e, (make_intconst Int.zero)))
  | Bool_case_l -> OK (Ebinop1 ((Ocmpl Ceq), e, (make_longconst Int64.zero)))
  | Bool_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (False, True, True, True, False, True, True, False)), (String ((Ascii
        (True, True, True, True, False, True, True, False)), (String ((Ascii
        (False, False, True, False, True, True, True, False)), (String
        ((Ascii (False, True, False, False, False, True, True, False)),
        (String ((Ascii (True, True, True, True, False, True, True, False)),
        (String ((Ascii (True, True, True, True, False, True, True, False)),
        (String ((Ascii (False, False, True, True, False, True, True,
        False)), EmptyString)))))))))))))))))))))))))))))))))))))))))

(** val make_neg : expr1 -> type0 -> expr1 res **)

let make_neg e ty =
  match classify_neg ty with
  | Neg_case_i s -> OK (Eunop1 (Onegint, e))
  | Neg_case_f -> OK (Eunop1 (Onegf, e))
  | Neg_case_s -> OK (Eunop1 (Onegfs, e))
  | Neg_case_l s -> OK (Eunop1 (Onegl, e))
  | Neg_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (False, True, True, True, False, True, True, False)), (String ((Ascii
        (True, False, True, False, False, True, True, False)), (String
        ((Ascii (True, True, True, False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))

(** val make_absfloat : expr1 -> type0 -> expr1 res **)

let make_absfloat e ty =
  match classify_neg ty with
  | Neg_case_i sg -> OK (Eunop1 (Oabsf, (make_floatofint e sg)))
  | Neg_case_f -> OK (Eunop1 (Oabsf, e))
  | Neg_case_s -> OK (Eunop1 (Oabsf, (make_floatofsingle e)))
  | Neg_case_l sg -> OK (Eunop1 (Oabsf, (make_floatoflong e sg)))
  | Neg_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (True, False, False, False, False, True, True, False)), (String
        ((Ascii (False, True, False, False, False, True, True, False)),
        (String ((Ascii (True, True, False, False, True, True, True, False)),
        (String ((Ascii (False, True, True, False, False, True, True,
        False)), (String ((Ascii (False, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, True, False, True,
        True, False)), (String ((Ascii (True, False, False, False, False,
        True, True, False)), (String ((Ascii (False, False, True, False,
        True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))))

(** val make_notint : expr1 -> type0 -> expr1 res **)

let make_notint e ty =
  match classify_notint ty with
  | Notint_case_i s -> OK (Eunop1 (Onotint0, e))
  | Notint_case_l s -> OK (Eunop1 (Onotl, e))
  | Notint_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (False, True, True, True, False, True, True, False)), (String ((Ascii
        (True, True, True, True, False, True, True, False)), (String ((Ascii
        (False, False, True, False, True, True, True, False)), (String
        ((Ascii (True, False, False, True, False, True, True, False)),
        (String ((Ascii (False, True, True, True, False, True, True, False)),
        (String ((Ascii (False, False, True, False, True, True, True,
        False)), EmptyString)))))))))))))))))))))))))))))))))))))))

(** val make_binarith :
    binary_operation1 -> binary_operation1 -> binary_operation1 ->
    binary_operation1 -> binary_operation1 -> binary_operation1 -> expr1 ->
    type0 -> expr1 -> type0 -> expr1 res **)

let make_binarith iop iopu fop sop0 lop lopu e1 ty1 e2 ty2 =
  let c = classify_binarith ty1 ty2 in
  let ty = binarith_type c in
  bind (make_cast0 ty1 ty e1) (fun e1' ->
    bind (make_cast0 ty2 ty e2) (fun e2' ->
      match c with
      | Bin_case_i s ->
        (match s with
         | Signed -> OK (Ebinop1 (iop, e1', e2'))
         | Unsigned -> OK (Ebinop1 (iopu, e1', e2')))
      | Bin_case_l s ->
        (match s with
         | Signed -> OK (Ebinop1 (lop, e1', e2'))
         | Unsigned -> OK (Ebinop1 (lopu, e1', e2')))
      | Bin_case_f -> OK (Ebinop1 (fop, e1', e2'))
      | Bin_case_s -> OK (Ebinop1 (sop0, e1', e2'))
      | Bin_default ->
        Error
          (msg (String ((Ascii (True, True, False, False, False, False, True,
            False)), (String ((Ascii (True, True, False, False, True, True,
            True, False)), (String ((Ascii (False, False, False, True, False,
            True, True, False)), (String ((Ascii (True, False, True, True,
            False, True, True, False)), (String ((Ascii (True, True, True,
            False, False, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (False, True, True, True, False, True, False, False)), (String
            ((Ascii (True, False, True, True, False, True, True, False)),
            (String ((Ascii (True, False, False, False, False, True, True,
            False)), (String ((Ascii (True, True, False, True, False, True,
            True, False)), (String ((Ascii (True, False, True, False, False,
            True, True, False)), (String ((Ascii (True, True, True, True,
            True, False, True, False)), (String ((Ascii (False, True, False,
            False, False, True, True, False)), (String ((Ascii (True, False,
            False, True, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (True, False, False, False, False, True, True, False)), (String
            ((Ascii (False, True, False, False, True, True, True, False)),
            (String ((Ascii (True, False, False, True, False, True, True,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (False, False, False, True, False,
            True, True, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))

(** val make_add :
    composite_env -> expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_add ce e1 ty1 e2 ty2 =
  match classify_add ty1 ty2 with
  | Add_case_pi ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Oadd0, e1, (Ebinop1 (Omul0, n0, e2))))
  | Add_case_ip ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Oadd0, e2, (Ebinop1 (Omul0, n0, e1))))
  | Add_case_pl ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Oadd0, e1, (Ebinop1 (Omul0, n0, (Eunop1 (Ointoflong,
    e2))))))
  | Add_case_lp ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Oadd0, e2, (Ebinop1 (Omul0, n0, (Eunop1 (Ointoflong,
    e1))))))
  | Add_default ->
    make_binarith Oadd0 Oadd0 Oaddf Oaddfs Oaddl Oaddl e1 ty1 e2 ty2

(** val make_sub :
    composite_env -> expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_sub ce e1 ty1 e2 ty2 =
  match classify_sub ty1 ty2 with
  | Sub_case_pi ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Osub0, e1, (Ebinop1 (Omul0, n0, e2))))
  | Sub_case_pp ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Odiv0, (Ebinop1 (Osub0, e1, e2)), n0))
  | Sub_case_pl ty ->
    let n0 = make_intconst (Int.repr (sizeof ce ty)) in
    OK (Ebinop1 (Osub0, e1, (Ebinop1 (Omul0, n0, (Eunop1 (Ointoflong,
    e2))))))
  | Sub_default ->
    make_binarith Osub0 Osub0 Osubf Osubfs Osubl Osubl e1 ty1 e2 ty2

(** val make_mul : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_mul e1 ty1 e2 ty2 =
  make_binarith Omul0 Omul0 Omulf Omulfs Omull Omull e1 ty1 e2 ty2

(** val make_div : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_div e1 ty1 e2 ty2 =
  make_binarith Odiv0 Odivu Odivf Odivfs Odivl Odivlu e1 ty1 e2 ty2

(** val make_binarith_int :
    binary_operation1 -> binary_operation1 -> binary_operation1 ->
    binary_operation1 -> expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_binarith_int iop iopu lop lopu e1 ty1 e2 ty2 =
  let c = classify_binarith ty1 ty2 in
  let ty = binarith_type c in
  bind (make_cast0 ty1 ty e1) (fun e1' ->
    bind (make_cast0 ty2 ty e2) (fun e2' ->
      match c with
      | Bin_case_i s ->
        (match s with
         | Signed -> OK (Ebinop1 (iop, e1', e2'))
         | Unsigned -> OK (Ebinop1 (iopu, e1', e2')))
      | Bin_case_l s ->
        (match s with
         | Signed -> OK (Ebinop1 (lop, e1', e2'))
         | Unsigned -> OK (Ebinop1 (lopu, e1', e2')))
      | _ ->
        Error
          (msg (String ((Ascii (True, True, False, False, False, False, True,
            False)), (String ((Ascii (True, True, False, False, True, True,
            True, False)), (String ((Ascii (False, False, False, True, False,
            True, True, False)), (String ((Ascii (True, False, True, True,
            False, True, True, False)), (String ((Ascii (True, True, True,
            False, False, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (False, True, True, True, False, True, False, False)), (String
            ((Ascii (True, False, True, True, False, True, True, False)),
            (String ((Ascii (True, False, False, False, False, True, True,
            False)), (String ((Ascii (True, True, False, True, False, True,
            True, False)), (String ((Ascii (True, False, True, False, False,
            True, True, False)), (String ((Ascii (True, True, True, True,
            True, False, True, False)), (String ((Ascii (False, True, False,
            False, False, True, True, False)), (String ((Ascii (True, False,
            False, True, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (True, False, False, False, False, True, True, False)), (String
            ((Ascii (False, True, False, False, True, True, True, False)),
            (String ((Ascii (True, False, False, True, False, True, True,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (False, False, False, True, False,
            True, True, False)), (String ((Ascii (True, True, True, True,
            True, False, True, False)), (String ((Ascii (True, False, False,
            True, False, True, True, False)), (String ((Ascii (False, True,
            True, True, False, True, True, False)), (String ((Ascii (False,
            False, True, False, True, True, True, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val make_mod : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_mod e1 ty1 e2 ty2 =
  make_binarith_int Omod0 Omodu Omodl Omodlu e1 ty1 e2 ty2

(** val make_and : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_and e1 ty1 e2 ty2 =
  make_binarith_int Oand0 Oand0 Oandl Oandl e1 ty1 e2 ty2

(** val make_or : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_or e1 ty1 e2 ty2 =
  make_binarith_int Oor0 Oor0 Oorl Oorl e1 ty1 e2 ty2

(** val make_xor : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_xor e1 ty1 e2 ty2 =
  make_binarith_int Oxor0 Oxor0 Oxorl Oxorl e1 ty1 e2 ty2

(** val make_shl : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_shl e1 ty1 e2 ty2 =
  match classify_shift ty1 ty2 with
  | Shift_case_ii s -> OK (Ebinop1 (Oshl0, e1, e2))
  | Shift_case_ll s -> OK (Ebinop1 (Oshll, e1, (Eunop1 (Ointoflong, e2))))
  | Shift_case_il s -> OK (Ebinop1 (Oshl0, e1, (Eunop1 (Ointoflong, e2))))
  | Shift_case_li s -> OK (Ebinop1 (Oshll, e1, e2))
  | Shift_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)), (String ((Ascii
        (False, False, False, True, False, True, True, False)), (String
        ((Ascii (False, False, True, True, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))

(** val make_shr : expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_shr e1 ty1 e2 ty2 =
  match classify_shift ty1 ty2 with
  | Shift_case_ii s ->
    (match s with
     | Signed -> OK (Ebinop1 (Oshr0, e1, e2))
     | Unsigned -> OK (Ebinop1 (Oshru, e1, e2)))
  | Shift_case_ll s ->
    (match s with
     | Signed -> OK (Ebinop1 (Oshrl, e1, (Eunop1 (Ointoflong, e2))))
     | Unsigned -> OK (Ebinop1 (Oshrlu, e1, (Eunop1 (Ointoflong, e2)))))
  | Shift_case_il s ->
    (match s with
     | Signed -> OK (Ebinop1 (Oshr0, e1, (Eunop1 (Ointoflong, e2))))
     | Unsigned -> OK (Ebinop1 (Oshru, e1, (Eunop1 (Ointoflong, e2)))))
  | Shift_case_li s ->
    (match s with
     | Signed -> OK (Ebinop1 (Oshrl, e1, e2))
     | Unsigned -> OK (Ebinop1 (Oshrlu, e1, e2)))
  | Shift_default ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)), (String ((Ascii
        (False, False, False, True, False, True, True, False)), (String
        ((Ascii (False, True, False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))

(** val make_cmp :
    comparison0 -> expr1 -> type0 -> expr1 -> type0 -> expr1 res **)

let make_cmp c e1 ty1 e2 ty2 =
  match classify_cmp ty1 ty2 with
  | Cmp_case_pp -> OK (Ebinop1 ((Ocmpu c), e1, e2))
  | Cmp_case_pl -> OK (Ebinop1 ((Ocmpu c), e1, (Eunop1 (Ointoflong, e2))))
  | Cmp_case_lp -> OK (Ebinop1 ((Ocmpu c), (Eunop1 (Ointoflong, e1)), e2))
  | Cmp_default ->
    make_binarith (Ocmp c) (Ocmpu c) (Ocmpf c) (Ocmpfs c) (Ocmpl c) (Ocmplu
      c) e1 ty1 e2 ty2

(** val make_load : expr1 -> type0 -> expr1 res **)

let make_load addr ty_res =
  match access_mode ty_res with
  | By_value chunk -> OK (Eload0 (chunk, addr))
  | By_nothing ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (False, False, True, True, False, True, True, False)), (String
        ((Ascii (True, True, True, True, False, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, False, False, True, True,
        False)), EmptyString)))))))))))))))))))))))))))))))))))
  | _ -> OK addr

(** val make_memcpy : composite_env -> expr1 -> expr1 -> type0 -> stmt0 **)

let make_memcpy ce dst src ty =
  Sbuiltin1 (None, (EF_memcpy ((sizeof ce ty), (alignof_blockcopy ce ty))),
    (Cons (dst, (Cons (src, Nil)))))

(** val make_store :
    composite_env -> expr1 -> type0 -> expr1 -> stmt0 res **)

let make_store ce addr ty rhs0 =
  match access_mode ty with
  | By_value chunk -> OK (Sstore0 (chunk, addr, rhs0))
  | By_copy -> OK (make_memcpy ce addr rhs0 ty)
  | _ ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)), (String ((Ascii
        (False, False, True, False, True, True, True, False)), (String
        ((Ascii (True, True, True, True, False, True, True, False)), (String
        ((Ascii (False, True, False, False, True, True, True, False)),
        (String ((Ascii (True, False, True, False, False, True, True,
        False)), EmptyString)))))))))))))))))))))))))))))))))))))

(** val transl_unop : unary_operation -> expr1 -> type0 -> expr1 res **)

let transl_unop op a ta =
  match op with
  | Onotbool -> make_notbool a ta
  | Onotint -> make_notint a ta
  | Oneg -> make_neg a ta
  | Oabsfloat -> make_absfloat a ta

(** val transl_binop :
    composite_env -> binary_operation -> expr1 -> type0 -> expr1 -> type0 ->
    expr1 res **)

let transl_binop ce op a ta b tb =
  match op with
  | Oadd -> make_add ce a ta b tb
  | Osub -> make_sub ce a ta b tb
  | Omul -> make_mul a ta b tb
  | Odiv -> make_div a ta b tb
  | Omod -> make_mod a ta b tb
  | Oand -> make_and a ta b tb
  | Oor -> make_or a ta b tb
  | Oxor -> make_xor a ta b tb
  | Oshl -> make_shl a ta b tb
  | Oshr -> make_shr a ta b tb
  | Oeq -> make_cmp Ceq a ta b tb
  | One -> make_cmp Cne a ta b tb
  | Olt -> make_cmp Clt a ta b tb
  | Ogt -> make_cmp Cgt a ta b tb
  | Ole -> make_cmp Cle a ta b tb
  | Oge -> make_cmp Cge a ta b tb

(** val make_field_access :
    composite_env -> type0 -> ident -> expr1 -> expr1 res **)

let make_field_access ce ty f a =
  match ty with
  | Tstruct (id, a0) ->
    (match PTree.get id ce with
     | Some co ->
       bind (field_offset ce f co.co_members) (fun ofs -> OK (Ebinop1 (Oadd0,
         a, (make_intconst (Int.repr ofs)))))
     | None ->
       Error (Cons ((MSG (String ((Ascii (True, False, True, False, True,
         False, True, False)), (String ((Ascii (False, True, True, True,
         False, True, True, False)), (String ((Ascii (False, False, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, False, False, True, True, False)), (String ((Ascii
         (True, False, False, True, False, True, True, False)), (String
         ((Ascii (False, True, True, True, False, True, True, False)),
         (String ((Ascii (True, False, True, False, False, True, True,
         False)), (String ((Ascii (False, False, True, False, False, True,
         True, False)), (String ((Ascii (False, False, False, False, False,
         True, False, False)), (String ((Ascii (True, True, False, False,
         True, True, True, False)), (String ((Ascii (False, False, True,
         False, True, True, True, False)), (String ((Ascii (False, True,
         False, False, True, True, True, False)), (String ((Ascii (True,
         False, True, False, True, True, True, False)), (String ((Ascii
         (True, True, False, False, False, True, True, False)), (String
         ((Ascii (False, False, True, False, True, True, True, False)),
         (String ((Ascii (False, False, False, False, False, True, False,
         False)), EmptyString))))))))))))))))))))))))))))))))))), (Cons ((CTX
         id), Nil)))))
  | Tunion (id, a0) -> OK a
  | _ ->
    Error
      (msg (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (False, False, False, True, False, True,
        True, False)), (String ((Ascii (True, False, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, False, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, True, False)), (String ((Ascii (False, True, True, True, False,
        True, False, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, True, True, True, False, True, False)), (String ((Ascii
        (False, True, True, False, False, True, True, False)), (String
        ((Ascii (True, False, False, True, False, True, True, False)),
        (String ((Ascii (True, False, True, False, False, True, True,
        False)), (String ((Ascii (False, False, True, True, False, True,
        True, False)), (String ((Ascii (False, False, True, False, False,
        True, True, False)), (String ((Ascii (True, True, True, True, True,
        False, True, False)), (String ((Ascii (True, False, False, False,
        False, True, True, False)), (String ((Ascii (True, True, False,
        False, False, True, True, False)), (String ((Ascii (True, True,
        False, False, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))

(** val transl_expr : composite_env -> expr -> expr1 res **)

let rec transl_expr ce = function
| Econst_int (n0, t1) -> OK (make_intconst n0)
| Econst_float (n0, t1) -> OK (make_floatconst n0)
| Econst_single (n0, t1) -> OK (make_singleconst n0)
| Econst_long (n0, t1) -> OK (make_longconst n0)
| Evar (id, ty) -> make_load (Eaddrof0 id) ty
| Etempvar (id, ty) -> OK (Evar1 id)
| Ederef (b, ty) -> bind (transl_expr ce b) (fun tb -> make_load tb ty)
| Eaddrof (b, t1) -> transl_lvalue ce b
| Eunop (op, b, t1) ->
  bind (transl_expr ce b) (fun tb -> transl_unop op tb (typeof b))
| Ebinop (op, b, c, t1) ->
  bind (transl_expr ce b) (fun tb ->
    bind (transl_expr ce c) (fun tc ->
      transl_binop ce op tb (typeof b) tc (typeof c)))
| Ecast (b, ty) ->
  bind (transl_expr ce b) (fun tb -> make_cast0 (typeof b) ty tb)
| Efield (b, i, ty) ->
  bind (transl_expr ce b) (fun tb ->
    bind (make_field_access ce (typeof b) i tb) (fun addr ->
      make_load addr ty))
| Esizeof (ty', ty) -> OK (make_intconst (Int.repr (sizeof ce ty')))
| Ealignof (ty', ty) -> OK (make_intconst (Int.repr (alignof ce ty')))

(** val transl_lvalue : composite_env -> expr -> expr1 res **)

and transl_lvalue ce = function
| Evar (id, t1) -> OK (Eaddrof0 id)
| Ederef (b, t1) -> transl_expr ce b
| Efield (b, i, ty) ->
  bind (transl_expr ce b) (fun tb -> make_field_access ce (typeof b) i tb)
| _ ->
  Error
    (msg (String ((Ascii (True, True, False, False, False, False, True,
      False)), (String ((Ascii (True, True, False, False, True, True, True,
      False)), (String ((Ascii (False, False, False, True, False, True, True,
      False)), (String ((Ascii (True, False, True, True, False, True, True,
      False)), (String ((Ascii (True, True, True, False, False, True, True,
      False)), (String ((Ascii (True, False, True, False, False, True, True,
      False)), (String ((Ascii (False, True, True, True, False, True, True,
      False)), (String ((Ascii (False, True, True, True, False, True, False,
      False)), (String ((Ascii (False, False, True, False, True, True, True,
      False)), (String ((Ascii (False, True, False, False, True, True, True,
      False)), (String ((Ascii (True, False, False, False, False, True, True,
      False)), (String ((Ascii (False, True, True, True, False, True, True,
      False)), (String ((Ascii (True, True, False, False, True, True, True,
      False)), (String ((Ascii (False, False, True, True, False, True, True,
      False)), (String ((Ascii (True, True, True, True, True, False, True,
      False)), (String ((Ascii (False, False, True, True, False, True, True,
      False)), (String ((Ascii (False, True, True, False, True, True, True,
      False)), (String ((Ascii (True, False, False, False, False, True, True,
      False)), (String ((Ascii (False, False, True, True, False, True, True,
      False)), (String ((Ascii (True, False, True, False, True, True, True,
      False)), (String ((Ascii (True, False, True, False, False, True, True,
      False)), EmptyString)))))))))))))))))))))))))))))))))))))))))))

(** val transl_arglist :
    composite_env -> expr list -> typelist -> expr1 list res **)

let rec transl_arglist ce al tyl =
  match al with
  | Nil ->
    (match tyl with
     | Tnil -> OK Nil
     | Tcons (t1, t2) ->
       Error
         (msg (String ((Ascii (True, True, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (False, False, False, True, False,
           True, True, False)), (String ((Ascii (True, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           False, False, True, True, False)), (String ((Ascii (True, False,
           True, False, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, False, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (False, True, False, False, True, True, True,
           False)), (String ((Ascii (True, False, False, False, False, True,
           True, False)), (String ((Ascii (False, True, True, True, False,
           True, True, False)), (String ((Ascii (True, True, False, False,
           True, True, True, False)), (String ((Ascii (False, False, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, True, True, False, True, False)), (String ((Ascii (True,
           False, False, False, False, True, True, False)), (String ((Ascii
           (False, True, False, False, True, True, True, False)), (String
           ((Ascii (True, True, True, False, False, True, True, False)),
           (String ((Ascii (False, False, True, True, False, True, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, False,
           True, True, True, False)), (String ((Ascii (False, True, False,
           True, True, True, False, False)), (String ((Ascii (False, False,
           False, False, False, True, False, False)), (String ((Ascii (True,
           False, False, False, False, True, True, False)), (String ((Ascii
           (False, True, False, False, True, True, True, False)), (String
           ((Ascii (True, False, False, True, False, True, True, False)),
           (String ((Ascii (False, False, True, False, True, True, True,
           False)), (String ((Ascii (True, False, False, True, True, True,
           True, False)), (String ((Ascii (False, False, False, False, False,
           True, False, False)), (String ((Ascii (True, False, True, True,
           False, True, True, False)), (String ((Ascii (True, False, False,
           True, False, True, True, False)), (String ((Ascii (True, True,
           False, False, True, True, True, False)), (String ((Ascii (True,
           False, True, True, False, True, True, False)), (String ((Ascii
           (True, False, False, False, False, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, False, False, False, True, True,
           False)), (String ((Ascii (False, False, False, True, False, True,
           True, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  | Cons (a1, a2) ->
    (match tyl with
     | Tnil ->
       bind (transl_expr ce a1) (fun ta1 ->
         bind
           (make_cast0 (typeof a1) (default_argument_conversion (typeof a1))
             ta1) (fun ta1' ->
           bind (transl_arglist ce a2 Tnil) (fun ta2 -> OK (Cons (ta1',
             ta2)))))
     | Tcons (ty1, ty2) ->
       bind (transl_expr ce a1) (fun ta1 ->
         bind (make_cast0 (typeof a1) ty1 ta1) (fun ta1' ->
           bind (transl_arglist ce a2 ty2) (fun ta2 -> OK (Cons (ta1', ta2))))))

(** val typlist_of_arglist : expr list -> typelist -> typ list **)

let rec typlist_of_arglist al tyl =
  match al with
  | Nil -> Nil
  | Cons (a1, a2) ->
    (match tyl with
     | Tnil ->
       Cons ((typ_of_type (default_argument_conversion (typeof a1))),
         (typlist_of_arglist a2 Tnil))
     | Tcons (ty1, ty2) ->
       Cons ((typ_of_type ty1), (typlist_of_arglist a2 ty2)))

(** val transl_statement :
    composite_env -> type0 -> nat -> nat -> statement -> stmt0 res **)

let rec transl_statement ce tyret nbrk ncnt = function
| Sskip -> OK Sskip1
| Sassign (b, c) ->
  bind (transl_lvalue ce b) (fun tb ->
    bind (transl_expr ce c) (fun tc ->
      bind (make_cast0 (typeof c) (typeof b) tc) (fun tc' ->
        make_store ce tb (typeof b) tc')))
| Sset (x, b) -> bind (transl_expr ce b) (fun tb -> OK (Sset0 (x, tb)))
| Scall (x, b, cl) ->
  (match classify_fun (typeof b) with
   | Fun_case_f (args, res2, cconv) ->
     bind (transl_expr ce b) (fun tb ->
       bind (transl_arglist ce cl args) (fun tcl -> OK (Scall1 (x,
         { sig_args = (typlist_of_arglist cl args); sig_res =
         (opttyp_of_type res2); sig_cc = cconv }, tb, tcl))))
   | Fun_default ->
     Error
       (msg (String ((Ascii (True, True, False, False, False, False, True,
         False)), (String ((Ascii (True, True, False, False, True, True,
         True, False)), (String ((Ascii (False, False, False, True, False,
         True, True, False)), (String ((Ascii (True, False, True, True,
         False, True, True, False)), (String ((Ascii (True, True, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, False, False)), (String
         ((Ascii (False, False, True, False, True, True, True, False)),
         (String ((Ascii (False, True, False, False, True, True, True,
         False)), (String ((Ascii (True, False, False, False, False, True,
         True, False)), (String ((Ascii (False, True, True, True, False,
         True, True, False)), (String ((Ascii (True, True, False, False,
         True, True, True, False)), (String ((Ascii (False, False, True,
         True, False, True, True, False)), (String ((Ascii (True, True, True,
         True, True, False, True, False)), (String ((Ascii (True, True,
         False, False, True, True, True, False)), (String ((Ascii (False,
         False, True, False, True, True, True, False)), (String ((Ascii
         (True, False, True, True, False, True, True, False)), (String
         ((Ascii (False, False, True, False, True, True, True, False)),
         (String ((Ascii (False, False, False, True, False, True, False,
         False)), (String ((Ascii (True, True, False, False, False, True,
         True, False)), (String ((Ascii (True, False, False, False, False,
         True, True, False)), (String ((Ascii (False, False, True, True,
         False, True, True, False)), (String ((Ascii (False, False, True,
         True, False, True, True, False)), (String ((Ascii (True, False,
         False, True, False, True, False, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))
| Sbuiltin (x, ef, tyargs, bl) ->
  bind (transl_arglist ce bl tyargs) (fun tbl -> OK (Sbuiltin1 (x, ef, tbl)))
| Ssequence (s1, s2) ->
  bind (transl_statement ce tyret nbrk ncnt s1) (fun ts1 ->
    bind (transl_statement ce tyret nbrk ncnt s2) (fun ts2 -> OK (Sseq0 (ts1,
      ts2))))
| Sifthenelse (e, s1, s2) ->
  bind (transl_expr ce e) (fun te ->
    bind (transl_statement ce tyret nbrk ncnt s1) (fun ts1 ->
      bind (transl_statement ce tyret nbrk ncnt s2) (fun ts2 -> OK
        (Sifthenelse1 ((make_boolean te (typeof e)), ts1, ts2)))))
| Sloop (s1, s2) ->
  bind (transl_statement ce tyret (S O) O s1) (fun ts1 ->
    bind (transl_statement ce tyret O (S ncnt) s2) (fun ts2 -> OK (Sblock0
      (Sloop1 (Sseq0 ((Sblock0 ts1), ts2))))))
| Sbreak -> OK (Sexit0 nbrk)
| Scontinue -> OK (Sexit0 ncnt)
| Sreturn o ->
  (match o with
   | Some e ->
     bind (transl_expr ce e) (fun te ->
       bind (make_cast0 (typeof e) tyret te) (fun te' -> OK (Sreturn1 (Some
         te'))))
   | None -> OK (Sreturn1 None))
| Sswitch (a, sl) ->
  bind (transl_expr ce a) (fun ta ->
    bind (transl_lbl_stmt ce tyret O (S ncnt) sl) (fun tsl ->
      match classify_switch (typeof a) with
      | Switch_case_i -> OK (Sblock0 (Sswitch1 (False, ta, tsl)))
      | Switch_case_l -> OK (Sblock0 (Sswitch1 (True, ta, tsl)))
      | Switch_default ->
        Error
          (msg (String ((Ascii (True, True, False, False, False, False, True,
            False)), (String ((Ascii (True, True, False, False, True, True,
            True, False)), (String ((Ascii (False, False, False, True, False,
            True, True, False)), (String ((Ascii (True, False, True, True,
            False, True, True, False)), (String ((Ascii (True, True, True,
            False, False, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (False, True, True, True, False, True, False, False)), (String
            ((Ascii (False, False, True, False, True, True, True, False)),
            (String ((Ascii (False, True, False, False, True, True, True,
            False)), (String ((Ascii (True, False, False, False, False, True,
            True, False)), (String ((Ascii (False, True, True, True, False,
            True, True, False)), (String ((Ascii (True, True, False, False,
            True, True, True, False)), (String ((Ascii (False, False, True,
            True, False, True, True, False)), (String ((Ascii (True, True,
            True, True, True, False, True, False)), (String ((Ascii (True,
            True, False, False, True, True, True, False)), (String ((Ascii
            (False, False, True, False, True, True, True, False)), (String
            ((Ascii (True, False, True, True, False, True, True, False)),
            (String ((Ascii (False, False, True, False, True, True, True,
            False)), (String ((Ascii (False, False, False, True, False, True,
            False, False)), (String ((Ascii (True, True, False, False, True,
            True, True, False)), (String ((Ascii (True, True, True, False,
            True, True, True, False)), (String ((Ascii (True, False, False,
            True, False, True, True, False)), (String ((Ascii (False, False,
            True, False, True, True, True, False)), (String ((Ascii (True,
            True, False, False, False, True, True, False)), (String ((Ascii
            (False, False, False, True, False, True, True, False)), (String
            ((Ascii (True, False, False, True, False, True, False, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
| Slabel (lbl, s0) ->
  bind (transl_statement ce tyret nbrk ncnt s0) (fun ts -> OK (Slabel1 (lbl,
    ts)))
| Sgoto lbl -> OK (Sgoto1 lbl)

(** val transl_lbl_stmt :
    composite_env -> type0 -> nat -> nat -> labeled_statements -> lbl_stmt
    res **)

and transl_lbl_stmt ce tyret nbrk ncnt = function
| LSnil -> OK LSnil0
| LScons (n0, s, sl') ->
  bind (transl_statement ce tyret nbrk ncnt s) (fun ts ->
    bind (transl_lbl_stmt ce tyret nbrk ncnt sl') (fun tsl' -> OK (LScons0
      (n0, ts, tsl'))))

(** val transl_var :
    composite_env -> (ident, type0) prod -> (ident, z) prod **)

let transl_var ce v =
  Pair ((fst v), (sizeof ce (snd v)))

(** val signature_of_function : function0 -> signature **)

let signature_of_function f =
  { sig_args = (map typ_of_type (map snd f.fn_params)); sig_res =
    (opttyp_of_type f.fn_return); sig_cc = f.fn_callconv }

(** val transl_function : composite_env -> function0 -> function2 res **)

let transl_function ce f =
  bind (transl_statement ce f.fn_return (S O) O f.fn_body) (fun tbody -> OK
    { fn_sig0 = (signature_of_function f); fn_params1 =
    (map fst f.fn_params); fn_vars1 = (map (transl_var ce) f.fn_vars);
    fn_temps0 = (map fst f.fn_temps); fn_body1 = tbody })

(** val transl_fundef : composite_env -> fundef0 -> fundef2 res **)

let transl_fundef ce = function
| Internal0 g -> bind (transl_function ce g) (fun tg -> OK (Internal tg))
| External0 (ef, args, res2, cconv) ->
  (match signature_eq (ef_sig ef) (signature_of_type args res2 cconv) with
   | Left -> OK (External ef)
   | Right ->
     Error
       (msg (String ((Ascii (True, True, False, False, False, False, True,
         False)), (String ((Ascii (True, True, False, False, True, True,
         True, False)), (String ((Ascii (False, False, False, True, False,
         True, True, False)), (String ((Ascii (True, False, True, True,
         False, True, True, False)), (String ((Ascii (True, True, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, False, False)), (String
         ((Ascii (False, False, True, False, True, True, True, False)),
         (String ((Ascii (False, True, False, False, True, True, True,
         False)), (String ((Ascii (True, False, False, False, False, True,
         True, False)), (String ((Ascii (False, True, True, True, False,
         True, True, False)), (String ((Ascii (True, True, False, False,
         True, True, True, False)), (String ((Ascii (False, False, True,
         True, False, True, True, False)), (String ((Ascii (True, True, True,
         True, True, False, True, False)), (String ((Ascii (False, True,
         True, False, False, True, True, False)), (String ((Ascii (True,
         False, True, False, True, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, True, False)), (String
         ((Ascii (False, False, True, False, False, True, True, False)),
         (String ((Ascii (True, False, True, False, False, True, True,
         False)), (String ((Ascii (False, True, True, False, False, True,
         True, False)), (String ((Ascii (False, True, False, True, True,
         True, False, False)), (String ((Ascii (False, False, False, False,
         False, True, False, False)), (String ((Ascii (True, True, True,
         False, True, True, True, False)), (String ((Ascii (False, True,
         False, False, True, True, True, False)), (String ((Ascii (True,
         True, True, True, False, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, True, False)), (String
         ((Ascii (True, True, True, False, False, True, True, False)),
         (String ((Ascii (False, False, False, False, False, True, False,
         False)), (String ((Ascii (True, False, True, False, False, True,
         True, False)), (String ((Ascii (False, False, False, True, True,
         True, True, False)), (String ((Ascii (False, False, True, False,
         True, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (False, True,
         False, False, True, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii (True,
         False, False, False, False, True, True, False)), (String ((Ascii
         (False, False, True, True, False, True, True, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (True, True, False, False, True, True, True,
         False)), (String ((Ascii (True, False, False, True, False, True,
         True, False)), (String ((Ascii (True, True, True, False, False,
         True, True, False)), (String ((Ascii (False, True, True, True,
         False, True, True, False)), (String ((Ascii (True, False, False,
         False, False, True, True, False)), (String ((Ascii (False, False,
         True, False, True, True, True, False)), (String ((Ascii (True,
         False, True, False, True, True, True, False)), (String ((Ascii
         (False, True, False, False, True, True, True, False)), (String
         ((Ascii (True, False, True, False, False, True, True, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val transl_globvar : type0 -> unit0 res **)

let transl_globvar ty =
  OK Tt

(** val transl_program : program0 -> program2 res **)

let transl_program p =
  transform_partial_program2 (transl_fundef p.prog_comp_env) transl_globvar
    (program_of_program p)

module Sort = 
 functor (X:TotalLeBool') ->
 struct 
  (** val merge : X.t list -> X.t list -> X.t list **)
  
  let rec merge l1 l2 =
    let rec merge_aux l3 =
      match l1 with
      | Nil -> l3
      | Cons (a1, l1') ->
        (match l3 with
         | Nil -> l1
         | Cons (a2, l2') ->
           (match X.leb a1 a2 with
            | True -> Cons (a1, (merge l1' l3))
            | False -> Cons (a2, (merge_aux l2'))))
    in merge_aux l2
  
  (** val merge_list_to_stack :
      X.t list option list -> X.t list -> X.t list option list **)
  
  let rec merge_list_to_stack stack l =
    match stack with
    | Nil -> Cons ((Some l), Nil)
    | Cons (y, stack') ->
      (match y with
       | Some l' -> Cons (None, (merge_list_to_stack stack' (merge l' l)))
       | None -> Cons ((Some l), stack'))
  
  (** val merge_stack : X.t list option list -> X.t list **)
  
  let rec merge_stack = function
  | Nil -> Nil
  | Cons (y, stack') ->
    (match y with
     | Some l -> merge l (merge_stack stack')
     | None -> merge_stack stack')
  
  (** val iter_merge : X.t list option list -> X.t list -> X.t list **)
  
  let rec iter_merge stack = function
  | Nil -> merge_stack stack
  | Cons (a, l') -> iter_merge (merge_list_to_stack stack (Cons (a, Nil))) l'
  
  (** val sort : X.t list -> X.t list **)
  
  let sort =
    iter_merge Nil
  
  (** val flatten_stack : X.t list option list -> X.t list **)
  
  let rec flatten_stack = function
  | Nil -> Nil
  | Cons (o, stack') ->
    (match o with
     | Some l -> app l (flatten_stack stack')
     | None -> flatten_stack stack')
 end

type compilenv0 = z PTree.t

(** val var_addr : compilenv0 -> ident -> expr0 **)

let var_addr cenv id =
  match PTree.get id cenv with
  | Some ofs -> Econst (Oaddrstack (Int.repr ofs))
  | None -> Econst (Oaddrsymbol (id, Int.zero))

(** val transl_constant : constant0 -> constant **)

let transl_constant = function
| Ointconst0 n0 -> Ointconst n0
| Ofloatconst0 n0 -> Ofloatconst n0
| Osingleconst0 n0 -> Osingleconst n0
| Olongconst0 n0 -> Olongconst n0

(** val transl_expr0 : compilenv0 -> expr1 -> expr0 res **)

let rec transl_expr0 cenv = function
| Evar1 id -> OK (Evar0 id)
| Eaddrof0 id -> OK (var_addr cenv id)
| Econst0 cst -> OK (Econst (transl_constant cst))
| Eunop1 (op, e1) ->
  bind (transl_expr0 cenv e1) (fun te1 -> OK (Eunop0 (op, te1)))
| Ebinop1 (op, e1, e2) ->
  bind (transl_expr0 cenv e1) (fun te1 ->
    bind (transl_expr0 cenv e2) (fun te2 -> OK (Ebinop0 (op, te1, te2))))
| Eload0 (chunk, e0) ->
  bind (transl_expr0 cenv e0) (fun te -> OK (Eload (chunk, te)))

(** val transl_exprlist : compilenv0 -> expr1 list -> expr0 list res **)

let rec transl_exprlist cenv = function
| Nil -> OK Nil
| Cons (e1, e2) ->
  bind (transl_expr0 cenv e1) (fun te1 ->
    bind (transl_exprlist cenv e2) (fun te2 -> OK (Cons (te1, te2))))

type exit_env = bool list

(** val shift_exit : exit_env -> nat -> nat **)

let rec shift_exit e n0 =
  match e with
  | Nil -> n0
  | Cons (b, e') ->
    (match b with
     | True ->
       (match n0 with
        | O -> O
        | S m0 -> S (shift_exit e' m0))
     | False -> S (shift_exit e' n0))

(** val switch_table : lbl_stmt -> nat -> ((z, nat) prod list, nat) prod **)

let rec switch_table ls k =
  match ls with
  | LSnil0 -> Pair (Nil, k)
  | LScons0 (o, s, rem0) ->
    (match o with
     | Some ni ->
       let Pair (tbl, dfl) = switch_table rem0 (S k) in
       Pair ((Cons ((Pair (ni, k)), tbl)), dfl)
     | None -> let Pair (tbl, dfl) = switch_table rem0 (S k) in Pair (tbl, k))

(** val switch_env : lbl_stmt -> exit_env -> exit_env **)

let rec switch_env ls e =
  match ls with
  | LSnil0 -> e
  | LScons0 (o, s, ls') -> Cons (False, (switch_env ls' e))

(** val transl_stmt : compilenv0 -> exit_env -> stmt0 -> stmt res **)

let rec transl_stmt cenv xenv = function
| Sskip1 -> OK Sskip0
| Sset0 (id, e) ->
  bind (transl_expr0 cenv e) (fun te -> OK (Sassign0 (id, te)))
| Sstore0 (chunk, e1, e2) ->
  bind (transl_expr0 cenv e1) (fun te1 ->
    bind (transl_expr0 cenv e2) (fun te2 -> OK (Sstore (chunk, te1, te2))))
| Scall1 (optid, sig1, e, el) ->
  bind (transl_expr0 cenv e) (fun te ->
    bind (transl_exprlist cenv el) (fun tel -> OK (Scall0 (optid, sig1, te,
      tel))))
| Sbuiltin1 (optid, ef, el) ->
  bind (transl_exprlist cenv el) (fun tel -> OK (Sbuiltin0 (optid, ef, tel)))
| Sseq0 (s1, s2) ->
  bind (transl_stmt cenv xenv s1) (fun ts1 ->
    bind (transl_stmt cenv xenv s2) (fun ts2 -> OK (Sseq (ts1, ts2))))
| Sifthenelse1 (e, s1, s2) ->
  bind (transl_expr0 cenv e) (fun te ->
    bind (transl_stmt cenv xenv s1) (fun ts1 ->
      bind (transl_stmt cenv xenv s2) (fun ts2 -> OK (Sifthenelse0 (te, ts1,
        ts2)))))
| Sloop1 s0 -> bind (transl_stmt cenv xenv s0) (fun ts -> OK (Sloop0 ts))
| Sblock0 s0 ->
  bind (transl_stmt cenv (Cons (True, xenv)) s0) (fun ts -> OK (Sblock ts))
| Sexit0 n0 -> OK (Sexit (shift_exit xenv n0))
| Sswitch1 (long, e, ls) ->
  let Pair (tbl, dfl) = switch_table ls O in
  bind (transl_expr0 cenv e) (fun te ->
    transl_lblstmt cenv (switch_env ls xenv) ls (Sswitch0 (long, te, tbl,
      dfl)))
| Sreturn1 o ->
  (match o with
   | Some e -> bind (transl_expr0 cenv e) (fun te -> OK (Sreturn0 (Some te)))
   | None -> OK (Sreturn0 None))
| Slabel1 (lbl, s0) ->
  bind (transl_stmt cenv xenv s0) (fun ts -> OK (Slabel0 (lbl, ts)))
| Sgoto1 lbl -> OK (Sgoto0 lbl)

(** val transl_lblstmt :
    compilenv0 -> exit_env -> lbl_stmt -> stmt -> stmt res **)

and transl_lblstmt cenv xenv ls body =
  match ls with
  | LSnil0 -> OK (Sseq ((Sblock body), Sskip0))
  | LScons0 (o, s, ls') ->
    bind (transl_stmt cenv xenv s) (fun ts ->
      transl_lblstmt cenv (tl xenv) ls' (Sseq ((Sblock body), ts)))

(** val block_alignment : z -> z **)

let block_alignment sz =
  match zlt sz (Zpos (XO XH)) with
  | Left -> Zpos XH
  | Right ->
    (match zlt sz (Zpos (XO (XO XH))) with
     | Left -> Zpos (XO XH)
     | Right ->
       (match zlt sz (Zpos (XO (XO (XO XH)))) with
        | Left -> Zpos (XO (XO XH))
        | Right -> Zpos (XO (XO (XO XH)))))

(** val assign_variable :
    (compilenv0, z) prod -> (ident, z) prod -> (compilenv0, z) prod **)

let assign_variable cenv_stacksize = function
| Pair (id, sz) ->
  let Pair (cenv, stacksize) = cenv_stacksize in
  let ofs = align stacksize (block_alignment sz) in
  Pair ((PTree.set id ofs cenv), (Z.add ofs (Z.max Z0 sz)))

(** val assign_variables :
    (compilenv0, z) prod -> (ident, z) prod list -> (compilenv0, z) prod **)

let assign_variables cenv_stacksize vars =
  fold_left assign_variable vars cenv_stacksize

module VarOrder = 
 struct 
  type t = (ident, z) prod
  
  (** val leb : t -> t -> bool **)
  
  let leb v1 v2 =
    proj_sumbool (zle (snd v1) (snd v2))
 end

module VarSort = Sort(VarOrder)

(** val build_compilenv : function2 -> (compilenv0, z) prod **)

let build_compilenv f =
  assign_variables (Pair (PTree.empty, Z0)) (VarSort.sort f.fn_vars1)

(** val transl_funbody : compilenv0 -> z -> function2 -> function1 res **)

let transl_funbody cenv stacksize f =
  bind (transl_stmt cenv Nil f.fn_body1) (fun tbody -> OK { fn_sig =
    f.fn_sig0; fn_params0 = f.fn_params1; fn_vars0 = f.fn_temps0;
    fn_stackspace = stacksize; fn_body0 = tbody })

(** val transl_function0 : function2 -> function1 res **)

let transl_function0 f =
  let Pair (cenv, stacksize) = build_compilenv f in
  (match zle stacksize Int.max_unsigned with
   | Left -> transl_funbody cenv stacksize f
   | Right ->
     Error
       (msg (String ((Ascii (True, True, False, False, False, False, True,
         False)), (String ((Ascii (True, False, True, True, False, True,
         True, False)), (String ((Ascii (True, False, False, True, False,
         True, True, False)), (String ((Ascii (False, True, True, True,
         False, True, True, False)), (String ((Ascii (True, True, True, True,
         False, True, True, False)), (String ((Ascii (False, True, False,
         False, True, True, True, False)), (String ((Ascii (True, True, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii
         (False, True, False, True, True, True, False, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (False, False, True, False, True, True, True,
         False)), (String ((Ascii (True, True, True, True, False, True, True,
         False)), (String ((Ascii (True, True, True, True, False, True, True,
         False)), (String ((Ascii (False, False, False, False, False, True,
         False, False)), (String ((Ascii (True, False, True, True, False,
         True, True, False)), (String ((Ascii (True, False, False, False,
         False, True, True, False)), (String ((Ascii (False, True, True,
         True, False, True, True, False)), (String ((Ascii (True, False,
         False, True, True, True, True, False)), (String ((Ascii (False,
         False, False, False, False, True, False, False)), (String ((Ascii
         (False, False, True, True, False, True, True, False)), (String
         ((Ascii (True, True, True, True, False, True, True, False)), (String
         ((Ascii (True, True, False, False, False, True, True, False)),
         (String ((Ascii (True, False, False, False, False, True, True,
         False)), (String ((Ascii (False, False, True, True, False, True,
         True, False)), (String ((Ascii (False, False, False, False, False,
         True, False, False)), (String ((Ascii (False, True, True, False,
         True, True, True, False)), (String ((Ascii (True, False, False,
         False, False, True, True, False)), (String ((Ascii (False, True,
         False, False, True, True, True, False)), (String ((Ascii (True,
         False, False, True, False, True, True, False)), (String ((Ascii
         (True, False, False, False, False, True, True, False)), (String
         ((Ascii (False, True, False, False, False, True, True, False)),
         (String ((Ascii (False, False, True, True, False, True, True,
         False)), (String ((Ascii (True, False, True, False, False, True,
         True, False)), (String ((Ascii (True, True, False, False, True,
         True, True, False)), (String ((Ascii (False, False, True, True,
         False, True, False, False)), (String ((Ascii (False, False, False,
         False, False, True, False, False)), (String ((Ascii (True, True,
         False, False, True, True, True, False)), (String ((Ascii (False,
         False, True, False, True, True, True, False)), (String ((Ascii
         (True, False, False, False, False, True, True, False)), (String
         ((Ascii (True, True, False, False, False, True, True, False)),
         (String ((Ascii (True, True, False, True, False, True, True,
         False)), (String ((Ascii (False, False, False, False, False, True,
         False, False)), (String ((Ascii (True, True, False, False, True,
         True, True, False)), (String ((Ascii (True, False, False, True,
         False, True, True, False)), (String ((Ascii (False, True, False,
         True, True, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (False, False,
         False, False, False, True, False, False)), (String ((Ascii (True,
         False, True, False, False, True, True, False)), (String ((Ascii
         (False, False, False, True, True, True, True, False)), (String
         ((Ascii (True, True, False, False, False, True, True, False)),
         (String ((Ascii (True, False, True, False, False, True, True,
         False)), (String ((Ascii (True, False, True, False, False, True,
         True, False)), (String ((Ascii (False, False, True, False, False,
         True, True, False)), (String ((Ascii (True, False, True, False,
         False, True, True, False)), (String ((Ascii (False, False, True,
         False, False, True, True, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val transl_fundef0 : fundef2 -> fundef1 res **)

let transl_fundef0 f =
  transf_partial_fundef transl_function0 f

(** val transl_program0 : program2 -> program1 res **)

let transl_program0 p =
  transform_partial_program transl_fundef0 p

(** val symbol_is_external : ident -> bool **)

let symbol_is_external =
  failwith "AXIOM TO BE REALIZED"

(** val addrsymbol : ident -> Int.int -> expr2 **)

let addrsymbol id ofs =
  match symbol_is_external id with
  | True ->
    (match Int.eq ofs Int.zero with
     | True -> Eop ((Oindirectsymbol id), Enil)
     | False ->
       Eop ((Olea (Aindexed ofs)), (Econs ((Eop ((Oindirectsymbol id),
         Enil)), Enil))))
  | False -> Eop ((Olea (Aglobal (id, ofs))), Enil)

(** val addrstack : Int.int -> expr2 **)

let addrstack ofs =
  Eop ((Olea (Ainstack ofs)), Enil)

type notint_cases =
| Notint_case1 of Int.int
| Notint_case2 of Int.int * expr2
| Notint_default0 of expr2

(** val notint_match : expr2 -> notint_cases **)

let notint_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Notint_case1 n0
      | Econs (e1, e2) ->
        Notint_default0 (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | Oxorimm n0 ->
     (match e0 with
      | Enil -> Notint_default0 (Eop ((Oxorimm n0), Enil))
      | Econs (e1, e2) ->
        (match e2 with
         | Enil -> Notint_case2 (n0, e1)
         | Econs (e3, e4) ->
           Notint_default0 (Eop ((Oxorimm n0), (Econs (e1, (Econs (e3,
             e4))))))))
   | x -> Notint_default0 (Eop (x, e0)))
| x -> Notint_default0 x

(** val notint0 : expr2 -> expr2 **)

let notint0 e =
  match notint_match e with
  | Notint_case1 n0 -> Eop ((Ointconst1 (Int.not n0)), Enil)
  | Notint_case2 (n0, e1) -> Eop ((Oxorimm (Int.not n0)), (Econs (e1, Enil)))
  | Notint_default0 e0 -> Eop (Onot, (Econs (e0, Enil)))

type addimm_cases =
| Addimm_case1 of Int.int
| Addimm_case2 of addressing * exprlist
| Addimm_default of expr2

(** val addimm_match : expr2 -> addimm_cases **)

let addimm_match = function
| Eop (o, args) ->
  (match o with
   | Ointconst1 m0 ->
     (match args with
      | Enil -> Addimm_case1 m0
      | Econs (e0, e1) ->
        Addimm_default (Eop ((Ointconst1 m0), (Econs (e0, e1)))))
   | Olea addr -> Addimm_case2 (addr, args)
   | x -> Addimm_default (Eop (x, args)))
| x -> Addimm_default x

(** val addimm : Int.int -> expr2 -> expr2 **)

let addimm n0 e =
  match Int.eq n0 Int.zero with
  | True -> e
  | False ->
    (match addimm_match e with
     | Addimm_case1 m0 -> Eop ((Ointconst1 (Int.add n0 m0)), Enil)
     | Addimm_case2 (addr, args) ->
       Eop ((Olea (offset_addressing_total addr n0)), args)
     | Addimm_default e0 -> Eop ((Olea (Aindexed n0)), (Econs (e0, Enil))))

type add_cases =
| Add_case1 of Int.int * expr2
| Add_case2 of expr2 * Int.int
| Add_case3 of Int.int * expr2 * Int.int * expr2
| Add_case4 of Int.int * expr2 * Int.int * Int.int * expr2
| Add_case5 of Int.int * Int.int * expr2 * Int.int * expr2
| Add_case6 of Int.int * expr2 * ident * Int.int
| Add_case7 of ident * Int.int * Int.int * expr2
| Add_case8 of Int.int * Int.int * expr2 * ident * Int.int
| Add_case9 of ident * Int.int * Int.int * Int.int * expr2
| Add_case10 of Int.int * Int.int * expr2 * expr2
| Add_case11 of expr2 * Int.int * Int.int * expr2
| Add_case12 of Int.int * expr2 * expr2
| Add_case13 of expr2 * Int.int * expr2
| Add_default0 of expr2 * expr2

(** val add_match : expr2 -> expr2 -> add_cases **)

let add_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Add_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Add_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Add_default0 (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | Olea a ->
                (match a with
                 | Aindexed n0 ->
                   (match e5 with
                    | Enil ->
                      Add_default0 (e4, (Eop ((Olea (Aindexed n0)), Enil)))
                    | Econs (t2, e6) ->
                      (match e6 with
                       | Enil -> Add_case13 (e4, n0, t2)
                       | Econs (e7, e8) ->
                         Add_default0 (e4, (Eop ((Olea (Aindexed n0)), (Econs
                           (t2, (Econs (e7, e8)))))))))
                 | Ascaled (sc, n0) ->
                   (match e5 with
                    | Enil ->
                      Add_default0 (e4, (Eop ((Olea (Ascaled (sc, n0))),
                        Enil)))
                    | Econs (t2, e6) ->
                      (match e6 with
                       | Enil -> Add_case11 (e4, sc, n0, t2)
                       | Econs (e7, e8) ->
                         Add_default0 (e4, (Eop ((Olea (Ascaled (sc, n0))),
                           (Econs (t2, (Econs (e7, e8)))))))))
                 | x -> Add_default0 (e4, (Eop ((Olea x), e5))))
              | x -> Add_default0 (e4, (Eop (x, e5))))
           | x -> Add_default0 (e4, x)))
     | Olea a ->
       (match a with
        | Aindexed n0 ->
          (match e with
           | Enil ->
             let e3 = Eop ((Olea (Aindexed n0)), Enil) in
             (match e2 with
              | Eop (o0, e0) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e0 with
                    | Enil -> Add_case2 (e3, n2)
                    | Econs (e4, e5) ->
                      Add_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                        e5))))))
                 | Olea a0 ->
                   (match a0 with
                    | Aindexed n1 ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Aindexed n1)),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case13 (e3, n1, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Aindexed n1)),
                              (Econs (t2, (Econs (e5, e6)))))))))
                    | Ascaled (sc, n1) ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n1))),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case11 (e3, sc, n1, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Ascaled (sc,
                              n1))), (Econs (t2, (Econs (e5, e6)))))))))
                    | x -> Add_default0 (e3, (Eop ((Olea x), e0))))
                 | x -> Add_default0 (e3, (Eop (x, e0))))
              | x -> Add_default0 (e3, x))
           | Econs (t1, e0) ->
             (match e0 with
              | Enil ->
                (match e2 with
                 | Eop (o0, e3) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e3 with
                       | Enil ->
                         Add_case2 ((Eop ((Olea (Aindexed n0)), (Econs (t1,
                           Enil)))), n2)
                       | Econs (e4, e5) ->
                         Add_case12 (n0, t1, (Eop ((Ointconst1 n2), (Econs
                           (e4, e5))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n1 ->
                         (match e3 with
                          | Enil ->
                            Add_case12 (n0, t1, (Eop ((Olea (Aindexed n1)),
                              Enil)))
                          | Econs (t2, e4) ->
                            (match e4 with
                             | Enil -> Add_case3 (n0, t1, n1, t2)
                             | Econs (e5, e6) ->
                               Add_case12 (n0, t1, (Eop ((Olea (Aindexed
                                 n1)), (Econs (t2, (Econs (e5, e6)))))))))
                       | Ascaled (sc, n1) ->
                         (match e3 with
                          | Enil ->
                            Add_case12 (n0, t1, (Eop ((Olea (Ascaled (sc,
                              n1))), Enil)))
                          | Econs (t2, e4) ->
                            (match e4 with
                             | Enil -> Add_case4 (n0, t1, sc, n1, t2)
                             | Econs (e5, e6) ->
                               Add_case12 (n0, t1, (Eop ((Olea (Ascaled (sc,
                                 n1))), (Econs (t2, (Econs (e5, e6)))))))))
                       | Aglobal (id, ofs) ->
                         (match e3 with
                          | Enil -> Add_case6 (n0, t1, id, ofs)
                          | Econs (e4, e5) ->
                            Add_case12 (n0, t1, (Eop ((Olea (Aglobal (id,
                              ofs))), (Econs (e4, e5))))))
                       | x -> Add_case12 (n0, t1, (Eop ((Olea x), e3))))
                    | x -> Add_case12 (n0, t1, (Eop (x, e3))))
                 | x -> Add_case12 (n0, t1, x))
              | Econs (e3, e4) ->
                let e5 = Eop ((Olea (Aindexed n0)), (Econs (t1, (Econs (e3,
                  e4)))))
                in
                (match e2 with
                 | Eop (o0, e6) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e6 with
                       | Enil -> Add_case2 (e5, n2)
                       | Econs (e7, e8) ->
                         Add_default0 (e5, (Eop ((Ointconst1 n2), (Econs (e7,
                           e8))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n1 ->
                         (match e6 with
                          | Enil ->
                            Add_default0 (e5, (Eop ((Olea (Aindexed n1)),
                              Enil)))
                          | Econs (t2, e7) ->
                            (match e7 with
                             | Enil -> Add_case13 (e5, n1, t2)
                             | Econs (e8, e9) ->
                               Add_default0 (e5, (Eop ((Olea (Aindexed n1)),
                                 (Econs (t2, (Econs (e8, e9)))))))))
                       | Ascaled (sc, n1) ->
                         (match e6 with
                          | Enil ->
                            Add_default0 (e5, (Eop ((Olea (Ascaled (sc,
                              n1))), Enil)))
                          | Econs (t2, e7) ->
                            (match e7 with
                             | Enil -> Add_case11 (e5, sc, n1, t2)
                             | Econs (e8, e9) ->
                               Add_default0 (e5, (Eop ((Olea (Ascaled (sc,
                                 n1))), (Econs (t2, (Econs (e8, e9)))))))))
                       | x -> Add_default0 (e5, (Eop ((Olea x), e6))))
                    | x -> Add_default0 (e5, (Eop (x, e6))))
                 | x -> Add_default0 (e5, x))))
        | Ascaled (sc, n0) ->
          (match e with
           | Enil ->
             let e3 = Eop ((Olea (Ascaled (sc, n0))), Enil) in
             (match e2 with
              | Eop (o0, e0) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e0 with
                    | Enil -> Add_case2 (e3, n2)
                    | Econs (e4, e5) ->
                      Add_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                        e5))))))
                 | Olea a0 ->
                   (match a0 with
                    | Aindexed n1 ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Aindexed n1)),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case13 (e3, n1, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Aindexed n1)),
                              (Econs (t2, (Econs (e5, e6)))))))))
                    | Ascaled (sc0, n1) ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Ascaled (sc0, n1))),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case11 (e3, sc0, n1, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Ascaled (sc0,
                              n1))), (Econs (t2, (Econs (e5, e6)))))))))
                    | x -> Add_default0 (e3, (Eop ((Olea x), e0))))
                 | x -> Add_default0 (e3, (Eop (x, e0))))
              | x -> Add_default0 (e3, x))
           | Econs (t1, e0) ->
             (match e0 with
              | Enil ->
                (match e2 with
                 | Eop (o0, e3) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e3 with
                       | Enil ->
                         Add_case2 ((Eop ((Olea (Ascaled (sc, n0))), (Econs
                           (t1, Enil)))), n2)
                       | Econs (e4, e5) ->
                         Add_case10 (sc, n0, t1, (Eop ((Ointconst1 n2),
                           (Econs (e4, e5))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n1 ->
                         (match e3 with
                          | Enil ->
                            Add_case10 (sc, n0, t1, (Eop ((Olea (Aindexed
                              n1)), Enil)))
                          | Econs (t2, e4) ->
                            (match e4 with
                             | Enil -> Add_case5 (sc, n0, t1, n1, t2)
                             | Econs (e5, e6) ->
                               Add_case10 (sc, n0, t1, (Eop ((Olea (Aindexed
                                 n1)), (Econs (t2, (Econs (e5, e6)))))))))
                       | Aglobal (id, ofs) ->
                         (match e3 with
                          | Enil -> Add_case8 (sc, n0, t1, id, ofs)
                          | Econs (e4, e5) ->
                            Add_case10 (sc, n0, t1, (Eop ((Olea (Aglobal (id,
                              ofs))), (Econs (e4, e5))))))
                       | x -> Add_case10 (sc, n0, t1, (Eop ((Olea x), e3))))
                    | x -> Add_case10 (sc, n0, t1, (Eop (x, e3))))
                 | x -> Add_case10 (sc, n0, t1, x))
              | Econs (e3, e4) ->
                let e5 = Eop ((Olea (Ascaled (sc, n0))), (Econs (t1, (Econs
                  (e3, e4)))))
                in
                (match e2 with
                 | Eop (o0, e6) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e6 with
                       | Enil -> Add_case2 (e5, n2)
                       | Econs (e7, e8) ->
                         Add_default0 (e5, (Eop ((Ointconst1 n2), (Econs (e7,
                           e8))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n1 ->
                         (match e6 with
                          | Enil ->
                            Add_default0 (e5, (Eop ((Olea (Aindexed n1)),
                              Enil)))
                          | Econs (t2, e7) ->
                            (match e7 with
                             | Enil -> Add_case13 (e5, n1, t2)
                             | Econs (e8, e9) ->
                               Add_default0 (e5, (Eop ((Olea (Aindexed n1)),
                                 (Econs (t2, (Econs (e8, e9)))))))))
                       | Ascaled (sc0, n1) ->
                         (match e6 with
                          | Enil ->
                            Add_default0 (e5, (Eop ((Olea (Ascaled (sc0,
                              n1))), Enil)))
                          | Econs (t2, e7) ->
                            (match e7 with
                             | Enil -> Add_case11 (e5, sc0, n1, t2)
                             | Econs (e8, e9) ->
                               Add_default0 (e5, (Eop ((Olea (Ascaled (sc0,
                                 n1))), (Econs (t2, (Econs (e8, e9)))))))))
                       | x -> Add_default0 (e5, (Eop ((Olea x), e6))))
                    | x -> Add_default0 (e5, (Eop (x, e6))))
                 | x -> Add_default0 (e5, x))))
        | Aglobal (id, ofs) ->
          (match e with
           | Enil ->
             let e3 = Eop ((Olea (Aglobal (id, ofs))), Enil) in
             (match e2 with
              | Eop (o0, e0) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e0 with
                    | Enil -> Add_case2 (e3, n2)
                    | Econs (e4, e5) ->
                      Add_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                        e5))))))
                 | Olea a0 ->
                   (match a0 with
                    | Aindexed n0 ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Aindexed n0)),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case7 (id, ofs, n0, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Aindexed n0)),
                              (Econs (t2, (Econs (e5, e6)))))))))
                    | Ascaled (sc, n0) ->
                      (match e0 with
                       | Enil ->
                         Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n0))),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Add_case9 (id, ofs, sc, n0, t2)
                          | Econs (e5, e6) ->
                            Add_default0 (e3, (Eop ((Olea (Ascaled (sc,
                              n0))), (Econs (t2, (Econs (e5, e6)))))))))
                    | x -> Add_default0 (e3, (Eop ((Olea x), e0))))
                 | x -> Add_default0 (e3, (Eop (x, e0))))
              | x -> Add_default0 (e3, x))
           | Econs (e0, e3) ->
             let e4 = Eop ((Olea (Aglobal (id, ofs))), (Econs (e0, e3))) in
             (match e2 with
              | Eop (o0, e5) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e5 with
                    | Enil -> Add_case2 (e4, n2)
                    | Econs (e6, e7) ->
                      Add_default0 (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                        e7))))))
                 | Olea a0 ->
                   (match a0 with
                    | Aindexed n0 ->
                      (match e5 with
                       | Enil ->
                         Add_default0 (e4, (Eop ((Olea (Aindexed n0)),
                           Enil)))
                       | Econs (t2, e6) ->
                         (match e6 with
                          | Enil -> Add_case13 (e4, n0, t2)
                          | Econs (e7, e8) ->
                            Add_default0 (e4, (Eop ((Olea (Aindexed n0)),
                              (Econs (t2, (Econs (e7, e8)))))))))
                    | Ascaled (sc, n0) ->
                      (match e5 with
                       | Enil ->
                         Add_default0 (e4, (Eop ((Olea (Ascaled (sc, n0))),
                           Enil)))
                       | Econs (t2, e6) ->
                         (match e6 with
                          | Enil -> Add_case11 (e4, sc, n0, t2)
                          | Econs (e7, e8) ->
                            Add_default0 (e4, (Eop ((Olea (Ascaled (sc,
                              n0))), (Econs (t2, (Econs (e7, e8)))))))))
                    | x -> Add_default0 (e4, (Eop ((Olea x), e5))))
                 | x -> Add_default0 (e4, (Eop (x, e5))))
              | x -> Add_default0 (e4, x)))
        | x ->
          let e3 = Eop ((Olea x), e) in
          (match e2 with
           | Eop (o0, e0) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e0 with
                 | Enil -> Add_case2 (e3, n2)
                 | Econs (e4, e5) ->
                   Add_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                     e5))))))
              | Olea a0 ->
                (match a0 with
                 | Aindexed n0 ->
                   (match e0 with
                    | Enil ->
                      Add_default0 (e3, (Eop ((Olea (Aindexed n0)), Enil)))
                    | Econs (t2, e4) ->
                      (match e4 with
                       | Enil -> Add_case13 (e3, n0, t2)
                       | Econs (e5, e6) ->
                         Add_default0 (e3, (Eop ((Olea (Aindexed n0)), (Econs
                           (t2, (Econs (e5, e6)))))))))
                 | Ascaled (sc, n0) ->
                   (match e0 with
                    | Enil ->
                      Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n0))),
                        Enil)))
                    | Econs (t2, e4) ->
                      (match e4 with
                       | Enil -> Add_case11 (e3, sc, n0, t2)
                       | Econs (e5, e6) ->
                         Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n0))),
                           (Econs (t2, (Econs (e5, e6)))))))))
                 | x0 -> Add_default0 (e3, (Eop ((Olea x0), e0))))
              | x0 -> Add_default0 (e3, (Eop (x0, e0))))
           | x0 -> Add_default0 (e3, x0)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Add_case2 (e3, n2)
              | Econs (e4, e5) ->
                Add_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | Olea a ->
             (match a with
              | Aindexed n0 ->
                (match e0 with
                 | Enil ->
                   Add_default0 (e3, (Eop ((Olea (Aindexed n0)), Enil)))
                 | Econs (t2, e4) ->
                   (match e4 with
                    | Enil -> Add_case13 (e3, n0, t2)
                    | Econs (e5, e6) ->
                      Add_default0 (e3, (Eop ((Olea (Aindexed n0)), (Econs
                        (t2, (Econs (e5, e6)))))))))
              | Ascaled (sc, n0) ->
                (match e0 with
                 | Enil ->
                   Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n0))), Enil)))
                 | Econs (t2, e4) ->
                   (match e4 with
                    | Enil -> Add_case11 (e3, sc, n0, t2)
                    | Econs (e5, e6) ->
                      Add_default0 (e3, (Eop ((Olea (Ascaled (sc, n0))),
                        (Econs (t2, (Econs (e5, e6)))))))))
              | x0 -> Add_default0 (e3, (Eop ((Olea x0), e0))))
           | x0 -> Add_default0 (e3, (Eop (x0, e0))))
        | x0 -> Add_default0 (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Add_case2 (x, n2)
           | Econs (e0, e3) ->
             Add_default0 (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | Olea a ->
          (match a with
           | Aindexed n0 ->
             (match e with
              | Enil -> Add_default0 (x, (Eop ((Olea (Aindexed n0)), Enil)))
              | Econs (t2, e0) ->
                (match e0 with
                 | Enil -> Add_case13 (x, n0, t2)
                 | Econs (e3, e4) ->
                   Add_default0 (x, (Eop ((Olea (Aindexed n0)), (Econs (t2,
                     (Econs (e3, e4)))))))))
           | Ascaled (sc, n0) ->
             (match e with
              | Enil ->
                Add_default0 (x, (Eop ((Olea (Ascaled (sc, n0))), Enil)))
              | Econs (t2, e0) ->
                (match e0 with
                 | Enil -> Add_case11 (x, sc, n0, t2)
                 | Econs (e3, e4) ->
                   Add_default0 (x, (Eop ((Olea (Ascaled (sc, n0))), (Econs
                     (t2, (Econs (e3, e4)))))))))
           | x0 -> Add_default0 (x, (Eop ((Olea x0), e))))
        | x0 -> Add_default0 (x, (Eop (x0, e))))
     | x0 -> Add_default0 (x, x0))

(** val add0 : expr2 -> expr2 -> expr2 **)

let add0 e1 e2 =
  match add_match e1 e2 with
  | Add_case1 (n1, t2) -> addimm n1 t2
  | Add_case2 (t1, n2) -> addimm n2 t1
  | Add_case3 (n1, t1, n2, t2) ->
    Eop ((Olea (Aindexed2 (Int.add n1 n2))), (Econs (t1, (Econs (t2,
      Enil)))))
  | Add_case4 (n1, t1, sc, n2, t2) ->
    Eop ((Olea (Aindexed2scaled (sc, (Int.add n1 n2)))), (Econs (t1, (Econs
      (t2, Enil)))))
  | Add_case5 (sc, n1, t1, n2, t2) ->
    Eop ((Olea (Aindexed2scaled (sc, (Int.add n1 n2)))), (Econs (t2, (Econs
      (t1, Enil)))))
  | Add_case6 (n1, t1, id, ofs) ->
    Eop ((Olea (Abased (id, (Int.add ofs n1)))), (Econs (t1, Enil)))
  | Add_case7 (id, ofs, n2, t2) ->
    Eop ((Olea (Abased (id, (Int.add ofs n2)))), (Econs (t2, Enil)))
  | Add_case8 (sc, n1, t1, id, ofs) ->
    Eop ((Olea (Abasedscaled (sc, id, (Int.add ofs n1)))), (Econs (t1,
      Enil)))
  | Add_case9 (id, ofs, sc, n2, t2) ->
    Eop ((Olea (Abasedscaled (sc, id, (Int.add ofs n2)))), (Econs (t2,
      Enil)))
  | Add_case10 (sc, n0, t1, t2) ->
    Eop ((Olea (Aindexed2scaled (sc, n0))), (Econs (t2, (Econs (t1, Enil)))))
  | Add_case11 (t1, sc, n0, t2) ->
    Eop ((Olea (Aindexed2scaled (sc, n0))), (Econs (t1, (Econs (t2, Enil)))))
  | Add_case12 (n0, t1, t2) ->
    Eop ((Olea (Aindexed2 n0)), (Econs (t1, (Econs (t2, Enil)))))
  | Add_case13 (t1, n0, t2) ->
    Eop ((Olea (Aindexed2 n0)), (Econs (t1, (Econs (t2, Enil)))))
  | Add_default0 (e3, e4) ->
    Eop ((Olea (Aindexed2 Int.zero)), (Econs (e3, (Econs (e4, Enil)))))

type negint_cases =
| Negint_case1 of Int.int
| Negint_default of expr2

(** val negint_match : expr2 -> negint_cases **)

let negint_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Negint_case1 n0
      | Econs (e1, e2) ->
        Negint_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Negint_default (Eop (x, e0)))
| x -> Negint_default x

(** val negint0 : expr2 -> expr2 **)

let negint0 e =
  match negint_match e with
  | Negint_case1 n0 -> Eop ((Ointconst1 (Int.neg n0)), Enil)
  | Negint_default e0 -> Eop (Oneg0, (Econs (e0, Enil)))

type sub_cases =
| Sub_case1 of expr2 * Int.int
| Sub_case2 of Int.int * expr2 * Int.int * expr2
| Sub_case3 of Int.int * expr2 * expr2
| Sub_case4 of expr2 * Int.int * expr2
| Sub_default0 of expr2 * expr2

(** val sub_match : expr2 -> expr2 -> sub_cases **)

let sub_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Olea a ->
       (match a with
        | Aindexed n1 ->
          (match e with
           | Enil ->
             let e3 = Eop ((Olea (Aindexed n1)), Enil) in
             (match e2 with
              | Eop (o0, e0) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e0 with
                    | Enil -> Sub_case1 (e3, n2)
                    | Econs (e4, e5) ->
                      Sub_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                        e5))))))
                 | Olea a0 ->
                   (match a0 with
                    | Aindexed n2 ->
                      (match e0 with
                       | Enil ->
                         Sub_default0 (e3, (Eop ((Olea (Aindexed n2)),
                           Enil)))
                       | Econs (t2, e4) ->
                         (match e4 with
                          | Enil -> Sub_case4 (e3, n2, t2)
                          | Econs (e5, e6) ->
                            Sub_default0 (e3, (Eop ((Olea (Aindexed n2)),
                              (Econs (t2, (Econs (e5, e6)))))))))
                    | x -> Sub_default0 (e3, (Eop ((Olea x), e0))))
                 | x -> Sub_default0 (e3, (Eop (x, e0))))
              | x -> Sub_default0 (e3, x))
           | Econs (t1, e0) ->
             (match e0 with
              | Enil ->
                (match e2 with
                 | Eop (o0, e3) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e3 with
                       | Enil ->
                         Sub_case1 ((Eop ((Olea (Aindexed n1)), (Econs (t1,
                           Enil)))), n2)
                       | Econs (e4, e5) ->
                         Sub_case3 (n1, t1, (Eop ((Ointconst1 n2), (Econs
                           (e4, e5))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n2 ->
                         (match e3 with
                          | Enil ->
                            Sub_case3 (n1, t1, (Eop ((Olea (Aindexed n2)),
                              Enil)))
                          | Econs (t2, e4) ->
                            (match e4 with
                             | Enil -> Sub_case2 (n1, t1, n2, t2)
                             | Econs (e5, e6) ->
                               Sub_case3 (n1, t1, (Eop ((Olea (Aindexed n2)),
                                 (Econs (t2, (Econs (e5, e6)))))))))
                       | x -> Sub_case3 (n1, t1, (Eop ((Olea x), e3))))
                    | x -> Sub_case3 (n1, t1, (Eop (x, e3))))
                 | x -> Sub_case3 (n1, t1, x))
              | Econs (e3, e4) ->
                let e5 = Eop ((Olea (Aindexed n1)), (Econs (t1, (Econs (e3,
                  e4)))))
                in
                (match e2 with
                 | Eop (o0, e6) ->
                   (match o0 with
                    | Ointconst1 n2 ->
                      (match e6 with
                       | Enil -> Sub_case1 (e5, n2)
                       | Econs (e7, e8) ->
                         Sub_default0 (e5, (Eop ((Ointconst1 n2), (Econs (e7,
                           e8))))))
                    | Olea a0 ->
                      (match a0 with
                       | Aindexed n2 ->
                         (match e6 with
                          | Enil ->
                            Sub_default0 (e5, (Eop ((Olea (Aindexed n2)),
                              Enil)))
                          | Econs (t2, e7) ->
                            (match e7 with
                             | Enil -> Sub_case4 (e5, n2, t2)
                             | Econs (e8, e9) ->
                               Sub_default0 (e5, (Eop ((Olea (Aindexed n2)),
                                 (Econs (t2, (Econs (e8, e9)))))))))
                       | x -> Sub_default0 (e5, (Eop ((Olea x), e6))))
                    | x -> Sub_default0 (e5, (Eop (x, e6))))
                 | x -> Sub_default0 (e5, x))))
        | x ->
          let e3 = Eop ((Olea x), e) in
          (match e2 with
           | Eop (o0, e0) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e0 with
                 | Enil -> Sub_case1 (e3, n2)
                 | Econs (e4, e5) ->
                   Sub_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4,
                     e5))))))
              | Olea a0 ->
                (match a0 with
                 | Aindexed n2 ->
                   (match e0 with
                    | Enil ->
                      Sub_default0 (e3, (Eop ((Olea (Aindexed n2)), Enil)))
                    | Econs (t2, e4) ->
                      (match e4 with
                       | Enil -> Sub_case4 (e3, n2, t2)
                       | Econs (e5, e6) ->
                         Sub_default0 (e3, (Eop ((Olea (Aindexed n2)), (Econs
                           (t2, (Econs (e5, e6)))))))))
                 | x0 -> Sub_default0 (e3, (Eop ((Olea x0), e0))))
              | x0 -> Sub_default0 (e3, (Eop (x0, e0))))
           | x0 -> Sub_default0 (e3, x0)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Sub_case1 (e3, n2)
              | Econs (e4, e5) ->
                Sub_default0 (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | Olea a ->
             (match a with
              | Aindexed n2 ->
                (match e0 with
                 | Enil ->
                   Sub_default0 (e3, (Eop ((Olea (Aindexed n2)), Enil)))
                 | Econs (t2, e4) ->
                   (match e4 with
                    | Enil -> Sub_case4 (e3, n2, t2)
                    | Econs (e5, e6) ->
                      Sub_default0 (e3, (Eop ((Olea (Aindexed n2)), (Econs
                        (t2, (Econs (e5, e6)))))))))
              | x0 -> Sub_default0 (e3, (Eop ((Olea x0), e0))))
           | x0 -> Sub_default0 (e3, (Eop (x0, e0))))
        | x0 -> Sub_default0 (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Sub_case1 (x, n2)
           | Econs (e0, e3) ->
             Sub_default0 (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | Olea a ->
          (match a with
           | Aindexed n2 ->
             (match e with
              | Enil -> Sub_default0 (x, (Eop ((Olea (Aindexed n2)), Enil)))
              | Econs (t2, e0) ->
                (match e0 with
                 | Enil -> Sub_case4 (x, n2, t2)
                 | Econs (e3, e4) ->
                   Sub_default0 (x, (Eop ((Olea (Aindexed n2)), (Econs (t2,
                     (Econs (e3, e4)))))))))
           | x0 -> Sub_default0 (x, (Eop ((Olea x0), e))))
        | x0 -> Sub_default0 (x, (Eop (x0, e))))
     | x0 -> Sub_default0 (x, x0))

(** val sub0 : expr2 -> expr2 -> expr2 **)

let sub0 e1 e2 =
  match sub_match e1 e2 with
  | Sub_case1 (t1, n2) -> addimm (Int.neg n2) t1
  | Sub_case2 (n1, t1, n2, t2) ->
    addimm (Int.sub n1 n2) (Eop (Osub1, (Econs (t1, (Econs (t2, Enil))))))
  | Sub_case3 (n1, t1, t2) ->
    addimm n1 (Eop (Osub1, (Econs (t1, (Econs (t2, Enil))))))
  | Sub_case4 (t1, n2, t2) ->
    addimm (Int.neg n2) (Eop (Osub1, (Econs (t1, (Econs (t2, Enil))))))
  | Sub_default0 (e3, e4) -> Eop (Osub1, (Econs (e3, (Econs (e4, Enil)))))

(** val shift_is_scale : Int.int -> bool **)

let shift_is_scale n0 =
  match match Int.eq n0 (Int.repr (Zpos XH)) with
        | True -> True
        | False -> Int.eq n0 (Int.repr (Zpos (XO XH))) with
  | True -> True
  | False -> Int.eq n0 (Int.repr (Zpos (XI XH)))

type shlimm_cases =
| Shlimm_case1 of Int.int
| Shlimm_case2 of Int.int * expr2
| Shlimm_case3 of Int.int * expr2
| Shlimm_default of expr2

(** val shlimm_match : expr2 -> shlimm_cases **)

let shlimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n1 ->
     (match e with
      | Enil -> Shlimm_case1 n1
      | Econs (e0, e2) ->
        Shlimm_default (Eop ((Ointconst1 n1), (Econs (e0, e2)))))
   | Oshlimm n1 ->
     (match e with
      | Enil -> Shlimm_default (Eop ((Oshlimm n1), Enil))
      | Econs (t1, e0) ->
        (match e0 with
         | Enil -> Shlimm_case2 (n1, t1)
         | Econs (e2, e3) ->
           Shlimm_default (Eop ((Oshlimm n1), (Econs (t1, (Econs (e2,
             e3))))))))
   | Olea a ->
     (match a with
      | Aindexed n1 ->
        (match e with
         | Enil -> Shlimm_default (Eop ((Olea (Aindexed n1)), Enil))
         | Econs (t1, e0) ->
           (match e0 with
            | Enil -> Shlimm_case3 (n1, t1)
            | Econs (e2, e3) ->
              Shlimm_default (Eop ((Olea (Aindexed n1)), (Econs (t1, (Econs
                (e2, e3))))))))
      | x -> Shlimm_default (Eop ((Olea x), e)))
   | x -> Shlimm_default (Eop (x, e)))
| x -> Shlimm_default x

(** val shlimm : expr2 -> Int.int -> expr2 **)

let shlimm e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match negb (Int.ltu n0 Int.iwordsize) with
     | True ->
       Eop (Oshl1, (Econs (e1, (Econs ((Eop ((Ointconst1 n0), Enil)),
         Enil)))))
     | False ->
       (match shlimm_match e1 with
        | Shlimm_case1 n1 -> Eop ((Ointconst1 (Int.shl n1 n0)), Enil)
        | Shlimm_case2 (n1, t1) ->
          (match Int.ltu (Int.add n0 n1) Int.iwordsize with
           | True -> Eop ((Oshlimm (Int.add n0 n1)), (Econs (t1, Enil)))
           | False -> Eop ((Oshlimm n0), (Econs (e1, Enil))))
        | Shlimm_case3 (n1, t1) ->
          (match shift_is_scale n0 with
           | True ->
             Eop ((Olea (Ascaled ((Int.shl Int.one n0), (Int.shl n1 n0)))),
               (Econs (t1, Enil)))
           | False -> Eop ((Oshlimm n0), (Econs (e1, Enil))))
        | Shlimm_default e2 ->
          (match shift_is_scale n0 with
           | True ->
             Eop ((Olea (Ascaled ((Int.shl Int.one n0), Int.zero))), (Econs
               (e2, Enil)))
           | False -> Eop ((Oshlimm n0), (Econs (e2, Enil))))))

type shruimm_cases =
| Shruimm_case1 of Int.int
| Shruimm_case2 of Int.int * expr2
| Shruimm_default of expr2

(** val shruimm_match : expr2 -> shruimm_cases **)

let shruimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n1 ->
     (match e with
      | Enil -> Shruimm_case1 n1
      | Econs (e0, e2) ->
        Shruimm_default (Eop ((Ointconst1 n1), (Econs (e0, e2)))))
   | Oshruimm n1 ->
     (match e with
      | Enil -> Shruimm_default (Eop ((Oshruimm n1), Enil))
      | Econs (t1, e0) ->
        (match e0 with
         | Enil -> Shruimm_case2 (n1, t1)
         | Econs (e2, e3) ->
           Shruimm_default (Eop ((Oshruimm n1), (Econs (t1, (Econs (e2,
             e3))))))))
   | x -> Shruimm_default (Eop (x, e)))
| x -> Shruimm_default x

(** val shruimm : expr2 -> Int.int -> expr2 **)

let shruimm e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match negb (Int.ltu n0 Int.iwordsize) with
     | True ->
       Eop (Oshru0, (Econs (e1, (Econs ((Eop ((Ointconst1 n0), Enil)),
         Enil)))))
     | False ->
       (match shruimm_match e1 with
        | Shruimm_case1 n1 -> Eop ((Ointconst1 (Int.shru n1 n0)), Enil)
        | Shruimm_case2 (n1, t1) ->
          (match Int.ltu (Int.add n0 n1) Int.iwordsize with
           | True -> Eop ((Oshruimm (Int.add n0 n1)), (Econs (t1, Enil)))
           | False -> Eop ((Oshruimm n0), (Econs (e1, Enil))))
        | Shruimm_default e2 -> Eop ((Oshruimm n0), (Econs (e2, Enil)))))

type shrimm_cases =
| Shrimm_case1 of Int.int
| Shrimm_case2 of Int.int * expr2
| Shrimm_default of expr2

(** val shrimm_match : expr2 -> shrimm_cases **)

let shrimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n1 ->
     (match e with
      | Enil -> Shrimm_case1 n1
      | Econs (e0, e2) ->
        Shrimm_default (Eop ((Ointconst1 n1), (Econs (e0, e2)))))
   | Oshrimm n1 ->
     (match e with
      | Enil -> Shrimm_default (Eop ((Oshrimm n1), Enil))
      | Econs (t1, e0) ->
        (match e0 with
         | Enil -> Shrimm_case2 (n1, t1)
         | Econs (e2, e3) ->
           Shrimm_default (Eop ((Oshrimm n1), (Econs (t1, (Econs (e2,
             e3))))))))
   | x -> Shrimm_default (Eop (x, e)))
| x -> Shrimm_default x

(** val shrimm : expr2 -> Int.int -> expr2 **)

let shrimm e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match negb (Int.ltu n0 Int.iwordsize) with
     | True ->
       Eop (Oshr1, (Econs (e1, (Econs ((Eop ((Ointconst1 n0), Enil)),
         Enil)))))
     | False ->
       (match shrimm_match e1 with
        | Shrimm_case1 n1 -> Eop ((Ointconst1 (Int.shr n1 n0)), Enil)
        | Shrimm_case2 (n1, t1) ->
          (match Int.ltu (Int.add n0 n1) Int.iwordsize with
           | True -> Eop ((Oshrimm (Int.add n0 n1)), (Econs (t1, Enil)))
           | False -> Eop ((Oshrimm n0), (Econs (e1, Enil))))
        | Shrimm_default e2 -> Eop ((Oshrimm n0), (Econs (e2, Enil)))))

(** val mulimm_base : Int.int -> expr2 -> expr2 **)

let mulimm_base n1 e2 =
  match Int.one_bits n1 with
  | Nil -> Eop ((Omulimm n1), (Econs (e2, Enil)))
  | Cons (i, l) ->
    (match l with
     | Nil -> shlimm e2 i
     | Cons (j, l0) ->
       (match l0 with
        | Nil ->
          Elet (e2, (add0 (shlimm (Eletvar O) i) (shlimm (Eletvar O) j)))
        | Cons (i0, l1) -> Eop ((Omulimm n1), (Econs (e2, Enil)))))

type mulimm_cases =
| Mulimm_case1 of Int.int
| Mulimm_case2 of Int.int * expr2
| Mulimm_default of expr2

(** val mulimm_match : expr2 -> mulimm_cases **)

let mulimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Mulimm_case1 n2
      | Econs (e0, e1) ->
        Mulimm_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | Olea a ->
     (match a with
      | Aindexed n2 ->
        (match e with
         | Enil -> Mulimm_default (Eop ((Olea (Aindexed n2)), Enil))
         | Econs (t2, e0) ->
           (match e0 with
            | Enil -> Mulimm_case2 (n2, t2)
            | Econs (e1, e3) ->
              Mulimm_default (Eop ((Olea (Aindexed n2)), (Econs (t2, (Econs
                (e1, e3))))))))
      | x -> Mulimm_default (Eop ((Olea x), e)))
   | x -> Mulimm_default (Eop (x, e)))
| x -> Mulimm_default x

(** val mulimm : Int.int -> expr2 -> expr2 **)

let mulimm n1 e2 =
  match Int.eq n1 Int.zero with
  | True -> Eop ((Ointconst1 Int.zero), Enil)
  | False ->
    (match Int.eq n1 Int.one with
     | True -> e2
     | False ->
       (match mulimm_match e2 with
        | Mulimm_case1 n2 -> Eop ((Ointconst1 (Int.mul n1 n2)), Enil)
        | Mulimm_case2 (n2, t2) -> addimm (Int.mul n1 n2) (mulimm_base n1 t2)
        | Mulimm_default e3 -> mulimm_base n1 e3))

type mul_cases =
| Mul_case1 of Int.int * expr2
| Mul_case2 of expr2 * Int.int
| Mul_default of expr2 * expr2

(** val mul_match : expr2 -> expr2 -> mul_cases **)

let mul_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Mul_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Mul_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Mul_default (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | x -> Mul_default (e4, (Eop (x, e5))))
           | x -> Mul_default (e4, x)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Mul_case2 (e3, n2)
              | Econs (e4, e5) ->
                Mul_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> Mul_default (e3, (Eop (x0, e0))))
        | x0 -> Mul_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Mul_case2 (x, n2)
           | Econs (e0, e3) ->
             Mul_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> Mul_default (x, (Eop (x0, e))))
     | x0 -> Mul_default (x, x0))

(** val mul0 : expr2 -> expr2 -> expr2 **)

let mul0 e1 e2 =
  match mul_match e1 e2 with
  | Mul_case1 (n1, t2) -> mulimm n1 t2
  | Mul_case2 (t1, n2) -> mulimm n2 t1
  | Mul_default (e3, e4) -> Eop (Omul1, (Econs (e3, (Econs (e4, Enil)))))

type andimm_cases =
| Andimm_case1 of Int.int
| Andimm_case2 of Int.int * expr2
| Andimm_case3 of expr2
| Andimm_case4 of expr2
| Andimm_default of expr2

(** val andimm_match : expr2 -> andimm_cases **)

let andimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Andimm_case1 n2
      | Econs (e0, e1) ->
        Andimm_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | Ocast8unsigned0 ->
     (match e with
      | Enil -> Andimm_default (Eop (Ocast8unsigned0, Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Andimm_case3 t2
         | Econs (e1, e3) ->
           Andimm_default (Eop (Ocast8unsigned0, (Econs (t2, (Econs (e1,
             e3))))))))
   | Ocast16unsigned0 ->
     (match e with
      | Enil -> Andimm_default (Eop (Ocast16unsigned0, Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Andimm_case4 t2
         | Econs (e1, e3) ->
           Andimm_default (Eop (Ocast16unsigned0, (Econs (t2, (Econs (e1,
             e3))))))))
   | Oandimm n2 ->
     (match e with
      | Enil -> Andimm_default (Eop ((Oandimm n2), Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Andimm_case2 (n2, t2)
         | Econs (e1, e3) ->
           Andimm_default (Eop ((Oandimm n2), (Econs (t2, (Econs (e1,
             e3))))))))
   | x -> Andimm_default (Eop (x, e)))
| x -> Andimm_default x

(** val andimm : Int.int -> expr2 -> expr2 **)

let andimm n1 e2 =
  match Int.eq n1 Int.zero with
  | True -> Eop ((Ointconst1 Int.zero), Enil)
  | False ->
    (match Int.eq n1 Int.mone with
     | True -> e2
     | False ->
       (match andimm_match e2 with
        | Andimm_case1 n2 -> Eop ((Ointconst1 (Int.coq_and n1 n2)), Enil)
        | Andimm_case2 (n2, t2) ->
          Eop ((Oandimm (Int.coq_and n1 n2)), (Econs (t2, Enil)))
        | Andimm_case3 t2 ->
          Eop ((Oandimm
            (Int.coq_and n1
              (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI XH))))))))))),
            (Econs (t2, Enil)))
        | Andimm_case4 t2 ->
          Eop ((Oandimm
            (Int.coq_and n1
              (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI
                (XI (XI (XI XH))))))))))))))))))), (Econs (t2, Enil)))
        | Andimm_default e3 -> Eop ((Oandimm n1), (Econs (e3, Enil)))))

type and_cases =
| And_case1 of Int.int * expr2
| And_case2 of expr2 * Int.int
| And_default of expr2 * expr2

(** val and_match : expr2 -> expr2 -> and_cases **)

let and_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> And_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> And_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   And_default (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | x -> And_default (e4, (Eop (x, e5))))
           | x -> And_default (e4, x)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> And_case2 (e3, n2)
              | Econs (e4, e5) ->
                And_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> And_default (e3, (Eop (x0, e0))))
        | x0 -> And_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> And_case2 (x, n2)
           | Econs (e0, e3) ->
             And_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> And_default (x, (Eop (x0, e))))
     | x0 -> And_default (x, x0))

(** val and0 : expr2 -> expr2 -> expr2 **)

let and0 e1 e2 =
  match and_match e1 e2 with
  | And_case1 (n1, t2) -> andimm n1 t2
  | And_case2 (t1, n2) -> andimm n2 t1
  | And_default (e3, e4) -> Eop (Oand1, (Econs (e3, (Econs (e4, Enil)))))

type orimm_cases =
| Orimm_case1 of Int.int
| Orimm_case2 of Int.int * expr2
| Orimm_default of expr2

(** val orimm_match : expr2 -> orimm_cases **)

let orimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Orimm_case1 n2
      | Econs (e0, e1) ->
        Orimm_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | Oorimm n2 ->
     (match e with
      | Enil -> Orimm_default (Eop ((Oorimm n2), Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Orimm_case2 (n2, t2)
         | Econs (e1, e3) ->
           Orimm_default (Eop ((Oorimm n2), (Econs (t2, (Econs (e1, e3))))))))
   | x -> Orimm_default (Eop (x, e)))
| x -> Orimm_default x

(** val orimm : Int.int -> expr2 -> expr2 **)

let orimm n1 e2 =
  match Int.eq n1 Int.zero with
  | True -> e2
  | False ->
    (match Int.eq n1 Int.mone with
     | True -> Eop ((Ointconst1 Int.mone), Enil)
     | False ->
       (match orimm_match e2 with
        | Orimm_case1 n2 -> Eop ((Ointconst1 (Int.coq_or n1 n2)), Enil)
        | Orimm_case2 (n2, t2) ->
          Eop ((Oorimm (Int.coq_or n1 n2)), (Econs (t2, Enil)))
        | Orimm_default e3 -> Eop ((Oorimm n1), (Econs (e3, Enil)))))

(** val same_expr_pure : expr2 -> expr2 -> bool **)

let same_expr_pure e1 e2 =
  match e1 with
  | Evar2 v1 ->
    (match e2 with
     | Evar2 v2 ->
       (match ident_eq v1 v2 with
        | Left -> True
        | Right -> False)
     | _ -> False)
  | _ -> False

type or_cases =
| Or_case1 of Int.int * expr2
| Or_case2 of expr2 * Int.int
| Or_case3 of Int.int * expr2 * Int.int * expr2
| Or_case4 of Int.int * expr2 * Int.int * expr2
| Or_default of expr2 * expr2

(** val or_match : expr2 -> expr2 -> or_cases **)

let or_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Or_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Or_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Or_default (e4, (Eop ((Ointconst1 n2), (Econs (e6, e7))))))
              | x -> Or_default (e4, (Eop (x, e5))))
           | x -> Or_default (e4, x)))
     | Oshlimm n1 ->
       (match e with
        | Enil ->
          let e3 = Eop ((Oshlimm n1), Enil) in
          (match e2 with
           | Eop (o0, e0) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e0 with
                 | Enil -> Or_case2 (e3, n2)
                 | Econs (e4, e5) ->
                   Or_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
              | x -> Or_default (e3, (Eop (x, e0))))
           | x -> Or_default (e3, x))
        | Econs (t1, e0) ->
          (match e0 with
           | Enil ->
             let e3 = Eop ((Oshlimm n1), (Econs (t1, Enil))) in
             (match e2 with
              | Eop (o0, e4) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e4 with
                    | Enil -> Or_case2 (e3, n2)
                    | Econs (e5, e6) ->
                      Or_default (e3, (Eop ((Ointconst1 n2), (Econs (e5,
                        e6))))))
                 | Oshruimm n2 ->
                   (match e4 with
                    | Enil -> Or_default (e3, (Eop ((Oshruimm n2), Enil)))
                    | Econs (t2, e5) ->
                      (match e5 with
                       | Enil -> Or_case3 (n1, t1, n2, t2)
                       | Econs (e6, e7) ->
                         Or_default (e3, (Eop ((Oshruimm n2), (Econs (t2,
                           (Econs (e6, e7)))))))))
                 | x -> Or_default (e3, (Eop (x, e4))))
              | x -> Or_default (e3, x))
           | Econs (e3, e4) ->
             let e5 = Eop ((Oshlimm n1), (Econs (t1, (Econs (e3, e4))))) in
             (match e2 with
              | Eop (o0, e6) ->
                (match o0 with
                 | Ointconst1 n2 ->
                   (match e6 with
                    | Enil -> Or_case2 (e5, n2)
                    | Econs (e7, e8) ->
                      Or_default (e5, (Eop ((Ointconst1 n2), (Econs (e7,
                        e8))))))
                 | x -> Or_default (e5, (Eop (x, e6))))
              | x -> Or_default (e5, x))))
     | Oshruimm n2 ->
       (match e with
        | Enil ->
          let e3 = Eop ((Oshruimm n2), Enil) in
          (match e2 with
           | Eop (o0, e0) ->
             (match o0 with
              | Ointconst1 n3 ->
                (match e0 with
                 | Enil -> Or_case2 (e3, n3)
                 | Econs (e4, e5) ->
                   Or_default (e3, (Eop ((Ointconst1 n3), (Econs (e4, e5))))))
              | x -> Or_default (e3, (Eop (x, e0))))
           | x -> Or_default (e3, x))
        | Econs (t2, e0) ->
          (match e0 with
           | Enil ->
             let e3 = Eop ((Oshruimm n2), (Econs (t2, Enil))) in
             (match e2 with
              | Eop (o0, e4) ->
                (match o0 with
                 | Ointconst1 n3 ->
                   (match e4 with
                    | Enil -> Or_case2 (e3, n3)
                    | Econs (e5, e6) ->
                      Or_default (e3, (Eop ((Ointconst1 n3), (Econs (e5,
                        e6))))))
                 | Oshlimm n1 ->
                   (match e4 with
                    | Enil -> Or_default (e3, (Eop ((Oshlimm n1), Enil)))
                    | Econs (t1, e5) ->
                      (match e5 with
                       | Enil -> Or_case4 (n2, t2, n1, t1)
                       | Econs (e6, e7) ->
                         Or_default (e3, (Eop ((Oshlimm n1), (Econs (t1,
                           (Econs (e6, e7)))))))))
                 | x -> Or_default (e3, (Eop (x, e4))))
              | x -> Or_default (e3, x))
           | Econs (e3, e4) ->
             let e5 = Eop ((Oshruimm n2), (Econs (t2, (Econs (e3, e4))))) in
             (match e2 with
              | Eop (o0, e6) ->
                (match o0 with
                 | Ointconst1 n3 ->
                   (match e6 with
                    | Enil -> Or_case2 (e5, n3)
                    | Econs (e7, e8) ->
                      Or_default (e5, (Eop ((Ointconst1 n3), (Econs (e7,
                        e8))))))
                 | x -> Or_default (e5, (Eop (x, e6))))
              | x -> Or_default (e5, x))))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Or_case2 (e3, n2)
              | Econs (e4, e5) ->
                Or_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> Or_default (e3, (Eop (x0, e0))))
        | x0 -> Or_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Or_case2 (x, n2)
           | Econs (e0, e3) ->
             Or_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> Or_default (x, (Eop (x0, e))))
     | x0 -> Or_default (x, x0))

(** val or0 : expr2 -> expr2 -> expr2 **)

let or0 e1 e2 =
  match or_match e1 e2 with
  | Or_case1 (n1, t2) -> orimm n1 t2
  | Or_case2 (t1, n2) -> orimm n2 t1
  | Or_case3 (n1, t1, n2, t2) ->
    (match Int.eq (Int.add n1 n2) Int.iwordsize with
     | True ->
       (match same_expr_pure t1 t2 with
        | True -> Eop ((Ororimm n2), (Econs (t1, Enil)))
        | False -> Eop ((Oshldimm n1), (Econs (t1, (Econs (t2, Enil))))))
     | False -> Eop (Oor1, (Econs (e1, (Econs (e2, Enil))))))
  | Or_case4 (n2, t2, n1, t1) ->
    (match Int.eq (Int.add n1 n2) Int.iwordsize with
     | True ->
       (match same_expr_pure t1 t2 with
        | True -> Eop ((Ororimm n2), (Econs (t1, Enil)))
        | False -> Eop ((Oshldimm n1), (Econs (t1, (Econs (t2, Enil))))))
     | False -> Eop (Oor1, (Econs (e1, (Econs (e2, Enil))))))
  | Or_default (e3, e4) -> Eop (Oor1, (Econs (e3, (Econs (e4, Enil)))))

type xorimm_cases =
| Xorimm_case1 of Int.int
| Xorimm_case2 of Int.int * expr2
| Xorimm_case3 of expr2
| Xorimm_default of expr2

(** val xorimm_match : expr2 -> xorimm_cases **)

let xorimm_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Xorimm_case1 n2
      | Econs (e0, e1) ->
        Xorimm_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | Oxorimm n2 ->
     (match e with
      | Enil -> Xorimm_default (Eop ((Oxorimm n2), Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Xorimm_case2 (n2, t2)
         | Econs (e1, e3) ->
           Xorimm_default (Eop ((Oxorimm n2), (Econs (t2, (Econs (e1,
             e3))))))))
   | Onot ->
     (match e with
      | Enil -> Xorimm_default (Eop (Onot, Enil))
      | Econs (t2, e0) ->
        (match e0 with
         | Enil -> Xorimm_case3 t2
         | Econs (e1, e3) ->
           Xorimm_default (Eop (Onot, (Econs (t2, (Econs (e1, e3))))))))
   | x -> Xorimm_default (Eop (x, e)))
| x -> Xorimm_default x

(** val xorimm : Int.int -> expr2 -> expr2 **)

let xorimm n1 e2 =
  match Int.eq n1 Int.zero with
  | True -> e2
  | False ->
    (match xorimm_match e2 with
     | Xorimm_case1 n2 -> Eop ((Ointconst1 (Int.xor n1 n2)), Enil)
     | Xorimm_case2 (n2, t2) ->
       Eop ((Oxorimm (Int.xor n1 n2)), (Econs (t2, Enil)))
     | Xorimm_case3 t2 -> Eop ((Oxorimm (Int.not n1)), (Econs (t2, Enil)))
     | Xorimm_default e3 -> Eop ((Oxorimm n1), (Econs (e3, Enil))))

type xor_cases =
| Xor_case1 of Int.int * expr2
| Xor_case2 of expr2 * Int.int
| Xor_default of expr2 * expr2

(** val xor_match : expr2 -> expr2 -> xor_cases **)

let xor_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Xor_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Xor_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Xor_default (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | x -> Xor_default (e4, (Eop (x, e5))))
           | x -> Xor_default (e4, x)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Xor_case2 (e3, n2)
              | Econs (e4, e5) ->
                Xor_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> Xor_default (e3, (Eop (x0, e0))))
        | x0 -> Xor_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Xor_case2 (x, n2)
           | Econs (e0, e3) ->
             Xor_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> Xor_default (x, (Eop (x0, e))))
     | x0 -> Xor_default (x, x0))

(** val xor0 : expr2 -> expr2 -> expr2 **)

let xor0 e1 e2 =
  match xor_match e1 e2 with
  | Xor_case1 (n1, t2) -> xorimm n1 t2
  | Xor_case2 (t1, n2) -> xorimm n2 t1
  | Xor_default (e3, e4) -> Eop (Oxor1, (Econs (e3, (Econs (e4, Enil)))))

(** val divu_base : expr2 -> expr2 -> expr2 **)

let divu_base e1 e2 =
  Eop (Odivu0, (Econs (e1, (Econs (e2, Enil)))))

(** val modu_base : expr2 -> expr2 -> expr2 **)

let modu_base e1 e2 =
  Eop (Omodu0, (Econs (e1, (Econs (e2, Enil)))))

(** val divs_base : expr2 -> expr2 -> expr2 **)

let divs_base e1 e2 =
  Eop (Odiv1, (Econs (e1, (Econs (e2, Enil)))))

(** val mods_base : expr2 -> expr2 -> expr2 **)

let mods_base e1 e2 =
  Eop (Omod1, (Econs (e1, (Econs (e2, Enil)))))

(** val shrximm : expr2 -> Int.int -> expr2 **)

let shrximm e1 n2 =
  match Int.eq n2 Int.zero with
  | True -> e1
  | False -> Eop ((Oshrximm n2), (Econs (e1, Enil)))

type shl_cases =
| Shl_case1 of Int.int
| Shl_default of expr2

(** val shl_match : expr2 -> shl_cases **)

let shl_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Shl_case1 n2
      | Econs (e0, e1) ->
        Shl_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Shl_default (Eop (x, e)))
| x -> Shl_default x

(** val shl0 : expr2 -> expr2 -> expr2 **)

let shl0 e1 e2 =
  match shl_match e2 with
  | Shl_case1 n2 -> shlimm e1 n2
  | Shl_default e3 -> Eop (Oshl1, (Econs (e1, (Econs (e3, Enil)))))

type shr_cases =
| Shr_case1 of Int.int
| Shr_default of expr2

(** val shr_match : expr2 -> shr_cases **)

let shr_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Shr_case1 n2
      | Econs (e0, e1) ->
        Shr_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Shr_default (Eop (x, e)))
| x -> Shr_default x

(** val shr1 : expr2 -> expr2 -> expr2 **)

let shr1 e1 e2 =
  match shr_match e2 with
  | Shr_case1 n2 -> shrimm e1 n2
  | Shr_default e3 -> Eop (Oshr1, (Econs (e1, (Econs (e3, Enil)))))

type shru_cases =
| Shru_case1 of Int.int
| Shru_default of expr2

(** val shru_match : expr2 -> shru_cases **)

let shru_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Shru_case1 n2
      | Econs (e0, e1) ->
        Shru_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Shru_default (Eop (x, e)))
| x -> Shru_default x

(** val shru0 : expr2 -> expr2 -> expr2 **)

let shru0 e1 e2 =
  match shru_match e2 with
  | Shru_case1 n2 -> shruimm e1 n2
  | Shru_default e3 -> Eop (Oshru0, (Econs (e1, (Econs (e3, Enil)))))

(** val negf0 : expr2 -> expr2 **)

let negf0 e =
  Eop (Onegf0, (Econs (e, Enil)))

(** val absf0 : expr2 -> expr2 **)

let absf0 e =
  Eop (Oabsf0, (Econs (e, Enil)))

(** val addf0 : expr2 -> expr2 -> expr2 **)

let addf0 e1 e2 =
  Eop (Oaddf0, (Econs (e1, (Econs (e2, Enil)))))

(** val subf0 : expr2 -> expr2 -> expr2 **)

let subf0 e1 e2 =
  Eop (Osubf0, (Econs (e1, (Econs (e2, Enil)))))

(** val mulf0 : expr2 -> expr2 -> expr2 **)

let mulf0 e1 e2 =
  Eop (Omulf0, (Econs (e1, (Econs (e2, Enil)))))

(** val negfs0 : expr2 -> expr2 **)

let negfs0 e =
  Eop (Onegfs0, (Econs (e, Enil)))

(** val absfs0 : expr2 -> expr2 **)

let absfs0 e =
  Eop (Oabsfs0, (Econs (e, Enil)))

(** val addfs0 : expr2 -> expr2 -> expr2 **)

let addfs0 e1 e2 =
  Eop (Oaddfs0, (Econs (e1, (Econs (e2, Enil)))))

(** val subfs0 : expr2 -> expr2 -> expr2 **)

let subfs0 e1 e2 =
  Eop (Osubfs0, (Econs (e1, (Econs (e2, Enil)))))

(** val mulfs0 : expr2 -> expr2 -> expr2 **)

let mulfs0 e1 e2 =
  Eop (Omulfs0, (Econs (e1, (Econs (e2, Enil)))))

type compimm_cases =
| Compimm_case1 of comparison0 * Int.int
| Compimm_case2 of condition * exprlist
| Compimm_case3 of condition * exprlist
| Compimm_case4 of Int.int * expr2
| Compimm_case5 of Int.int * expr2
| Compimm_default of comparison0 * expr2

(** val compimm_match : comparison0 -> expr2 -> compimm_cases **)

let compimm_match c e1 =
  match c with
  | Ceq ->
    let c0 = Ceq in
    (match e1 with
     | Eop (o, el) ->
       (match o with
        | Ointconst1 n1 ->
          (match el with
           | Enil -> Compimm_case1 (c0, n1)
           | Econs (e, e0) ->
             Compimm_default (c0, (Eop ((Ointconst1 n1), (Econs (e, e0))))))
        | Oandimm n1 ->
          (match el with
           | Enil -> Compimm_default (c0, (Eop ((Oandimm n1), Enil)))
           | Econs (t1, e) ->
             (match e with
              | Enil -> Compimm_case4 (n1, t1)
              | Econs (e0, e2) ->
                Compimm_default (c0, (Eop ((Oandimm n1), (Econs (t1, (Econs
                  (e0, e2)))))))))
        | Ocmp0 c1 -> Compimm_case2 (c1, el)
        | x -> Compimm_default (c0, (Eop (x, el))))
     | x -> Compimm_default (c0, x))
  | Cne ->
    let c0 = Cne in
    (match e1 with
     | Eop (o, el) ->
       (match o with
        | Ointconst1 n1 ->
          (match el with
           | Enil -> Compimm_case1 (c0, n1)
           | Econs (e, e0) ->
             Compimm_default (c0, (Eop ((Ointconst1 n1), (Econs (e, e0))))))
        | Oandimm n1 ->
          (match el with
           | Enil -> Compimm_default (c0, (Eop ((Oandimm n1), Enil)))
           | Econs (t1, e) ->
             (match e with
              | Enil -> Compimm_case5 (n1, t1)
              | Econs (e0, e2) ->
                Compimm_default (c0, (Eop ((Oandimm n1), (Econs (t1, (Econs
                  (e0, e2)))))))))
        | Ocmp0 c1 -> Compimm_case3 (c1, el)
        | x -> Compimm_default (c0, (Eop (x, el))))
     | x -> Compimm_default (c0, x))
  | x ->
    (match e1 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n1 ->
          (match e with
           | Enil -> Compimm_case1 (x, n1)
           | Econs (e0, e2) ->
             Compimm_default (x, (Eop ((Ointconst1 n1), (Econs (e0, e2))))))
        | x0 -> Compimm_default (x, (Eop (x0, e))))
     | x0 -> Compimm_default (x, x0))

(** val compimm :
    (comparison0 -> Int.int -> condition) -> (comparison0 -> Int.int ->
    Int.int -> bool) -> comparison0 -> expr2 -> Int.int -> expr2 **)

let compimm default0 sem c e1 n2 =
  match compimm_match c e1 with
  | Compimm_case1 (c0, n1) ->
    Eop ((Ointconst1
      (match sem c0 n1 n2 with
       | True -> Int.one
       | False -> Int.zero)), Enil)
  | Compimm_case2 (c0, el) ->
    (match Int.eq_dec n2 Int.zero with
     | Left -> Eop ((Ocmp0 (negate_condition c0)), el)
     | Right ->
       (match Int.eq_dec n2 Int.one with
        | Left -> Eop ((Ocmp0 c0), el)
        | Right -> Eop ((Ointconst1 Int.zero), Enil)))
  | Compimm_case3 (c0, el) ->
    (match Int.eq_dec n2 Int.zero with
     | Left -> Eop ((Ocmp0 c0), el)
     | Right ->
       (match Int.eq_dec n2 Int.one with
        | Left -> Eop ((Ocmp0 (negate_condition c0)), el)
        | Right -> Eop ((Ointconst1 Int.one), Enil)))
  | Compimm_case4 (n1, t1) ->
    (match Int.eq_dec n2 Int.zero with
     | Left -> Eop ((Ocmp0 (Cmaskzero n1)), (Econs (t1, Enil)))
     | Right -> Eop ((Ocmp0 (default0 c n2)), (Econs (e1, Enil))))
  | Compimm_case5 (n1, t1) ->
    (match Int.eq_dec n2 Int.zero with
     | Left -> Eop ((Ocmp0 (Cmasknotzero n1)), (Econs (t1, Enil)))
     | Right -> Eop ((Ocmp0 (default0 c n2)), (Econs (e1, Enil))))
  | Compimm_default (c0, e2) ->
    Eop ((Ocmp0 (default0 c0 n2)), (Econs (e2, Enil)))

type comp_cases =
| Comp_case1 of Int.int * expr2
| Comp_case2 of expr2 * Int.int
| Comp_default of expr2 * expr2

(** val comp_match : expr2 -> expr2 -> comp_cases **)

let comp_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Comp_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Comp_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Comp_default (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | x -> Comp_default (e4, (Eop (x, e5))))
           | x -> Comp_default (e4, x)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Comp_case2 (e3, n2)
              | Econs (e4, e5) ->
                Comp_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> Comp_default (e3, (Eop (x0, e0))))
        | x0 -> Comp_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Comp_case2 (x, n2)
           | Econs (e0, e3) ->
             Comp_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> Comp_default (x, (Eop (x0, e))))
     | x0 -> Comp_default (x, x0))

(** val comp : comparison0 -> expr2 -> expr2 -> expr2 **)

let comp c e1 e2 =
  match comp_match e1 e2 with
  | Comp_case1 (n1, t2) ->
    compimm (fun x x0 -> Ccompimm (x, x0)) Int.cmp (swap_comparison c) t2 n1
  | Comp_case2 (t1, n2) ->
    compimm (fun x x0 -> Ccompimm (x, x0)) Int.cmp c t1 n2
  | Comp_default (e3, e4) ->
    Eop ((Ocmp0 (Ccomp c)), (Econs (e3, (Econs (e4, Enil)))))

type compu_cases =
| Compu_case1 of Int.int * expr2
| Compu_case2 of expr2 * Int.int
| Compu_default of expr2 * expr2

(** val compu_match : expr2 -> expr2 -> compu_cases **)

let compu_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Ointconst1 n1 ->
       (match e with
        | Enil -> Compu_case1 (n1, e2)
        | Econs (e0, e3) ->
          let e4 = Eop ((Ointconst1 n1), (Econs (e0, e3))) in
          (match e2 with
           | Eop (o0, e5) ->
             (match o0 with
              | Ointconst1 n2 ->
                (match e5 with
                 | Enil -> Compu_case2 (e4, n2)
                 | Econs (e6, e7) ->
                   Compu_default (e4, (Eop ((Ointconst1 n2), (Econs (e6,
                     e7))))))
              | x -> Compu_default (e4, (Eop (x, e5))))
           | x -> Compu_default (e4, x)))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Ointconst1 n2 ->
             (match e0 with
              | Enil -> Compu_case2 (e3, n2)
              | Econs (e4, e5) ->
                Compu_default (e3, (Eop ((Ointconst1 n2), (Econs (e4, e5))))))
           | x0 -> Compu_default (e3, (Eop (x0, e0))))
        | x0 -> Compu_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Ointconst1 n2 ->
          (match e with
           | Enil -> Compu_case2 (x, n2)
           | Econs (e0, e3) ->
             Compu_default (x, (Eop ((Ointconst1 n2), (Econs (e0, e3))))))
        | x0 -> Compu_default (x, (Eop (x0, e))))
     | x0 -> Compu_default (x, x0))

(** val compu : comparison0 -> expr2 -> expr2 -> expr2 **)

let compu c e1 e2 =
  match compu_match e1 e2 with
  | Compu_case1 (n1, t2) ->
    compimm (fun x x0 -> Ccompuimm (x, x0)) Int.cmpu (swap_comparison c) t2
      n1
  | Compu_case2 (t1, n2) ->
    compimm (fun x x0 -> Ccompuimm (x, x0)) Int.cmpu c t1 n2
  | Compu_default (e3, e4) ->
    Eop ((Ocmp0 (Ccompu c)), (Econs (e3, (Econs (e4, Enil)))))

(** val compf : comparison0 -> expr2 -> expr2 -> expr2 **)

let compf c e1 e2 =
  Eop ((Ocmp0 (Ccompf c)), (Econs (e1, (Econs (e2, Enil)))))

(** val compfs : comparison0 -> expr2 -> expr2 -> expr2 **)

let compfs c e1 e2 =
  Eop ((Ocmp0 (Ccompfs c)), (Econs (e1, (Econs (e2, Enil)))))

type cast8unsigned_cases =
| Cast8unsigned_case1 of Int.int
| Cast8unsigned_case2 of Int.int * expr2
| Cast8unsigned_default of expr2

(** val cast8unsigned_match : expr2 -> cast8unsigned_cases **)

let cast8unsigned_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Cast8unsigned_case1 n0
      | Econs (e1, e2) ->
        Cast8unsigned_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | Oandimm n0 ->
     (match e0 with
      | Enil -> Cast8unsigned_default (Eop ((Oandimm n0), Enil))
      | Econs (t1, e1) ->
        (match e1 with
         | Enil -> Cast8unsigned_case2 (n0, t1)
         | Econs (e2, e3) ->
           Cast8unsigned_default (Eop ((Oandimm n0), (Econs (t1, (Econs (e2,
             e3))))))))
   | x -> Cast8unsigned_default (Eop (x, e0)))
| x -> Cast8unsigned_default x

(** val cast8unsigned : expr2 -> expr2 **)

let cast8unsigned e =
  match cast8unsigned_match e with
  | Cast8unsigned_case1 n0 ->
    Eop ((Ointconst1 (Int.zero_ext (Zpos (XO (XO (XO XH)))) n0)), Enil)
  | Cast8unsigned_case2 (n0, t1) ->
    andimm
      (Int.coq_and (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI XH)))))))))
        n0) t1
  | Cast8unsigned_default e0 -> Eop (Ocast8unsigned0, (Econs (e0, Enil)))

type cast8signed_cases =
| Cast8signed_case1 of Int.int
| Cast8signed_default of expr2

(** val cast8signed_match : expr2 -> cast8signed_cases **)

let cast8signed_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Cast8signed_case1 n0
      | Econs (e1, e2) ->
        Cast8signed_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Cast8signed_default (Eop (x, e0)))
| x -> Cast8signed_default x

(** val cast8signed : expr2 -> expr2 **)

let cast8signed e =
  match cast8signed_match e with
  | Cast8signed_case1 n0 ->
    Eop ((Ointconst1 (Int.sign_ext (Zpos (XO (XO (XO XH)))) n0)), Enil)
  | Cast8signed_default e0 -> Eop (Ocast8signed0, (Econs (e0, Enil)))

type cast16unsigned_cases =
| Cast16unsigned_case1 of Int.int
| Cast16unsigned_case2 of Int.int * expr2
| Cast16unsigned_default of expr2

(** val cast16unsigned_match : expr2 -> cast16unsigned_cases **)

let cast16unsigned_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Cast16unsigned_case1 n0
      | Econs (e1, e2) ->
        Cast16unsigned_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | Oandimm n0 ->
     (match e0 with
      | Enil -> Cast16unsigned_default (Eop ((Oandimm n0), Enil))
      | Econs (t1, e1) ->
        (match e1 with
         | Enil -> Cast16unsigned_case2 (n0, t1)
         | Econs (e2, e3) ->
           Cast16unsigned_default (Eop ((Oandimm n0), (Econs (t1, (Econs (e2,
             e3))))))))
   | x -> Cast16unsigned_default (Eop (x, e0)))
| x -> Cast16unsigned_default x

(** val cast16unsigned : expr2 -> expr2 **)

let cast16unsigned e =
  match cast16unsigned_match e with
  | Cast16unsigned_case1 n0 ->
    Eop ((Ointconst1 (Int.zero_ext (Zpos (XO (XO (XO (XO XH))))) n0)), Enil)
  | Cast16unsigned_case2 (n0, t1) ->
    andimm
      (Int.coq_and
        (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI
          (XI (XI XH))))))))))))))))) n0) t1
  | Cast16unsigned_default e0 -> Eop (Ocast16unsigned0, (Econs (e0, Enil)))

type cast16signed_cases =
| Cast16signed_case1 of Int.int
| Cast16signed_default of expr2

(** val cast16signed_match : expr2 -> cast16signed_cases **)

let cast16signed_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Cast16signed_case1 n0
      | Econs (e1, e2) ->
        Cast16signed_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Cast16signed_default (Eop (x, e0)))
| x -> Cast16signed_default x

(** val cast16signed : expr2 -> expr2 **)

let cast16signed e =
  match cast16signed_match e with
  | Cast16signed_case1 n0 ->
    Eop ((Ointconst1 (Int.sign_ext (Zpos (XO (XO (XO (XO XH))))) n0)), Enil)
  | Cast16signed_default e0 -> Eop (Ocast16signed0, (Econs (e0, Enil)))

(** val singleoffloat0 : expr2 -> expr2 **)

let singleoffloat0 e =
  Eop (Osingleoffloat0, (Econs (e, Enil)))

(** val floatofsingle0 : expr2 -> expr2 **)

let floatofsingle0 e =
  Eop (Ofloatofsingle0, (Econs (e, Enil)))

(** val intoffloat0 : expr2 -> expr2 **)

let intoffloat0 e =
  Eop (Ointoffloat0, (Econs (e, Enil)))

type floatofint_cases =
| Floatofint_case1 of Int.int
| Floatofint_default of expr2

(** val floatofint_match : expr2 -> floatofint_cases **)

let floatofint_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Floatofint_case1 n0
      | Econs (e1, e2) ->
        Floatofint_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Floatofint_default (Eop (x, e0)))
| x -> Floatofint_default x

(** val floatofint0 : expr2 -> expr2 **)

let floatofint0 e =
  match floatofint_match e with
  | Floatofint_case1 n0 -> Eop ((Ofloatconst1 (Float.of_int n0)), Enil)
  | Floatofint_default e0 -> Eop (Ofloatofint0, (Econs (e0, Enil)))

(** val intuoffloat0 : expr2 -> expr2 **)

let intuoffloat0 e =
  Elet (e, (Elet ((Eop ((Ofloatconst1 (Float.of_intu Float.ox8000_0000)),
    Enil)), (Econdition ((CEcond ((Ccompf Clt), (Econs ((Eletvar (S O)),
    (Econs ((Eletvar O), Enil)))))), (intoffloat0 (Eletvar (S O))),
    (addimm Float.ox8000_0000
      (intoffloat0 (subf0 (Eletvar (S O)) (Eletvar O)))))))))

type floatofintu_cases =
| Floatofintu_case1 of Int.int
| Floatofintu_default of expr2

(** val floatofintu_match : expr2 -> floatofintu_cases **)

let floatofintu_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Floatofintu_case1 n0
      | Econs (e1, e2) ->
        Floatofintu_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Floatofintu_default (Eop (x, e0)))
| x -> Floatofintu_default x

(** val floatofintu0 : expr2 -> expr2 **)

let floatofintu0 e =
  match floatofintu_match e with
  | Floatofintu_case1 n0 -> Eop ((Ofloatconst1 (Float.of_intu n0)), Enil)
  | Floatofintu_default e0 ->
    let f = Eop ((Ofloatconst1 (Float.of_intu Float.ox8000_0000)), Enil) in
    Elet (e0, (Econdition ((CEcond ((Ccompuimm (Clt, Float.ox8000_0000)),
    (Econs ((Eletvar O), Enil)))), (floatofint0 (Eletvar O)),
    (addf0 (floatofint0 (addimm (Int.neg Float.ox8000_0000) (Eletvar O))) f))))

(** val intofsingle0 : expr2 -> expr2 **)

let intofsingle0 e =
  Eop (Ointofsingle0, (Econs (e, Enil)))

type singleofint_cases =
| Singleofint_case1 of Int.int
| Singleofint_default of expr2

(** val singleofint_match : expr2 -> singleofint_cases **)

let singleofint_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Singleofint_case1 n0
      | Econs (e1, e2) ->
        Singleofint_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Singleofint_default (Eop (x, e0)))
| x -> Singleofint_default x

(** val singleofint0 : expr2 -> expr2 **)

let singleofint0 e =
  match singleofint_match e with
  | Singleofint_case1 n0 -> Eop ((Osingleconst1 (Float32.of_int n0)), Enil)
  | Singleofint_default e0 -> Eop (Osingleofint0, (Econs (e0, Enil)))

(** val intuofsingle0 : expr2 -> expr2 **)

let intuofsingle0 e =
  intuoffloat0 (floatofsingle0 e)

type singleofintu_cases =
| Singleofintu_case1 of Int.int
| Singleofintu_default of expr2

(** val singleofintu_match : expr2 -> singleofintu_cases **)

let singleofintu_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Singleofintu_case1 n0
      | Econs (e1, e2) ->
        Singleofintu_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | x -> Singleofintu_default (Eop (x, e0)))
| x -> Singleofintu_default x

(** val singleofintu0 : expr2 -> expr2 **)

let singleofintu0 e =
  match singleofintu_match e with
  | Singleofintu_case1 n0 -> Eop ((Osingleconst1 (Float32.of_intu n0)), Enil)
  | Singleofintu_default e0 -> singleoffloat0 (floatofintu0 e0)

type addressing_cases =
| Addressing_case1 of addressing * exprlist
| Addressing_default of expr2

(** val addressing_match : expr2 -> addressing_cases **)

let addressing_match = function
| Eop (o, args) ->
  (match o with
   | Olea addr -> Addressing_case1 (addr, args)
   | x -> Addressing_default (Eop (x, args)))
| x -> Addressing_default x

(** val addressing0 :
    memory_chunk -> expr2 -> (addressing, exprlist) prod **)

let addressing0 chunk e =
  match addressing_match e with
  | Addressing_case1 (addr, args) -> Pair (addr, args)
  | Addressing_default e0 -> Pair ((Aindexed Int.zero), (Econs (e0, Enil)))

type builtin_arg_cases =
| Builtin_arg_case1 of Int.int
| Builtin_arg_case2 of ident * Int.int
| Builtin_arg_case3 of Int.int
| Builtin_arg_case4 of Int.int * Int.int
| Builtin_arg_case5 of expr2 * expr2
| Builtin_arg_case6 of memory_chunk * ident * Int.int
| Builtin_arg_case7 of memory_chunk * Int.int
| Builtin_arg_default of expr2

(** val builtin_arg_match : expr2 -> builtin_arg_cases **)

let builtin_arg_match = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Builtin_arg_case1 n0
      | Econs (e1, e2) ->
        Builtin_arg_default (Eop ((Ointconst1 n0), (Econs (e1, e2)))))
   | Olea a ->
     (match a with
      | Aglobal (id, ofs) ->
        (match e0 with
         | Enil -> Builtin_arg_case2 (id, ofs)
         | Econs (e1, e2) ->
           Builtin_arg_default (Eop ((Olea (Aglobal (id, ofs))), (Econs (e1,
             e2)))))
      | Ainstack ofs ->
        (match e0 with
         | Enil -> Builtin_arg_case3 ofs
         | Econs (e1, e2) ->
           Builtin_arg_default (Eop ((Olea (Ainstack ofs)), (Econs (e1,
             e2)))))
      | x -> Builtin_arg_default (Eop ((Olea x), e0)))
   | Omakelong ->
     (match e0 with
      | Enil -> Builtin_arg_default (Eop (Omakelong, Enil))
      | Econs (h, e1) ->
        (match h with
         | Eop (o0, e2) ->
           (match o0 with
            | Ointconst1 h0 ->
              (match e2 with
               | Enil ->
                 let h1 = Eop ((Ointconst1 h0), Enil) in
                 (match e1 with
                  | Enil ->
                    Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                      ((Ointconst1 h0), Enil)), Enil))))
                  | Econs (l, e3) ->
                    (match l with
                     | Eop (o1, e4) ->
                       (match o1 with
                        | Ointconst1 l0 ->
                          (match e4 with
                           | Enil ->
                             (match e3 with
                              | Enil -> Builtin_arg_case4 (h0, l0)
                              | Econs (e5, e6) ->
                                Builtin_arg_default (Eop (Omakelong, (Econs
                                  ((Eop ((Ointconst1 h0), Enil)), (Econs
                                  ((Eop ((Ointconst1 l0), Enil)), (Econs (e5,
                                  e6)))))))))
                           | Econs (e5, e6) ->
                             (match e3 with
                              | Enil ->
                                Builtin_arg_case5 (h1, (Eop ((Ointconst1 l0),
                                  (Econs (e5, e6)))))
                              | Econs (e7, e8) ->
                                Builtin_arg_default (Eop (Omakelong, (Econs
                                  ((Eop ((Ointconst1 h0), Enil)), (Econs
                                  ((Eop ((Ointconst1 l0), (Econs (e5, e6)))),
                                  (Econs (e7, e8))))))))))
                        | Omakelong ->
                          (match e3 with
                           | Enil ->
                             Builtin_arg_case5 (h1, (Eop (Omakelong, e4)))
                           | Econs (e5, e6) ->
                             Builtin_arg_default (Eop (Omakelong, (Econs
                               ((Eop ((Ointconst1 h0), Enil)), (Econs ((Eop
                               (Omakelong, e4)), (Econs (e5, e6)))))))))
                        | x ->
                          (match e3 with
                           | Enil -> Builtin_arg_case5 (h1, (Eop (x, e4)))
                           | Econs (e5, e6) ->
                             Builtin_arg_default (Eop (Omakelong, (Econs
                               ((Eop ((Ointconst1 h0), Enil)), (Econs ((Eop
                               (x, e4)), (Econs (e5, e6))))))))))
                     | x ->
                       (match e3 with
                        | Enil -> Builtin_arg_case5 (h1, x)
                        | Econs (e4, e5) ->
                          Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                            ((Ointconst1 h0), Enil)), (Econs (x, (Econs (e4,
                            e5)))))))))))
               | Econs (e3, e4) ->
                 (match e1 with
                  | Enil ->
                    Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                      ((Ointconst1 h0), (Econs (e3, e4)))), Enil))))
                  | Econs (l, e5) ->
                    (match e5 with
                     | Enil ->
                       Builtin_arg_case5 ((Eop ((Ointconst1 h0), (Econs (e3,
                         e4)))), l)
                     | Econs (e6, e7) ->
                       Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                         ((Ointconst1 h0), (Econs (e3, e4)))), (Econs (l,
                         (Econs (e6, e7)))))))))))
            | Omakelong ->
              (match e1 with
               | Enil ->
                 Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                   (Omakelong, e2)), Enil))))
               | Econs (l, e3) ->
                 (match e3 with
                  | Enil -> Builtin_arg_case5 ((Eop (Omakelong, e2)), l)
                  | Econs (e4, e5) ->
                    Builtin_arg_default (Eop (Omakelong, (Econs ((Eop
                      (Omakelong, e2)), (Econs (l, (Econs (e4, e5))))))))))
            | x ->
              (match e1 with
               | Enil ->
                 Builtin_arg_default (Eop (Omakelong, (Econs ((Eop (x, e2)),
                   Enil))))
               | Econs (l, e3) ->
                 (match e3 with
                  | Enil -> Builtin_arg_case5 ((Eop (x, e2)), l)
                  | Econs (e4, e5) ->
                    Builtin_arg_default (Eop (Omakelong, (Econs ((Eop (x,
                      e2)), (Econs (l, (Econs (e4, e5)))))))))))
         | x ->
           (match e1 with
            | Enil ->
              Builtin_arg_default (Eop (Omakelong, (Econs (x, Enil))))
            | Econs (l, e2) ->
              (match e2 with
               | Enil -> Builtin_arg_case5 (x, l)
               | Econs (e3, e4) ->
                 Builtin_arg_default (Eop (Omakelong, (Econs (x, (Econs (l,
                   (Econs (e3, e4))))))))))))
   | x -> Builtin_arg_default (Eop (x, e0)))
| Eload1 (chunk, a, e0) ->
  (match a with
   | Aglobal (id, ofs) ->
     (match e0 with
      | Enil -> Builtin_arg_case6 (chunk, id, ofs)
      | Econs (e1, e2) ->
        Builtin_arg_default (Eload1 (chunk, (Aglobal (id, ofs)), (Econs (e1,
          e2)))))
   | Ainstack ofs ->
     (match e0 with
      | Enil -> Builtin_arg_case7 (chunk, ofs)
      | Econs (e1, e2) ->
        Builtin_arg_default (Eload1 (chunk, (Ainstack ofs), (Econs (e1,
          e2)))))
   | x -> Builtin_arg_default (Eload1 (chunk, x, e0)))
| x -> Builtin_arg_default x

(** val builtin_arg0 : expr2 -> expr2 builtin_arg **)

let builtin_arg0 e =
  match builtin_arg_match e with
  | Builtin_arg_case1 n0 -> BA_int n0
  | Builtin_arg_case2 (id, ofs) -> BA_addrglobal (id, ofs)
  | Builtin_arg_case3 ofs -> BA_addrstack ofs
  | Builtin_arg_case4 (h, l) -> BA_long (Int64.ofwords h l)
  | Builtin_arg_case5 (h, l) -> BA_splitlong ((BA h), (BA l))
  | Builtin_arg_case6 (chunk, id, ofs) -> BA_loadglobal (chunk, id, ofs)
  | Builtin_arg_case7 (chunk, ofs) -> BA_loadstack (chunk, ofs)
  | Builtin_arg_default e0 -> BA e0

(** val find_div_mul_params : nat -> z -> z -> z -> (z, z) prod option **)

let rec find_div_mul_params fuel nc d p =
  match fuel with
  | O -> None
  | S fuel' ->
    let twp = two_p p in
    (match zlt (Z.mul nc (Z.sub d (Z.modulo twp d))) twp with
     | Left ->
       Some (Pair ((Z.sub p (Zpos (XO (XO (XO (XO (XO XH))))))),
         (Z.div (Z.sub (Z.add twp d) (Z.modulo twp d)) d)))
     | Right -> find_div_mul_params fuel' nc d (Z.add p (Zpos XH)))

(** val divs_mul_params : z -> (z, z) prod option **)

let divs_mul_params d =
  match find_div_mul_params Int.wordsize
          (Z.sub (Z.sub Int.half_modulus (Z.modulo Int.half_modulus d)) (Zpos
            XH)) d (Zpos (XO (XO (XO (XO (XO XH)))))) with
  | Some p0 ->
    let Pair (p, m0) = p0 in
    (match match match match match match match proj_sumbool (zlt Z0 d) with
                                         | True ->
                                           proj_sumbool
                                             (zlt
                                               (two_p
                                                 (Z.add (Zpos (XO (XO (XO (XO
                                                   (XO XH)))))) p))
                                               (Z.mul m0 d))
                                         | False -> False with
                                   | True ->
                                     proj_sumbool
                                       (zle (Z.mul m0 d)
                                         (Z.add
                                           (two_p
                                             (Z.add (Zpos (XO (XO (XO (XO (XO
                                               XH)))))) p))
                                           (two_p (Z.add p (Zpos XH)))))
                                   | False -> False with
                             | True -> proj_sumbool (zle Z0 m0)
                             | False -> False with
                       | True -> proj_sumbool (zlt m0 Int.modulus)
                       | False -> False with
                 | True -> proj_sumbool (zle Z0 p)
                 | False -> False with
           | True -> proj_sumbool (zlt p (Zpos (XO (XO (XO (XO (XO XH)))))))
           | False -> False with
     | True -> Some (Pair (p, m0))
     | False -> None)
  | None -> None

(** val divu_mul_params : z -> (z, z) prod option **)

let divu_mul_params d =
  match find_div_mul_params Int.wordsize
          (Z.sub (Z.sub Int.modulus (Z.modulo Int.modulus d)) (Zpos XH)) d
          (Zpos (XO (XO (XO (XO (XO XH)))))) with
  | Some p0 ->
    let Pair (p, m0) = p0 in
    (match match match match match match match proj_sumbool (zlt Z0 d) with
                                         | True ->
                                           proj_sumbool
                                             (zle
                                               (two_p
                                                 (Z.add (Zpos (XO (XO (XO (XO
                                                   (XO XH)))))) p))
                                               (Z.mul m0 d))
                                         | False -> False with
                                   | True ->
                                     proj_sumbool
                                       (zle (Z.mul m0 d)
                                         (Z.add
                                           (two_p
                                             (Z.add (Zpos (XO (XO (XO (XO (XO
                                               XH)))))) p)) (two_p p)))
                                   | False -> False with
                             | True -> proj_sumbool (zle Z0 m0)
                             | False -> False with
                       | True -> proj_sumbool (zlt m0 Int.modulus)
                       | False -> False with
                 | True -> proj_sumbool (zle Z0 p)
                 | False -> False with
           | True -> proj_sumbool (zlt p (Zpos (XO (XO (XO (XO (XO XH)))))))
           | False -> False with
     | True -> Some (Pair (p, m0))
     | False -> None)
  | None -> None

(** val divu_mul : z -> z -> expr2 **)

let divu_mul p m0 =
  shruimm (Eop (Omulhu, (Econs ((Eletvar O), (Econs ((Eop ((Ointconst1
    (Int.repr m0)), Enil)), Enil)))))) (Int.repr p)

(** val divuimm : expr2 -> Int.int -> expr2 **)

let divuimm e1 n2 =
  match Int.is_power2 n2 with
  | Some l -> shruimm e1 l
  | None ->
    (match optim_for_size Tt with
     | True -> divu_base e1 (Eop ((Ointconst1 n2), Enil))
     | False ->
       (match divu_mul_params (Int.unsigned n2) with
        | Some p0 -> let Pair (p, m0) = p0 in Elet (e1, (divu_mul p m0))
        | None -> divu_base e1 (Eop ((Ointconst1 n2), Enil))))

type divu_cases =
| Divu_case1 of Int.int
| Divu_default of expr2

(** val divu_match : expr2 -> divu_cases **)

let divu_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Divu_case1 n2
      | Econs (e0, e1) ->
        Divu_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Divu_default (Eop (x, e)))
| x -> Divu_default x

(** val divu0 : expr2 -> expr2 -> expr2 **)

let divu0 e1 e2 =
  match divu_match e2 with
  | Divu_case1 n2 -> divuimm e1 n2
  | Divu_default e3 -> divu_base e1 e3

(** val mod_from_div : expr2 -> Int.int -> expr2 **)

let mod_from_div equo n0 =
  Eop (Osub1, (Econs ((Eletvar O), (Econs ((mulimm n0 equo), Enil)))))

(** val moduimm : expr2 -> Int.int -> expr2 **)

let moduimm e1 n2 =
  match Int.is_power2 n2 with
  | Some l -> andimm (Int.sub n2 Int.one) e1
  | None ->
    (match optim_for_size Tt with
     | True -> modu_base e1 (Eop ((Ointconst1 n2), Enil))
     | False ->
       (match divu_mul_params (Int.unsigned n2) with
        | Some p0 ->
          let Pair (p, m0) = p0 in
          Elet (e1, (mod_from_div (divu_mul p m0) n2))
        | None -> modu_base e1 (Eop ((Ointconst1 n2), Enil))))

type modu_cases =
| Modu_case1 of Int.int
| Modu_default of expr2

(** val modu_match : expr2 -> modu_cases **)

let modu_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Modu_case1 n2
      | Econs (e0, e1) ->
        Modu_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Modu_default (Eop (x, e)))
| x -> Modu_default x

(** val modu0 : expr2 -> expr2 -> expr2 **)

let modu0 e1 e2 =
  match modu_match e2 with
  | Modu_case1 n2 -> moduimm e1 n2
  | Modu_default e3 -> modu_base e1 e3

(** val divs_mul : z -> z -> expr2 **)

let divs_mul p m0 =
  let e2 = Eop (Omulhs, (Econs ((Eletvar O), (Econs ((Eop ((Ointconst1
    (Int.repr m0)), Enil)), Enil)))))
  in
  let e3 =
    match zlt m0 Int.half_modulus with
    | Left -> e2
    | Right -> add0 e2 (Eletvar O)
  in
  add0 (shrimm e3 (Int.repr p))
    (shruimm (Eletvar O) (Int.repr (Z.sub Int.zwordsize (Zpos XH))))

(** val divsimm : expr2 -> Int.int -> expr2 **)

let divsimm e1 n2 =
  match Int.is_power2 n2 with
  | Some l ->
    (match Int.ltu l (Int.repr (Zpos (XI (XI (XI (XI XH)))))) with
     | True -> shrximm e1 l
     | False -> divs_base e1 (Eop ((Ointconst1 n2), Enil)))
  | None ->
    (match optim_for_size Tt with
     | True -> divs_base e1 (Eop ((Ointconst1 n2), Enil))
     | False ->
       (match divs_mul_params (Int.signed n2) with
        | Some p0 -> let Pair (p, m0) = p0 in Elet (e1, (divs_mul p m0))
        | None -> divs_base e1 (Eop ((Ointconst1 n2), Enil))))

type divs_cases =
| Divs_case1 of Int.int
| Divs_default of expr2

(** val divs_match : expr2 -> divs_cases **)

let divs_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Divs_case1 n2
      | Econs (e0, e1) ->
        Divs_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Divs_default (Eop (x, e)))
| x -> Divs_default x

(** val divs0 : expr2 -> expr2 -> expr2 **)

let divs0 e1 e2 =
  match divs_match e2 with
  | Divs_case1 n2 -> divsimm e1 n2
  | Divs_default e3 -> divs_base e1 e3

(** val modsimm : expr2 -> Int.int -> expr2 **)

let modsimm e1 n2 =
  match Int.is_power2 n2 with
  | Some l ->
    (match Int.ltu l (Int.repr (Zpos (XI (XI (XI (XI XH)))))) with
     | True -> Elet (e1, (mod_from_div (shrximm (Eletvar O) l) n2))
     | False -> mods_base e1 (Eop ((Ointconst1 n2), Enil)))
  | None ->
    (match optim_for_size Tt with
     | True -> mods_base e1 (Eop ((Ointconst1 n2), Enil))
     | False ->
       (match divs_mul_params (Int.signed n2) with
        | Some p0 ->
          let Pair (p, m0) = p0 in
          Elet (e1, (mod_from_div (divs_mul p m0) n2))
        | None -> mods_base e1 (Eop ((Ointconst1 n2), Enil))))

type mods_cases =
| Mods_case1 of Int.int
| Mods_default of expr2

(** val mods_match : expr2 -> mods_cases **)

let mods_match = function
| Eop (o, e) ->
  (match o with
   | Ointconst1 n2 ->
     (match e with
      | Enil -> Mods_case1 n2
      | Econs (e0, e1) ->
        Mods_default (Eop ((Ointconst1 n2), (Econs (e0, e1)))))
   | x -> Mods_default (Eop (x, e)))
| x -> Mods_default x

(** val mods0 : expr2 -> expr2 -> expr2 **)

let mods0 e1 e2 =
  match mods_match e2 with
  | Mods_case1 n2 -> modsimm e1 n2
  | Mods_default e3 -> mods_base e1 e3

(** val divfimm : expr2 -> float -> expr2 **)

let divfimm e n0 =
  match Float.exact_inverse n0 with
  | Some n' ->
    Eop (Omulf0, (Econs (e, (Econs ((Eop ((Ofloatconst1 n'), Enil)),
      Enil)))))
  | None ->
    Eop (Odivf0, (Econs (e, (Econs ((Eop ((Ofloatconst1 n0), Enil)),
      Enil)))))

type divf_cases =
| Divf_case1 of float
| Divf_default of expr2

(** val divf_match : expr2 -> divf_cases **)

let divf_match = function
| Eop (o, e) ->
  (match o with
   | Ofloatconst1 n2 ->
     (match e with
      | Enil -> Divf_case1 n2
      | Econs (e0, e1) ->
        Divf_default (Eop ((Ofloatconst1 n2), (Econs (e0, e1)))))
   | x -> Divf_default (Eop (x, e)))
| x -> Divf_default x

(** val divf0 : expr2 -> expr2 -> expr2 **)

let divf0 e1 e2 =
  match divf_match e2 with
  | Divf_case1 n2 -> divfimm e1 n2
  | Divf_default e3 -> Eop (Odivf0, (Econs (e1, (Econs (e3, Enil)))))

(** val divfsimm : expr2 -> float32 -> expr2 **)

let divfsimm e n0 =
  match Float32.exact_inverse n0 with
  | Some n' ->
    Eop (Omulfs0, (Econs (e, (Econs ((Eop ((Osingleconst1 n'), Enil)),
      Enil)))))
  | None ->
    Eop (Odivfs0, (Econs (e, (Econs ((Eop ((Osingleconst1 n0), Enil)),
      Enil)))))

type divfs_cases =
| Divfs_case1 of float32
| Divfs_default of expr2

(** val divfs_match : expr2 -> divfs_cases **)

let divfs_match = function
| Eop (o, e) ->
  (match o with
   | Osingleconst1 n2 ->
     (match e with
      | Enil -> Divfs_case1 n2
      | Econs (e0, e1) ->
        Divfs_default (Eop ((Osingleconst1 n2), (Econs (e0, e1)))))
   | x -> Divfs_default (Eop (x, e)))
| x -> Divfs_default x

(** val divfs0 : expr2 -> expr2 -> expr2 **)

let divfs0 e1 e2 =
  match divfs_match e2 with
  | Divfs_case1 n2 -> divfsimm e1 n2
  | Divfs_default e3 -> Eop (Odivfs0, (Econs (e1, (Econs (e3, Enil)))))

type helper_functions = { i64_dtos : ident; i64_dtou : ident;
                          i64_stod : ident; i64_utod : ident;
                          i64_stof : ident; i64_utof : ident;
                          i64_sdiv : ident; i64_udiv : ident;
                          i64_smod : ident; i64_umod : ident;
                          i64_shl : ident; i64_shr : ident; i64_sar : 
                          ident }

(** val i64_dtos : helper_functions -> ident **)

let i64_dtos x = x.i64_dtos

(** val i64_dtou : helper_functions -> ident **)

let i64_dtou x = x.i64_dtou

(** val i64_stod : helper_functions -> ident **)

let i64_stod x = x.i64_stod

(** val i64_utod : helper_functions -> ident **)

let i64_utod x = x.i64_utod

(** val i64_stof : helper_functions -> ident **)

let i64_stof x = x.i64_stof

(** val i64_utof : helper_functions -> ident **)

let i64_utof x = x.i64_utof

(** val i64_sdiv : helper_functions -> ident **)

let i64_sdiv x = x.i64_sdiv

(** val i64_udiv : helper_functions -> ident **)

let i64_udiv x = x.i64_udiv

(** val i64_smod : helper_functions -> ident **)

let i64_smod x = x.i64_smod

(** val i64_umod : helper_functions -> ident **)

let i64_umod x = x.i64_umod

(** val i64_shl : helper_functions -> ident **)

let i64_shl x = x.i64_shl

(** val i64_shr : helper_functions -> ident **)

let i64_shr x = x.i64_shr

(** val i64_sar : helper_functions -> ident **)

let i64_sar x = x.i64_sar

(** val sig_l_l : signature **)

let sig_l_l =
  { sig_args = (Cons (Tlong, Nil)); sig_res = (Some Tlong); sig_cc =
    cc_default }

(** val sig_l_f : signature **)

let sig_l_f =
  { sig_args = (Cons (Tlong, Nil)); sig_res = (Some Tfloat); sig_cc =
    cc_default }

(** val sig_l_s : signature **)

let sig_l_s =
  { sig_args = (Cons (Tlong, Nil)); sig_res = (Some Tsingle); sig_cc =
    cc_default }

(** val sig_f_l : signature **)

let sig_f_l =
  { sig_args = (Cons (Tfloat, Nil)); sig_res = (Some Tlong); sig_cc =
    cc_default }

(** val sig_ll_l : signature **)

let sig_ll_l =
  { sig_args = (Cons (Tlong, (Cons (Tlong, Nil)))); sig_res = (Some Tlong);
    sig_cc = cc_default }

(** val sig_li_l : signature **)

let sig_li_l =
  { sig_args = (Cons (Tlong, (Cons (Tint, Nil)))); sig_res = (Some Tlong);
    sig_cc = cc_default }

(** val sig_ii_l : signature **)

let sig_ii_l =
  { sig_args = (Cons (Tint, (Cons (Tint, Nil)))); sig_res = (Some Tlong);
    sig_cc = cc_default }

(** val makelong : expr2 -> expr2 -> expr2 **)

let makelong h l =
  Eop (Omakelong, (Econs (h, (Econs (l, Enil)))))

type splitlong_cases =
| Splitlong_case1 of expr2 * expr2
| Splitlong_default of expr2

(** val splitlong_match : expr2 -> splitlong_cases **)

let splitlong_match = function
| Eop (o, e0) ->
  (match o with
   | Omakelong ->
     (match e0 with
      | Enil -> Splitlong_default (Eop (Omakelong, Enil))
      | Econs (h, e1) ->
        (match e1 with
         | Enil -> Splitlong_default (Eop (Omakelong, (Econs (h, Enil))))
         | Econs (l, e2) ->
           (match e2 with
            | Enil -> Splitlong_case1 (h, l)
            | Econs (e3, e4) ->
              Splitlong_default (Eop (Omakelong, (Econs (h, (Econs (l, (Econs
                (e3, e4)))))))))))
   | x -> Splitlong_default (Eop (x, e0)))
| x -> Splitlong_default x

(** val splitlong : expr2 -> (expr2 -> expr2 -> expr2) -> expr2 **)

let splitlong e f =
  match splitlong_match e with
  | Splitlong_case1 (h, l) -> f h l
  | Splitlong_default e0 ->
    Elet (e0,
      (f (Eop (Ohighlong, (Econs ((Eletvar O), Enil)))) (Eop (Olowlong,
        (Econs ((Eletvar O), Enil))))))

type splitlong2_cases =
| Splitlong2_case1 of expr2 * expr2 * expr2 * expr2
| Splitlong2_case2 of expr2 * expr2 * expr2
| Splitlong2_case3 of expr2 * expr2 * expr2
| Splitlong2_default of expr2 * expr2

(** val splitlong2_match : expr2 -> expr2 -> splitlong2_cases **)

let splitlong2_match e1 e2 =
  match e1 with
  | Eop (o, e) ->
    (match o with
     | Omakelong ->
       (match e with
        | Enil ->
          let e3 = Eop (Omakelong, Enil) in
          (match e2 with
           | Eop (o0, e0) ->
             (match o0 with
              | Omakelong ->
                (match e0 with
                 | Enil -> Splitlong2_default (e3, (Eop (Omakelong, Enil)))
                 | Econs (h2, e4) ->
                   (match e4 with
                    | Enil ->
                      Splitlong2_default (e3, (Eop (Omakelong, (Econs (h2,
                        Enil)))))
                    | Econs (l2, e5) ->
                      (match e5 with
                       | Enil -> Splitlong2_case3 (e3, h2, l2)
                       | Econs (e6, e7) ->
                         Splitlong2_default (e3, (Eop (Omakelong, (Econs (h2,
                           (Econs (l2, (Econs (e6, e7))))))))))))
              | x -> Splitlong2_default (e3, (Eop (x, e0))))
           | x -> Splitlong2_default (e3, x))
        | Econs (h1, e0) ->
          (match e0 with
           | Enil ->
             let e3 = Eop (Omakelong, (Econs (h1, Enil))) in
             (match e2 with
              | Eop (o0, e4) ->
                (match o0 with
                 | Omakelong ->
                   (match e4 with
                    | Enil ->
                      Splitlong2_default (e3, (Eop (Omakelong, Enil)))
                    | Econs (h2, e5) ->
                      (match e5 with
                       | Enil ->
                         Splitlong2_default (e3, (Eop (Omakelong, (Econs (h2,
                           Enil)))))
                       | Econs (l2, e6) ->
                         (match e6 with
                          | Enil -> Splitlong2_case3 (e3, h2, l2)
                          | Econs (e7, e8) ->
                            Splitlong2_default (e3, (Eop (Omakelong, (Econs
                              (h2, (Econs (l2, (Econs (e7, e8))))))))))))
                 | x -> Splitlong2_default (e3, (Eop (x, e4))))
              | x -> Splitlong2_default (e3, x))
           | Econs (l1, e3) ->
             (match e3 with
              | Enil ->
                (match e2 with
                 | Eop (o0, e4) ->
                   (match o0 with
                    | Omakelong ->
                      (match e4 with
                       | Enil ->
                         Splitlong2_case2 (h1, l1, (Eop (Omakelong, Enil)))
                       | Econs (h2, e5) ->
                         (match e5 with
                          | Enil ->
                            Splitlong2_case2 (h1, l1, (Eop (Omakelong, (Econs
                              (h2, Enil)))))
                          | Econs (l2, e6) ->
                            (match e6 with
                             | Enil -> Splitlong2_case1 (h1, l1, h2, l2)
                             | Econs (e7, e8) ->
                               Splitlong2_case2 (h1, l1, (Eop (Omakelong,
                                 (Econs (h2, (Econs (l2, (Econs (e7,
                                 e8))))))))))))
                    | x -> Splitlong2_case2 (h1, l1, (Eop (x, e4))))
                 | x -> Splitlong2_case2 (h1, l1, x))
              | Econs (e4, e5) ->
                let e6 = Eop (Omakelong, (Econs (h1, (Econs (l1, (Econs (e4,
                  e5)))))))
                in
                (match e2 with
                 | Eop (o0, e7) ->
                   (match o0 with
                    | Omakelong ->
                      (match e7 with
                       | Enil ->
                         Splitlong2_default (e6, (Eop (Omakelong, Enil)))
                       | Econs (h2, e8) ->
                         (match e8 with
                          | Enil ->
                            Splitlong2_default (e6, (Eop (Omakelong, (Econs
                              (h2, Enil)))))
                          | Econs (l2, e9) ->
                            (match e9 with
                             | Enil -> Splitlong2_case3 (e6, h2, l2)
                             | Econs (e10, e11) ->
                               Splitlong2_default (e6, (Eop (Omakelong,
                                 (Econs (h2, (Econs (l2, (Econs (e10,
                                 e11))))))))))))
                    | x -> Splitlong2_default (e6, (Eop (x, e7))))
                 | x -> Splitlong2_default (e6, x)))))
     | x ->
       let e3 = Eop (x, e) in
       (match e2 with
        | Eop (o0, e0) ->
          (match o0 with
           | Omakelong ->
             (match e0 with
              | Enil -> Splitlong2_default (e3, (Eop (Omakelong, Enil)))
              | Econs (h2, e4) ->
                (match e4 with
                 | Enil ->
                   Splitlong2_default (e3, (Eop (Omakelong, (Econs (h2,
                     Enil)))))
                 | Econs (l2, e5) ->
                   (match e5 with
                    | Enil -> Splitlong2_case3 (e3, h2, l2)
                    | Econs (e6, e7) ->
                      Splitlong2_default (e3, (Eop (Omakelong, (Econs (h2,
                        (Econs (l2, (Econs (e6, e7))))))))))))
           | x0 -> Splitlong2_default (e3, (Eop (x0, e0))))
        | x0 -> Splitlong2_default (e3, x0)))
  | x ->
    (match e2 with
     | Eop (o, e) ->
       (match o with
        | Omakelong ->
          (match e with
           | Enil -> Splitlong2_default (x, (Eop (Omakelong, Enil)))
           | Econs (h2, e0) ->
             (match e0 with
              | Enil ->
                Splitlong2_default (x, (Eop (Omakelong, (Econs (h2, Enil)))))
              | Econs (l2, e3) ->
                (match e3 with
                 | Enil -> Splitlong2_case3 (x, h2, l2)
                 | Econs (e4, e5) ->
                   Splitlong2_default (x, (Eop (Omakelong, (Econs (h2, (Econs
                     (l2, (Econs (e4, e5))))))))))))
        | x0 -> Splitlong2_default (x, (Eop (x0, e))))
     | x0 -> Splitlong2_default (x, x0))

(** val splitlong2 :
    expr2 -> expr2 -> (expr2 -> expr2 -> expr2 -> expr2 -> expr2) -> expr2 **)

let splitlong2 e1 e2 f =
  match splitlong2_match e1 e2 with
  | Splitlong2_case1 (h1, l1, h2, l2) -> f h1 l1 h2 l2
  | Splitlong2_case2 (h1, l1, t2) ->
    Elet (t2,
      (f (lift h1) (lift l1) (Eop (Ohighlong, (Econs ((Eletvar O), Enil))))
        (Eop (Olowlong, (Econs ((Eletvar O), Enil))))))
  | Splitlong2_case3 (t1, h2, l2) ->
    Elet (t1,
      (f (Eop (Ohighlong, (Econs ((Eletvar O), Enil)))) (Eop (Olowlong,
        (Econs ((Eletvar O), Enil)))) (lift h2) (lift l2)))
  | Splitlong2_default (e3, e4) ->
    Elet (e3, (Elet ((lift e4),
      (f (Eop (Ohighlong, (Econs ((Eletvar (S O)), Enil)))) (Eop (Olowlong,
        (Econs ((Eletvar (S O)), Enil)))) (Eop (Ohighlong, (Econs ((Eletvar
        O), Enil)))) (Eop (Olowlong, (Econs ((Eletvar O), Enil))))))))

type lowlong_cases =
| Lowlong_case1 of expr2 * expr2
| Lowlong_default of expr2

(** val lowlong_match : expr2 -> lowlong_cases **)

let lowlong_match = function
| Eop (o, e0) ->
  (match o with
   | Omakelong ->
     (match e0 with
      | Enil -> Lowlong_default (Eop (Omakelong, Enil))
      | Econs (e1, e2) ->
        (match e2 with
         | Enil -> Lowlong_default (Eop (Omakelong, (Econs (e1, Enil))))
         | Econs (e3, e4) ->
           (match e4 with
            | Enil -> Lowlong_case1 (e1, e3)
            | Econs (e5, e6) ->
              Lowlong_default (Eop (Omakelong, (Econs (e1, (Econs (e3, (Econs
                (e5, e6)))))))))))
   | x -> Lowlong_default (Eop (x, e0)))
| x -> Lowlong_default x

(** val lowlong : expr2 -> expr2 **)

let lowlong e =
  match lowlong_match e with
  | Lowlong_case1 (e1, e2) -> e2
  | Lowlong_default e0 -> Eop (Olowlong, (Econs (e0, Enil)))

type highlong_cases =
| Highlong_case1 of expr2 * expr2
| Highlong_default of expr2

(** val highlong_match : expr2 -> highlong_cases **)

let highlong_match = function
| Eop (o, e0) ->
  (match o with
   | Omakelong ->
     (match e0 with
      | Enil -> Highlong_default (Eop (Omakelong, Enil))
      | Econs (e1, e2) ->
        (match e2 with
         | Enil -> Highlong_default (Eop (Omakelong, (Econs (e1, Enil))))
         | Econs (e3, e4) ->
           (match e4 with
            | Enil -> Highlong_case1 (e1, e3)
            | Econs (e5, e6) ->
              Highlong_default (Eop (Omakelong, (Econs (e1, (Econs (e3,
                (Econs (e5, e6)))))))))))
   | x -> Highlong_default (Eop (x, e0)))
| x -> Highlong_default x

(** val highlong : expr2 -> expr2 **)

let highlong e =
  match highlong_match e with
  | Highlong_case1 (e1, e2) -> e1
  | Highlong_default e0 -> Eop (Ohighlong, (Econs (e0, Enil)))

(** val longconst : Int64.int -> expr2 **)

let longconst n0 =
  makelong (Eop ((Ointconst1 (Int64.hiword n0)), Enil)) (Eop ((Ointconst1
    (Int64.loword n0)), Enil))

type is_longconst_cases =
| Is_longconst_case1 of Int.int * Int.int
| Is_longconst_default of expr2

(** val is_longconst_match : expr2 -> is_longconst_cases **)

let is_longconst_match = function
| Eop (o, e0) ->
  (match o with
   | Omakelong ->
     (match e0 with
      | Enil -> Is_longconst_default (Eop (Omakelong, Enil))
      | Econs (e1, e2) ->
        (match e1 with
         | Eop (o0, e3) ->
           (match o0 with
            | Ointconst1 h ->
              (match e3 with
               | Enil ->
                 (match e2 with
                  | Enil ->
                    Is_longconst_default (Eop (Omakelong, (Econs ((Eop
                      ((Ointconst1 h), Enil)), Enil))))
                  | Econs (e4, e5) ->
                    (match e4 with
                     | Eop (o1, e6) ->
                       (match o1 with
                        | Ointconst1 l ->
                          (match e6 with
                           | Enil ->
                             (match e5 with
                              | Enil -> Is_longconst_case1 (h, l)
                              | Econs (e7, e8) ->
                                Is_longconst_default (Eop (Omakelong, (Econs
                                  ((Eop ((Ointconst1 h), Enil)), (Econs ((Eop
                                  ((Ointconst1 l), Enil)), (Econs (e7,
                                  e8)))))))))
                           | Econs (e7, e8) ->
                             Is_longconst_default (Eop (Omakelong, (Econs
                               ((Eop ((Ointconst1 h), Enil)), (Econs ((Eop
                               ((Ointconst1 l), (Econs (e7, e8)))), e5)))))))
                        | Omakelong ->
                          Is_longconst_default (Eop (Omakelong, (Econs ((Eop
                            ((Ointconst1 h), Enil)), (Econs ((Eop (Omakelong,
                            e6)), e5))))))
                        | x ->
                          Is_longconst_default (Eop (Omakelong, (Econs ((Eop
                            ((Ointconst1 h), Enil)), (Econs ((Eop (x, e6)),
                            e5)))))))
                     | x ->
                       Is_longconst_default (Eop (Omakelong, (Econs ((Eop
                         ((Ointconst1 h), Enil)), (Econs (x, e5))))))))
               | Econs (e4, e5) ->
                 Is_longconst_default (Eop (Omakelong, (Econs ((Eop
                   ((Ointconst1 h), (Econs (e4, e5)))), e2)))))
            | Omakelong ->
              Is_longconst_default (Eop (Omakelong, (Econs ((Eop (Omakelong,
                e3)), e2))))
            | x ->
              Is_longconst_default (Eop (Omakelong, (Econs ((Eop (x, e3)),
                e2)))))
         | x -> Is_longconst_default (Eop (Omakelong, (Econs (x, e2))))))
   | x -> Is_longconst_default (Eop (x, e0)))
| x -> Is_longconst_default x

(** val is_longconst : expr2 -> Int64.int option **)

let is_longconst e =
  match is_longconst_match e with
  | Is_longconst_case1 (h, l) -> Some (Int64.ofwords h l)
  | Is_longconst_default e0 -> None

(** val is_longconst_zero : expr2 -> bool **)

let is_longconst_zero e =
  match is_longconst e with
  | Some n0 -> Int64.eq n0 Int64.zero
  | None -> False

(** val intoflong : expr2 -> expr2 **)

let intoflong e =
  lowlong e

(** val longofint0 : expr2 -> expr2 **)

let longofint0 e =
  Elet (e,
    (makelong (shrimm (Eletvar O) (Int.repr (Zpos (XI (XI (XI (XI XH)))))))
      (Eletvar O)))

(** val longofintu0 : expr2 -> expr2 **)

let longofintu0 e =
  makelong (Eop ((Ointconst1 Int.zero), Enil)) e

(** val negl0 : expr2 -> expr2 **)

let negl0 e =
  match is_longconst e with
  | Some n0 -> longconst (Int64.neg n0)
  | None ->
    Ebuiltin ((EF_builtin ((String ((Ascii (True, True, True, True, True,
      False, True, False)), (String ((Ascii (True, True, True, True, True,
      False, True, False)), (String ((Ascii (False, True, False, False,
      False, True, True, False)), (String ((Ascii (True, False, True, False,
      True, True, True, False)), (String ((Ascii (True, False, False, True,
      False, True, True, False)), (String ((Ascii (False, False, True, True,
      False, True, True, False)), (String ((Ascii (False, False, True, False,
      True, True, True, False)), (String ((Ascii (True, False, False, True,
      False, True, True, False)), (String ((Ascii (False, True, True, True,
      False, True, True, False)), (String ((Ascii (True, True, True, True,
      True, False, True, False)), (String ((Ascii (False, True, True, True,
      False, True, True, False)), (String ((Ascii (True, False, True, False,
      False, True, True, False)), (String ((Ascii (True, True, True, False,
      False, True, True, False)), (String ((Ascii (False, False, True, True,
      False, True, True, False)), EmptyString)))))))))))))))))))))))))))),
      sig_l_l)), (Econs (e, Enil)))

(** val notl0 : expr2 -> expr2 **)

let notl0 e =
  splitlong e (fun h l -> makelong (notint0 h) (notint0 l))

(** val longoffloat0 : helper_functions -> expr2 -> expr2 **)

let longoffloat0 hf arg =
  Eexternal (hf.i64_dtos, sig_f_l, (Econs (arg, Enil)))

(** val longuoffloat0 : helper_functions -> expr2 -> expr2 **)

let longuoffloat0 hf arg =
  Eexternal (hf.i64_dtou, sig_f_l, (Econs (arg, Enil)))

(** val floatoflong0 : helper_functions -> expr2 -> expr2 **)

let floatoflong0 hf arg =
  Eexternal (hf.i64_stod, sig_l_f, (Econs (arg, Enil)))

(** val floatoflongu0 : helper_functions -> expr2 -> expr2 **)

let floatoflongu0 hf arg =
  Eexternal (hf.i64_utod, sig_l_f, (Econs (arg, Enil)))

(** val longofsingle0 : helper_functions -> expr2 -> expr2 **)

let longofsingle0 hf arg =
  longoffloat0 hf (floatofsingle0 arg)

(** val longuofsingle0 : helper_functions -> expr2 -> expr2 **)

let longuofsingle0 hf arg =
  longuoffloat0 hf (floatofsingle0 arg)

(** val singleoflong0 : helper_functions -> expr2 -> expr2 **)

let singleoflong0 hf arg =
  Eexternal (hf.i64_stof, sig_l_s, (Econs (arg, Enil)))

(** val singleoflongu0 : helper_functions -> expr2 -> expr2 **)

let singleoflongu0 hf arg =
  Eexternal (hf.i64_utof, sig_l_s, (Econs (arg, Enil)))

(** val andl0 : expr2 -> expr2 -> expr2 **)

let andl0 e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> makelong (and0 h1 h2) (and0 l1 l2))

(** val orl0 : expr2 -> expr2 -> expr2 **)

let orl0 e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> makelong (or0 h1 h2) (or0 l1 l2))

(** val xorl0 : expr2 -> expr2 -> expr2 **)

let xorl0 e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> makelong (xor0 h1 h2) (xor0 l1 l2))

(** val shllimm : helper_functions -> expr2 -> Int.int -> expr2 **)

let shllimm hf e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True ->
       splitlong e1 (fun h l ->
         makelong (or0 (shlimm h n0) (shruimm l (Int.sub Int.iwordsize n0)))
           (shlimm l n0))
     | False ->
       (match Int.ltu n0 Int64.iwordsize' with
        | True ->
          makelong (shlimm (lowlong e1) (Int.sub n0 Int.iwordsize)) (Eop
            ((Ointconst1 Int.zero), Enil))
        | False ->
          Eexternal (hf.i64_shl, sig_li_l, (Econs (e1, (Econs ((Eop
            ((Ointconst1 n0), Enil)), Enil)))))))

(** val shrluimm : helper_functions -> expr2 -> Int.int -> expr2 **)

let shrluimm hf e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True ->
       splitlong e1 (fun h l ->
         makelong (shruimm h n0)
           (or0 (shruimm l n0) (shlimm h (Int.sub Int.iwordsize n0))))
     | False ->
       (match Int.ltu n0 Int64.iwordsize' with
        | True ->
          makelong (Eop ((Ointconst1 Int.zero), Enil))
            (shruimm (highlong e1) (Int.sub n0 Int.iwordsize))
        | False ->
          Eexternal (hf.i64_shr, sig_li_l, (Econs (e1, (Econs ((Eop
            ((Ointconst1 n0), Enil)), Enil)))))))

(** val shrlimm : helper_functions -> expr2 -> Int.int -> expr2 **)

let shrlimm hf e1 n0 =
  match Int.eq n0 Int.zero with
  | True -> e1
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True ->
       splitlong e1 (fun h l ->
         makelong (shrimm h n0)
           (or0 (shruimm l n0) (shlimm h (Int.sub Int.iwordsize n0))))
     | False ->
       (match Int.ltu n0 Int64.iwordsize' with
        | True ->
          Elet ((highlong e1),
            (makelong
              (shrimm (Eletvar O) (Int.repr (Zpos (XI (XI (XI (XI XH)))))))
              (shrimm (Eletvar O) (Int.sub n0 Int.iwordsize))))
        | False ->
          Eexternal (hf.i64_sar, sig_li_l, (Econs (e1, (Econs ((Eop
            ((Ointconst1 n0), Enil)), Enil)))))))

(** val is_intconst : expr2 -> Int.int option **)

let is_intconst = function
| Eop (o, e0) ->
  (match o with
   | Ointconst1 n0 ->
     (match e0 with
      | Enil -> Some n0
      | Econs (e1, e2) -> None)
   | _ -> None)
| _ -> None

(** val shll0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let shll0 hf e1 e2 =
  match is_intconst e2 with
  | Some n0 -> shllimm hf e1 n0
  | None ->
    Eexternal (hf.i64_shl, sig_li_l, (Econs (e1, (Econs (e2, Enil)))))

(** val shrlu0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let shrlu0 hf e1 e2 =
  match is_intconst e2 with
  | Some n0 -> shrluimm hf e1 n0
  | None ->
    Eexternal (hf.i64_shr, sig_li_l, (Econs (e1, (Econs (e2, Enil)))))

(** val shrl0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let shrl0 hf e1 e2 =
  match is_intconst e2 with
  | Some n0 -> shrlimm hf e1 n0
  | None ->
    Eexternal (hf.i64_sar, sig_li_l, (Econs (e1, (Econs (e2, Enil)))))

(** val addl0 : expr2 -> expr2 -> expr2 **)

let addl0 e1 e2 =
  let default0 = Ebuiltin ((EF_builtin ((String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (False, True, False,
    False, False, True, True, False)), (String ((Ascii (True, False, True,
    False, True, True, True, False)), (String ((Ascii (True, False, False,
    True, False, True, True, False)), (String ((Ascii (False, False, True,
    True, False, True, True, False)), (String ((Ascii (False, False, True,
    False, True, True, True, False)), (String ((Ascii (True, False, False,
    True, False, True, True, False)), (String ((Ascii (False, True, True,
    True, False, True, True, False)), (String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (True, False, False,
    False, False, True, True, False)), (String ((Ascii (False, False, True,
    False, False, True, True, False)), (String ((Ascii (False, False, True,
    False, False, True, True, False)), (String ((Ascii (False, False, True,
    True, False, True, True, False)),
    EmptyString)))))))))))))))))))))))))))), sig_ll_l)), (Econs (e1, (Econs
    (e2, Enil)))))
  in
  (match is_longconst e1 with
   | Some n1 ->
     (match is_longconst e2 with
      | Some n2 -> longconst (Int64.add n1 n2)
      | None ->
        (match Int64.eq n1 Int64.zero with
         | True -> e2
         | False -> default0))
   | None ->
     (match is_longconst e2 with
      | Some n2 ->
        (match Int64.eq n2 Int64.zero with
         | True -> e1
         | False -> default0)
      | None -> default0))

(** val subl0 : expr2 -> expr2 -> expr2 **)

let subl0 e1 e2 =
  let default0 = Ebuiltin ((EF_builtin ((String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (False, True, False,
    False, False, True, True, False)), (String ((Ascii (True, False, True,
    False, True, True, True, False)), (String ((Ascii (True, False, False,
    True, False, True, True, False)), (String ((Ascii (False, False, True,
    True, False, True, True, False)), (String ((Ascii (False, False, True,
    False, True, True, True, False)), (String ((Ascii (True, False, False,
    True, False, True, True, False)), (String ((Ascii (False, True, True,
    True, False, True, True, False)), (String ((Ascii (True, True, True,
    True, True, False, True, False)), (String ((Ascii (True, True, False,
    False, True, True, True, False)), (String ((Ascii (True, False, True,
    False, True, True, True, False)), (String ((Ascii (False, True, False,
    False, False, True, True, False)), (String ((Ascii (False, False, True,
    True, False, True, True, False)),
    EmptyString)))))))))))))))))))))))))))), sig_ll_l)), (Econs (e1, (Econs
    (e2, Enil)))))
  in
  (match is_longconst e1 with
   | Some n1 ->
     (match is_longconst e2 with
      | Some n2 -> longconst (Int64.sub n1 n2)
      | None ->
        (match Int64.eq n1 Int64.zero with
         | True -> negl0 e2
         | False -> default0))
   | None ->
     (match is_longconst e2 with
      | Some n2 ->
        (match Int64.eq n2 Int64.zero with
         | True -> e1
         | False -> default0)
      | None -> default0))

(** val mull_base : expr2 -> expr2 -> expr2 **)

let mull_base e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> Elet ((Ebuiltin ((EF_builtin ((String
    ((Ascii (True, True, True, True, True, False, True, False)), (String
    ((Ascii (True, True, True, True, True, False, True, False)), (String
    ((Ascii (False, True, False, False, False, True, True, False)), (String
    ((Ascii (True, False, True, False, True, True, True, False)), (String
    ((Ascii (True, False, False, True, False, True, True, False)), (String
    ((Ascii (False, False, True, True, False, True, True, False)), (String
    ((Ascii (False, False, True, False, True, True, True, False)), (String
    ((Ascii (True, False, False, True, False, True, True, False)), (String
    ((Ascii (False, True, True, True, False, True, True, False)), (String
    ((Ascii (True, True, True, True, True, False, True, False)), (String
    ((Ascii (True, False, True, True, False, True, True, False)), (String
    ((Ascii (True, False, True, False, True, True, True, False)), (String
    ((Ascii (False, False, True, True, False, True, True, False)), (String
    ((Ascii (False, False, True, True, False, True, True, False)),
    EmptyString)))))))))))))))))))))))))))), sig_ii_l)), (Econs (l1, (Econs
    (l2, Enil)))))),
    (makelong
      (add0
        (add0 (Eop (Ohighlong, (Econs ((Eletvar O), Enil))))
          (mul0 (lift l1) (lift h2))) (mul0 (lift h1) (lift l2))) (Eop
      (Olowlong, (Econs ((Eletvar O), Enil)))))))

(** val mullimm : helper_functions -> expr2 -> Int64.int -> expr2 **)

let mullimm hf e n0 =
  match Int64.eq n0 Int64.zero with
  | True -> longconst Int64.zero
  | False ->
    (match Int64.eq n0 Int64.one with
     | True -> e
     | False ->
       (match Int64.is_power2 n0 with
        | Some l -> shllimm hf e (Int.repr (Int64.unsigned l))
        | None -> mull_base e (longconst n0)))

(** val mull0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let mull0 hf e1 e2 =
  match is_longconst e1 with
  | Some n1 ->
    (match is_longconst e2 with
     | Some n2 -> longconst (Int64.mul n1 n2)
     | None -> mullimm hf e2 n1)
  | None ->
    (match is_longconst e2 with
     | Some n2 -> mullimm hf e1 n2
     | None -> mull_base e1 e2)

(** val binop_long :
    ident -> (Int64.int -> Int64.int -> Int64.int) -> expr2 -> expr2 -> expr2 **)

let binop_long id sem e1 e2 =
  match is_longconst e1 with
  | Some n1 ->
    (match is_longconst e2 with
     | Some n2 -> longconst (sem n1 n2)
     | None -> Eexternal (id, sig_ll_l, (Econs (e1, (Econs (e2, Enil))))))
  | None -> Eexternal (id, sig_ll_l, (Econs (e1, (Econs (e2, Enil)))))

(** val divl : helper_functions -> expr2 -> expr2 -> expr2 **)

let divl hf e1 e2 =
  binop_long hf.i64_sdiv Int64.divs e1 e2

(** val modl : helper_functions -> expr2 -> expr2 -> expr2 **)

let modl hf e1 e2 =
  binop_long hf.i64_smod Int64.mods e1 e2

(** val divlu0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let divlu0 hf e1 e2 =
  let default0 = Eexternal (hf.i64_udiv, sig_ll_l, (Econs (e1, (Econs (e2,
    Enil)))))
  in
  (match is_longconst e1 with
   | Some n1 ->
     (match is_longconst e2 with
      | Some n2 -> longconst (Int64.divu n1 n2)
      | None -> default0)
   | None ->
     (match is_longconst e2 with
      | Some n2 ->
        (match Int64.is_power2 n2 with
         | Some l -> shrluimm hf e1 (Int.repr (Int64.unsigned l))
         | None -> default0)
      | None -> default0))

(** val modlu0 : helper_functions -> expr2 -> expr2 -> expr2 **)

let modlu0 hf e1 e2 =
  let default0 = Eexternal (hf.i64_umod, sig_ll_l, (Econs (e1, (Econs (e2,
    Enil)))))
  in
  (match is_longconst e1 with
   | Some n1 ->
     (match is_longconst e2 with
      | Some n2 -> longconst (Int64.modu n1 n2)
      | None -> default0)
   | None ->
     (match is_longconst e2 with
      | Some n2 ->
        (match Int64.is_power2 n2 with
         | Some l -> andl0 e1 (longconst (Int64.sub n2 Int64.one))
         | None -> default0)
      | None -> default0))

(** val cmpl_eq_zero : expr2 -> expr2 **)

let cmpl_eq_zero e =
  splitlong e (fun h l ->
    comp Ceq (or0 h l) (Eop ((Ointconst1 Int.zero), Enil)))

(** val cmpl_ne_zero : expr2 -> expr2 **)

let cmpl_ne_zero e =
  splitlong e (fun h l ->
    comp Cne (or0 h l) (Eop ((Ointconst1 Int.zero), Enil)))

(** val cmplu_gen : comparison0 -> comparison0 -> expr2 -> expr2 -> expr2 **)

let cmplu_gen ch cl e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> Econdition ((CEcond ((Ccomp Ceq),
    (Econs (h1, (Econs (h2, Enil)))))), (Eop ((Ocmp0 (Ccompu cl)), (Econs
    (l1, (Econs (l2, Enil)))))), (Eop ((Ocmp0 (Ccompu ch)), (Econs (h1,
    (Econs (h2, Enil))))))))

(** val cmplu0 : comparison0 -> expr2 -> expr2 -> expr2 **)

let cmplu0 c e1 e2 =
  match c with
  | Ceq -> cmpl_eq_zero (xorl0 e1 e2)
  | Cne -> cmpl_ne_zero (xorl0 e1 e2)
  | Cle -> cmplu_gen Clt Cle e1 e2
  | Cge -> cmplu_gen Cgt Cge e1 e2
  | x -> cmplu_gen x x e1 e2

(** val cmpl_gen : comparison0 -> comparison0 -> expr2 -> expr2 -> expr2 **)

let cmpl_gen ch cl e1 e2 =
  splitlong2 e1 e2 (fun h1 l1 h2 l2 -> Econdition ((CEcond ((Ccomp Ceq),
    (Econs (h1, (Econs (h2, Enil)))))), (Eop ((Ocmp0 (Ccompu cl)), (Econs
    (l1, (Econs (l2, Enil)))))), (Eop ((Ocmp0 (Ccomp ch)), (Econs (h1, (Econs
    (h2, Enil))))))))

(** val cmpl0 : comparison0 -> expr2 -> expr2 -> expr2 **)

let cmpl0 c e1 e2 =
  match c with
  | Ceq -> cmpl_eq_zero (xorl0 e1 e2)
  | Cne -> cmpl_ne_zero (xorl0 e1 e2)
  | Clt ->
    (match is_longconst_zero e2 with
     | True -> comp Clt (highlong e1) (Eop ((Ointconst1 Int.zero), Enil))
     | False -> cmpl_gen Clt Clt e1 e2)
  | Cle -> cmpl_gen Clt Cle e1 e2
  | Cgt -> cmpl_gen Cgt Cgt e1 e2
  | Cge ->
    (match is_longconst_zero e2 with
     | True -> comp Cge (highlong e1) (Eop ((Ointconst1 Int.zero), Enil))
     | False -> cmpl_gen Cgt Cge e1 e2)

(** val condexpr_of_expr : expr2 -> condexpr **)

let rec condexpr_of_expr e = match e with
| Eop (o, el) ->
  (match o with
   | Ocmp0 c -> CEcond (c, el)
   | _ -> CEcond ((Ccompuimm (Cne, Int.zero)), (Econs (e, Enil))))
| Econdition (a, b, c) ->
  CEcondition (a, (condexpr_of_expr b), (condexpr_of_expr c))
| Elet (a, b) -> CElet (a, (condexpr_of_expr b))
| _ -> CEcond ((Ccompuimm (Cne, Int.zero)), (Econs (e, Enil)))

(** val load0 : memory_chunk -> expr2 -> expr2 **)

let load0 chunk e1 =
  let Pair (mode1, args) = addressing0 chunk e1 in
  Eload1 (chunk, mode1, args)

(** val store0 : memory_chunk -> expr2 -> expr2 -> stmt1 **)

let store0 chunk e1 e2 =
  let Pair (mode1, args) = addressing0 chunk e1 in
  Sstore1 (chunk, mode1, args, e2)

(** val sel_constant : constant -> expr2 **)

let sel_constant = function
| Ointconst n0 -> Eop ((Ointconst1 n0), Enil)
| Ofloatconst f -> Eop ((Ofloatconst1 f), Enil)
| Osingleconst f -> Eop ((Osingleconst1 f), Enil)
| Olongconst n0 -> longconst n0
| Oaddrsymbol (id, ofs) -> addrsymbol id ofs
| Oaddrstack ofs -> addrstack ofs

(** val sel_unop : helper_functions -> unary_operation0 -> expr2 -> expr2 **)

let sel_unop hf op arg =
  match op with
  | Ocast8unsigned -> cast8unsigned arg
  | Ocast8signed -> cast8signed arg
  | Ocast16unsigned -> cast16unsigned arg
  | Ocast16signed -> cast16signed arg
  | Onegint -> negint0 arg
  | Onotint0 -> notint0 arg
  | Onegf -> negf0 arg
  | Oabsf -> absf0 arg
  | Onegfs -> negfs0 arg
  | Oabsfs -> absfs0 arg
  | Osingleoffloat -> singleoffloat0 arg
  | Ofloatofsingle -> floatofsingle0 arg
  | Ointoffloat -> intoffloat0 arg
  | Ointuoffloat -> intuoffloat0 arg
  | Ofloatofint -> floatofint0 arg
  | Ofloatofintu -> floatofintu0 arg
  | Ointofsingle -> intofsingle0 arg
  | Ointuofsingle -> intuofsingle0 arg
  | Osingleofint -> singleofint0 arg
  | Osingleofintu -> singleofintu0 arg
  | Onegl -> negl0 arg
  | Onotl -> notl0 arg
  | Ointoflong -> intoflong arg
  | Olongofint -> longofint0 arg
  | Olongofintu -> longofintu0 arg
  | Olongoffloat -> longoffloat0 hf arg
  | Olonguoffloat -> longuoffloat0 hf arg
  | Ofloatoflong -> floatoflong0 hf arg
  | Ofloatoflongu -> floatoflongu0 hf arg
  | Olongofsingle -> longofsingle0 hf arg
  | Olonguofsingle -> longuofsingle0 hf arg
  | Osingleoflong -> singleoflong0 hf arg
  | Osingleoflongu -> singleoflongu0 hf arg

(** val sel_binop :
    helper_functions -> binary_operation0 -> expr2 -> expr2 -> expr2 **)

let sel_binop hf op arg1 arg2 =
  match op with
  | Oadd0 -> add0 arg1 arg2
  | Osub0 -> sub0 arg1 arg2
  | Omul0 -> mul0 arg1 arg2
  | Odiv0 -> divs0 arg1 arg2
  | Odivu -> divu0 arg1 arg2
  | Omod0 -> mods0 arg1 arg2
  | Omodu -> modu0 arg1 arg2
  | Oand0 -> and0 arg1 arg2
  | Oor0 -> or0 arg1 arg2
  | Oxor0 -> xor0 arg1 arg2
  | Oshl0 -> shl0 arg1 arg2
  | Oshr0 -> shr1 arg1 arg2
  | Oshru -> shru0 arg1 arg2
  | Oaddf -> addf0 arg1 arg2
  | Osubf -> subf0 arg1 arg2
  | Omulf -> mulf0 arg1 arg2
  | Odivf -> divf0 arg1 arg2
  | Oaddfs -> addfs0 arg1 arg2
  | Osubfs -> subfs0 arg1 arg2
  | Omulfs -> mulfs0 arg1 arg2
  | Odivfs -> divfs0 arg1 arg2
  | Oaddl -> addl0 arg1 arg2
  | Osubl -> subl0 arg1 arg2
  | Omull -> mull0 hf arg1 arg2
  | Odivl -> divl hf arg1 arg2
  | Odivlu -> divlu0 hf arg1 arg2
  | Omodl -> modl hf arg1 arg2
  | Omodlu -> modlu0 hf arg1 arg2
  | Oandl -> andl0 arg1 arg2
  | Oorl -> orl0 arg1 arg2
  | Oxorl -> xorl0 arg1 arg2
  | Oshll -> shll0 hf arg1 arg2
  | Oshrl -> shrl0 hf arg1 arg2
  | Oshrlu -> shrlu0 hf arg1 arg2
  | Ocmp c -> comp c arg1 arg2
  | Ocmpu c -> compu c arg1 arg2
  | Ocmpf c -> compf c arg1 arg2
  | Ocmpfs c -> compfs c arg1 arg2
  | Ocmpl c -> cmpl0 c arg1 arg2
  | Ocmplu c -> cmplu0 c arg1 arg2

(** val sel_expr : helper_functions -> expr0 -> expr2 **)

let rec sel_expr hf = function
| Evar0 id -> Evar2 id
| Econst cst -> sel_constant cst
| Eunop0 (op, arg) -> sel_unop hf op (sel_expr hf arg)
| Ebinop0 (op, arg1, arg2) ->
  sel_binop hf op (sel_expr hf arg1) (sel_expr hf arg2)
| Eload (chunk, addr) -> load0 chunk (sel_expr hf addr)

(** val sel_exprlist : helper_functions -> expr0 list -> exprlist **)

let rec sel_exprlist hf = function
| Nil -> Enil
| Cons (a, bl) -> Econs ((sel_expr hf a), (sel_exprlist hf bl))

type call_kind =
| Call_default
| Call_imm of ident
| Call_builtin of external_function

(** val expr_is_addrof_ident : expr0 -> ident option **)

let expr_is_addrof_ident = function
| Econst c ->
  (match c with
   | Oaddrsymbol (id, ofs) ->
     (match Int.eq ofs Int.zero with
      | True -> Some id
      | False -> None)
   | _ -> None)
| _ -> None

(** val classify_call : genv -> expr0 -> call_kind **)

let classify_call ge e =
  match expr_is_addrof_ident e with
  | Some id ->
    (match Genv.find_symbol ge id with
     | Some b ->
       (match Genv.find_funct_ptr ge b with
        | Some f ->
          (match f with
           | Internal f0 -> Call_imm id
           | External ef ->
             (match ef_inline ef with
              | True -> Call_builtin ef
              | False -> Call_imm id))
        | None -> Call_imm id)
     | None -> Call_imm id)
  | None -> Call_default

(** val sel_builtin_arg :
    helper_functions -> expr0 -> builtin_arg_constraint -> expr2 builtin_arg **)

let sel_builtin_arg hf e c =
  let e' = sel_expr hf e in
  let ba = builtin_arg0 e' in
  (match builtin_arg_ok ba c with
   | True -> ba
   | False -> BA e')

(** val sel_builtin_args :
    helper_functions -> expr0 list -> builtin_arg_constraint list -> expr2
    builtin_arg list **)

let rec sel_builtin_args hf el cl =
  match el with
  | Nil -> Nil
  | Cons (e, el0) ->
    Cons ((sel_builtin_arg hf e (hd OK_default cl)),
      (sel_builtin_args hf el0 (tl cl)))

(** val sel_builtin_res : ident option -> ident builtin_res **)

let sel_builtin_res = function
| Some id -> BR id
| None -> BR_none

(** val compile_switch : z -> nat -> table -> comptree **)

let compile_switch =
  failwith "AXIOM TO BE REALIZED"

(** val sel_switch :
    (expr2 -> z -> expr2) -> (expr2 -> z -> expr2) -> (expr2 -> z -> expr2)
    -> (expr2 -> expr2) -> nat -> comptree -> exitexpr **)

let rec sel_switch make_cmp_eq make_cmp_ltu make_sub0 make_to_int arg = function
| CTaction act -> XEexit act
| CTifeq (key, act, t'0) ->
  XEcondition ((condexpr_of_expr (make_cmp_eq (Eletvar arg) key)), (XEexit
    act),
    (sel_switch make_cmp_eq make_cmp_ltu make_sub0 make_to_int arg t'0))
| CTiflt (key, t2, t3) ->
  XEcondition ((condexpr_of_expr (make_cmp_ltu (Eletvar arg) key)),
    (sel_switch make_cmp_eq make_cmp_ltu make_sub0 make_to_int arg t2),
    (sel_switch make_cmp_eq make_cmp_ltu make_sub0 make_to_int arg t3))
| CTjumptable (ofs, sz, tbl, t'0) ->
  XElet ((make_sub0 (Eletvar arg) ofs), (XEcondition
    ((condexpr_of_expr (make_cmp_ltu (Eletvar O) sz)), (XEjumptable
    ((make_to_int (Eletvar O)), tbl)),
    (sel_switch make_cmp_eq make_cmp_ltu make_sub0 make_to_int (S arg) t'0))))

(** val sel_switch_int : nat -> comptree -> exitexpr **)

let sel_switch_int =
  sel_switch (fun arg n0 ->
    comp Ceq arg (Eop ((Ointconst1 (Int.repr n0)), Enil))) (fun arg n0 ->
    compu Clt arg (Eop ((Ointconst1 (Int.repr n0)), Enil))) (fun arg ofs ->
    sub0 arg (Eop ((Ointconst1 (Int.repr ofs)), Enil))) (fun arg -> arg)

(** val sel_switch_long : nat -> comptree -> exitexpr **)

let sel_switch_long =
  sel_switch (fun arg n0 -> cmpl0 Ceq arg (longconst (Int64.repr n0)))
    (fun arg n0 -> cmplu0 Clt arg (longconst (Int64.repr n0)))
    (fun arg ofs -> subl0 arg (longconst (Int64.repr ofs))) lowlong

(** val sel_stmt : helper_functions -> genv -> stmt -> stmt1 res **)

let rec sel_stmt hf ge = function
| Sskip0 -> OK Sskip2
| Sassign0 (id, e) -> OK (Sassign1 (id, (sel_expr hf e)))
| Sstore (chunk, addr, rhs0) ->
  OK (store0 chunk (sel_expr hf addr) (sel_expr hf rhs0))
| Scall0 (optid, sg, fn, args) ->
  OK
    (match classify_call ge fn with
     | Call_default ->
       Scall2 (optid, sg, (Inl (sel_expr hf fn)), (sel_exprlist hf args))
     | Call_imm id -> Scall2 (optid, sg, (Inr id), (sel_exprlist hf args))
     | Call_builtin ef ->
       Sbuiltin2 ((sel_builtin_res optid), ef,
         (sel_builtin_args hf args (builtin_constraints ef))))
| Stailcall (sg, fn, args) ->
  OK
    (match classify_call ge fn with
     | Call_imm id -> Stailcall0 (sg, (Inr id), (sel_exprlist hf args))
     | _ -> Stailcall0 (sg, (Inl (sel_expr hf fn)), (sel_exprlist hf args)))
| Sbuiltin0 (optid, ef, args) ->
  OK (Sbuiltin2 ((sel_builtin_res optid), ef,
    (sel_builtin_args hf args (builtin_constraints ef))))
| Sseq (s1, s2) ->
  bind (sel_stmt hf ge s1) (fun s1' ->
    bind (sel_stmt hf ge s2) (fun s2' -> OK (Sseq1 (s1', s2'))))
| Sifthenelse0 (e, ifso, ifnot) ->
  bind (sel_stmt hf ge ifso) (fun ifso' ->
    bind (sel_stmt hf ge ifnot) (fun ifnot' -> OK (Sifthenelse2
      ((condexpr_of_expr (sel_expr hf e)), ifso', ifnot'))))
| Sloop0 body -> bind (sel_stmt hf ge body) (fun body' -> OK (Sloop2 body'))
| Sblock body -> bind (sel_stmt hf ge body) (fun body' -> OK (Sblock1 body'))
| Sexit n0 -> OK (Sexit1 n0)
| Sswitch0 (b, e, cases, dfl) ->
  (match b with
   | True ->
     let t1 = compile_switch Int64.modulus dfl cases in
     (match validate_switch Int64.modulus dfl cases t1 with
      | True ->
        OK (Sswitch2 (XElet ((sel_expr hf e), (sel_switch_long O t1))))
      | False ->
        Error
          (msg (String ((Ascii (True, True, False, False, True, False, True,
            False)), (String ((Ascii (True, False, True, False, False, True,
            True, False)), (String ((Ascii (False, False, True, True, False,
            True, True, False)), (String ((Ascii (True, False, True, False,
            False, True, True, False)), (String ((Ascii (True, True, False,
            False, False, True, True, False)), (String ((Ascii (False, False,
            True, False, True, True, True, False)), (String ((Ascii (True,
            False, False, True, False, True, True, False)), (String ((Ascii
            (True, True, True, True, False, True, True, False)), (String
            ((Ascii (False, True, True, True, False, True, True, False)),
            (String ((Ascii (False, True, False, True, True, True, False,
            False)), (String ((Ascii (False, False, False, False, False,
            True, False, False)), (String ((Ascii (False, True, False, False,
            False, True, True, False)), (String ((Ascii (True, False, False,
            False, False, True, True, False)), (String ((Ascii (False, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, False, False, False, True, False, False)), (String ((Ascii
            (True, True, False, False, True, True, True, False)), (String
            ((Ascii (True, True, True, False, True, True, True, False)),
            (String ((Ascii (True, False, False, True, False, True, True,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (True, True, False, False, False,
            True, True, False)), (String ((Ascii (False, False, False, True,
            False, True, True, False)), (String ((Ascii (False, False, False,
            False, False, True, False, False)), (String ((Ascii (False,
            False, False, True, False, True, False, False)), (String ((Ascii
            (False, False, True, True, False, True, True, False)), (String
            ((Ascii (True, True, True, True, False, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), (String ((Ascii (True, True, True, False, False, True,
            True, False)), (String ((Ascii (True, False, False, True, False,
            True, False, False)),
            EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
   | False ->
     let t1 = compile_switch Int.modulus dfl cases in
     (match validate_switch Int.modulus dfl cases t1 with
      | True ->
        OK (Sswitch2 (XElet ((sel_expr hf e), (sel_switch_int O t1))))
      | False ->
        Error
          (msg (String ((Ascii (True, True, False, False, True, False, True,
            False)), (String ((Ascii (True, False, True, False, False, True,
            True, False)), (String ((Ascii (False, False, True, True, False,
            True, True, False)), (String ((Ascii (True, False, True, False,
            False, True, True, False)), (String ((Ascii (True, True, False,
            False, False, True, True, False)), (String ((Ascii (False, False,
            True, False, True, True, True, False)), (String ((Ascii (True,
            False, False, True, False, True, True, False)), (String ((Ascii
            (True, True, True, True, False, True, True, False)), (String
            ((Ascii (False, True, True, True, False, True, True, False)),
            (String ((Ascii (False, True, False, True, True, True, False,
            False)), (String ((Ascii (False, False, False, False, False,
            True, False, False)), (String ((Ascii (False, True, False, False,
            False, True, True, False)), (String ((Ascii (True, False, False,
            False, False, True, True, False)), (String ((Ascii (False, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, False, False, False, True, False, False)), (String ((Ascii
            (True, True, False, False, True, True, True, False)), (String
            ((Ascii (True, True, True, False, True, True, True, False)),
            (String ((Ascii (True, False, False, True, False, True, True,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (True, True, False, False, False,
            True, True, False)), (String ((Ascii (False, False, False, True,
            False, True, True, False)), (String ((Ascii (False, False, False,
            False, False, True, False, False)), (String ((Ascii (False,
            False, False, True, False, True, False, False)), (String ((Ascii
            (True, False, False, True, False, True, True, False)), (String
            ((Ascii (False, True, True, True, False, True, True, False)),
            (String ((Ascii (False, False, True, False, True, True, True,
            False)), (String ((Ascii (True, False, False, True, False, True,
            False, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
| Sreturn0 o ->
  (match o with
   | Some e -> OK (Sreturn2 (Some (sel_expr hf e)))
   | None -> OK (Sreturn2 None))
| Slabel0 (lbl, body) ->
  bind (sel_stmt hf ge body) (fun body' -> OK (Slabel2 (lbl, body')))
| Sgoto0 lbl -> OK (Sgoto2 lbl)

(** val sel_function :
    helper_functions -> genv -> function1 -> function3 res **)

let sel_function hf ge f =
  bind (sel_stmt hf ge f.fn_body0) (fun body' -> OK { fn_sig1 = f.fn_sig;
    fn_params2 = f.fn_params0; fn_vars2 = f.fn_vars0; fn_stackspace0 =
    f.fn_stackspace; fn_body2 = body' })

(** val sel_fundef : helper_functions -> genv -> fundef1 -> fundef3 res **)

let sel_fundef hf ge f =
  transf_partial_fundef (sel_function hf ge) f

type globdef0 = (fundef1, unit0) globdef

(** val globdef_of_interest : globdef0 -> bool **)

let globdef_of_interest = function
| Gfun f ->
  (match f with
   | Internal f0 -> False
   | External e ->
     (match e with
      | EF_external (name, sg) ->
        prefix (String ((Ascii (True, True, True, True, True, False, True,
          False)), (String ((Ascii (True, True, True, True, True, False,
          True, False)), (String ((Ascii (True, False, False, True, False,
          True, True, False)), (String ((Ascii (False, True, True, False,
          True, True, False, False)), (String ((Ascii (False, False, True,
          False, True, True, False, False)), (String ((Ascii (True, True,
          True, True, True, False, True, False)), EmptyString))))))))))))
          name
      | _ -> False))
| Gvar v -> False

(** val record_globdef :
    globdef0 PTree.t -> (ident, globdef0) prod -> globdef0 PTree.t **)

let record_globdef globs = function
| Pair (id, gd) ->
  (match globdef_of_interest gd with
   | True -> PTree.set id gd globs
   | False -> PTree.remove id globs)

(** val record_globdefs : program1 -> globdef0 PTree.t **)

let record_globdefs p =
  fold_left record_globdef p.prog_defs PTree.empty

(** val lookup_helper_aux :
    string -> signature -> ident option -> ident -> globdef0 -> ident option **)

let lookup_helper_aux name sg res2 id = function
| Gfun f ->
  (match f with
   | Internal f0 -> res2
   | External e ->
     (match e with
      | EF_external (name', sg') ->
        (match match proj_sumbool (string_dec name name') with
               | True -> proj_sumbool (signature_eq sg sg')
               | False -> False with
         | True -> Some id
         | False -> res2)
      | _ -> res2))
| Gvar v -> res2

(** val lookup_helper :
    globdef0 PTree.t -> string -> signature -> ident res **)

let lookup_helper globs name sg =
  match PTree.fold (lookup_helper_aux name sg) globs None with
  | Some id -> OK id
  | None ->
    Error (Cons ((MSG name), (Cons ((MSG (String ((Ascii (False, True, False,
      True, True, True, False, False)), (String ((Ascii (False, False, False,
      False, False, True, False, False)), (String ((Ascii (True, False, True,
      True, False, True, True, False)), (String ((Ascii (True, False, False,
      True, False, True, True, False)), (String ((Ascii (True, True, False,
      False, True, True, True, False)), (String ((Ascii (True, True, False,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      True, False, True, True, False)), (String ((Ascii (False, True, True,
      True, False, True, True, False)), (String ((Ascii (True, True, True,
      False, False, True, True, False)), (String ((Ascii (False, False,
      False, False, False, True, False, False)), (String ((Ascii (True, True,
      True, True, False, True, True, False)), (String ((Ascii (False, True,
      False, False, True, True, True, False)), (String ((Ascii (False, False,
      False, False, False, True, False, False)), (String ((Ascii (True,
      False, False, True, False, True, True, False)), (String ((Ascii (False,
      True, True, True, False, True, True, False)), (String ((Ascii (True,
      True, False, False, False, True, True, False)), (String ((Ascii (True,
      True, True, True, False, True, True, False)), (String ((Ascii (False,
      True, False, False, True, True, True, False)), (String ((Ascii (False,
      True, False, False, True, True, True, False)), (String ((Ascii (True,
      False, True, False, False, True, True, False)), (String ((Ascii (True,
      True, False, False, False, True, True, False)), (String ((Ascii (False,
      False, True, False, True, True, True, False)), (String ((Ascii (False,
      False, False, False, False, True, False, False)), (String ((Ascii
      (False, False, True, False, False, True, True, False)), (String ((Ascii
      (True, False, True, False, False, True, True, False)), (String ((Ascii
      (True, True, False, False, False, True, True, False)), (String ((Ascii
      (False, False, True, True, False, True, True, False)), (String ((Ascii
      (True, False, False, False, False, True, True, False)), (String ((Ascii
      (False, True, False, False, True, True, True, False)), (String ((Ascii
      (True, False, False, False, False, True, True, False)), (String ((Ascii
      (False, False, True, False, True, True, True, False)), (String ((Ascii
      (True, False, False, True, False, True, True, False)), (String ((Ascii
      (True, True, True, True, False, True, True, False)), (String ((Ascii
      (False, True, True, True, False, True, True, False)),
      EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))),
      Nil))))

(** val get_helpers : program1 -> helper_functions res **)

let get_helpers p =
  let globs = record_globdefs p in
  bind
    (lookup_helper globs (String ((Ascii (True, True, True, True, True,
      False, True, False)), (String ((Ascii (True, True, True, True, True,
      False, True, False)), (String ((Ascii (True, False, False, True, False,
      True, True, False)), (String ((Ascii (False, True, True, False, True,
      True, False, False)), (String ((Ascii (False, False, True, False, True,
      True, False, False)), (String ((Ascii (True, True, True, True, True,
      False, True, False)), (String ((Ascii (False, False, True, False,
      False, True, True, False)), (String ((Ascii (False, False, True, False,
      True, True, True, False)), (String ((Ascii (True, True, True, True,
      False, True, True, False)), (String ((Ascii (True, True, False, False,
      True, True, True, False)), EmptyString)))))))))))))))))))) sig_f_l)
    (fun i64_dtos0 ->
    bind
      (lookup_helper globs (String ((Ascii (True, True, True, True, True,
        False, True, False)), (String ((Ascii (True, True, True, True, True,
        False, True, False)), (String ((Ascii (True, False, False, True,
        False, True, True, False)), (String ((Ascii (False, True, True,
        False, True, True, False, False)), (String ((Ascii (False, False,
        True, False, True, True, False, False)), (String ((Ascii (True, True,
        True, True, True, False, True, False)), (String ((Ascii (False,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, False, True, False, True, True, True, False)), (String
        ((Ascii (True, True, True, True, False, True, True, False)), (String
        ((Ascii (True, False, True, False, True, True, True, False)),
        EmptyString)))))))))))))))))))) sig_f_l) (fun i64_dtou0 ->
      bind
        (lookup_helper globs (String ((Ascii (True, True, True, True, True,
          False, True, False)), (String ((Ascii (True, True, True, True,
          True, False, True, False)), (String ((Ascii (True, False, False,
          True, False, True, True, False)), (String ((Ascii (False, True,
          True, False, True, True, False, False)), (String ((Ascii (False,
          False, True, False, True, True, False, False)), (String ((Ascii
          (True, True, True, True, True, False, True, False)), (String
          ((Ascii (True, True, False, False, True, True, True, False)),
          (String ((Ascii (False, False, True, False, True, True, True,
          False)), (String ((Ascii (True, True, True, True, False, True,
          True, False)), (String ((Ascii (False, False, True, False, False,
          True, True, False)), EmptyString)))))))))))))))))))) sig_l_f)
        (fun i64_stod0 ->
        bind
          (lookup_helper globs (String ((Ascii (True, True, True, True, True,
            False, True, False)), (String ((Ascii (True, True, True, True,
            True, False, True, False)), (String ((Ascii (True, False, False,
            True, False, True, True, False)), (String ((Ascii (False, True,
            True, False, True, True, False, False)), (String ((Ascii (False,
            False, True, False, True, True, False, False)), (String ((Ascii
            (True, True, True, True, True, False, True, False)), (String
            ((Ascii (True, False, True, False, True, True, True, False)),
            (String ((Ascii (False, False, True, False, True, True, True,
            False)), (String ((Ascii (True, True, True, True, False, True,
            True, False)), (String ((Ascii (False, False, True, False, False,
            True, True, False)), EmptyString)))))))))))))))))))) sig_l_f)
          (fun i64_utod0 ->
          bind
            (lookup_helper globs (String ((Ascii (True, True, True, True,
              True, False, True, False)), (String ((Ascii (True, True, True,
              True, True, False, True, False)), (String ((Ascii (True, False,
              False, True, False, True, True, False)), (String ((Ascii
              (False, True, True, False, True, True, False, False)), (String
              ((Ascii (False, False, True, False, True, True, False, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (False, False, True, False,
              True, True, True, False)), (String ((Ascii (True, True, True,
              True, False, True, True, False)), (String ((Ascii (False, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))) sig_l_s) (fun i64_stof0 ->
            bind
              (lookup_helper globs (String ((Ascii (True, True, True, True,
                True, False, True, False)), (String ((Ascii (True, True,
                True, True, True, False, True, False)), (String ((Ascii
                (True, False, False, True, False, True, True, False)),
                (String ((Ascii (False, True, True, False, True, True, False,
                False)), (String ((Ascii (False, False, True, False, True,
                True, False, False)), (String ((Ascii (True, True, True,
                True, True, False, True, False)), (String ((Ascii (True,
                False, True, False, True, True, True, False)), (String
                ((Ascii (False, False, True, False, True, True, True,
                False)), (String ((Ascii (True, True, True, True, False,
                True, True, False)), (String ((Ascii (False, True, True,
                False, False, True, True, False)),
                EmptyString)))))))))))))))))))) sig_l_s) (fun i64_utof0 ->
              bind
                (lookup_helper globs (String ((Ascii (True, True, True, True,
                  True, False, True, False)), (String ((Ascii (True, True,
                  True, True, True, False, True, False)), (String ((Ascii
                  (True, False, False, True, False, True, True, False)),
                  (String ((Ascii (False, True, True, False, True, True,
                  False, False)), (String ((Ascii (False, False, True, False,
                  True, True, False, False)), (String ((Ascii (True, True,
                  True, True, True, False, True, False)), (String ((Ascii
                  (True, True, False, False, True, True, True, False)),
                  (String ((Ascii (False, False, True, False, False, True,
                  True, False)), (String ((Ascii (True, False, False, True,
                  False, True, True, False)), (String ((Ascii (False, True,
                  True, False, True, True, True, False)),
                  EmptyString)))))))))))))))))))) sig_ll_l) (fun i64_sdiv0 ->
                bind
                  (lookup_helper globs (String ((Ascii (True, True, True,
                    True, True, False, True, False)), (String ((Ascii (True,
                    True, True, True, True, False, True, False)), (String
                    ((Ascii (True, False, False, True, False, True, True,
                    False)), (String ((Ascii (False, True, True, False, True,
                    True, False, False)), (String ((Ascii (False, False,
                    True, False, True, True, False, False)), (String ((Ascii
                    (True, True, True, True, True, False, True, False)),
                    (String ((Ascii (True, False, True, False, True, True,
                    True, False)), (String ((Ascii (False, False, True,
                    False, False, True, True, False)), (String ((Ascii (True,
                    False, False, True, False, True, True, False)), (String
                    ((Ascii (False, True, True, False, True, True, True,
                    False)), EmptyString)))))))))))))))))))) sig_ll_l)
                  (fun i64_udiv0 ->
                  bind
                    (lookup_helper globs (String ((Ascii (True, True, True,
                      True, True, False, True, False)), (String ((Ascii
                      (True, True, True, True, True, False, True, False)),
                      (String ((Ascii (True, False, False, True, False, True,
                      True, False)), (String ((Ascii (False, True, True,
                      False, True, True, False, False)), (String ((Ascii
                      (False, False, True, False, True, True, False, False)),
                      (String ((Ascii (True, True, True, True, True, False,
                      True, False)), (String ((Ascii (True, True, False,
                      False, True, True, True, False)), (String ((Ascii
                      (True, False, True, True, False, True, True, False)),
                      (String ((Ascii (True, True, True, True, False, True,
                      True, False)), (String ((Ascii (False, False, True,
                      False, False, True, True, False)),
                      EmptyString)))))))))))))))))))) sig_ll_l)
                    (fun i64_smod0 ->
                    bind
                      (lookup_helper globs (String ((Ascii (True, True, True,
                        True, True, False, True, False)), (String ((Ascii
                        (True, True, True, True, True, False, True, False)),
                        (String ((Ascii (True, False, False, True, False,
                        True, True, False)), (String ((Ascii (False, True,
                        True, False, True, True, False, False)), (String
                        ((Ascii (False, False, True, False, True, True,
                        False, False)), (String ((Ascii (True, True, True,
                        True, True, False, True, False)), (String ((Ascii
                        (True, False, True, False, True, True, True, False)),
                        (String ((Ascii (True, False, True, True, False,
                        True, True, False)), (String ((Ascii (True, True,
                        True, True, False, True, True, False)), (String
                        ((Ascii (False, False, True, False, False, True,
                        True, False)), EmptyString))))))))))))))))))))
                        sig_ll_l) (fun i64_umod0 ->
                      bind
                        (lookup_helper globs (String ((Ascii (True, True,
                          True, True, True, False, True, False)), (String
                          ((Ascii (True, True, True, True, True, False, True,
                          False)), (String ((Ascii (True, False, False, True,
                          False, True, True, False)), (String ((Ascii (False,
                          True, True, False, True, True, False, False)),
                          (String ((Ascii (False, False, True, False, True,
                          True, False, False)), (String ((Ascii (True, True,
                          True, True, True, False, True, False)), (String
                          ((Ascii (True, True, False, False, True, True,
                          True, False)), (String ((Ascii (False, False,
                          False, True, False, True, True, False)), (String
                          ((Ascii (False, False, True, True, False, True,
                          True, False)), EmptyString))))))))))))))))))
                          sig_li_l) (fun i64_shl0 ->
                        bind
                          (lookup_helper globs (String ((Ascii (True, True,
                            True, True, True, False, True, False)), (String
                            ((Ascii (True, True, True, True, True, False,
                            True, False)), (String ((Ascii (True, False,
                            False, True, False, True, True, False)), (String
                            ((Ascii (False, True, True, False, True, True,
                            False, False)), (String ((Ascii (False, False,
                            True, False, True, True, False, False)), (String
                            ((Ascii (True, True, True, True, True, False,
                            True, False)), (String ((Ascii (True, True,
                            False, False, True, True, True, False)), (String
                            ((Ascii (False, False, False, True, False, True,
                            True, False)), (String ((Ascii (False, True,
                            False, False, True, True, True, False)),
                            EmptyString)))))))))))))))))) sig_li_l)
                          (fun i64_shr0 ->
                          bind
                            (lookup_helper globs (String ((Ascii (True, True,
                              True, True, True, False, True, False)), (String
                              ((Ascii (True, True, True, True, True, False,
                              True, False)), (String ((Ascii (True, False,
                              False, True, False, True, True, False)),
                              (String ((Ascii (False, True, True, False,
                              True, True, False, False)), (String ((Ascii
                              (False, False, True, False, True, True, False,
                              False)), (String ((Ascii (True, True, True,
                              True, True, False, True, False)), (String
                              ((Ascii (True, True, False, False, True, True,
                              True, False)), (String ((Ascii (True, False,
                              False, False, False, True, True, False)),
                              (String ((Ascii (False, True, False, False,
                              True, True, True, False)),
                              EmptyString)))))))))))))))))) sig_li_l)
                            (fun i64_sar0 -> OK { i64_dtos = i64_dtos0;
                            i64_dtou = i64_dtou0; i64_stod = i64_stod0;
                            i64_utod = i64_utod0; i64_stof = i64_stof0;
                            i64_utof = i64_utof0; i64_sdiv = i64_sdiv0;
                            i64_udiv = i64_udiv0; i64_smod = i64_smod0;
                            i64_umod = i64_umod0; i64_shl = i64_shl0;
                            i64_shr = i64_shr0; i64_sar = i64_sar0 })))))))))))))

(** val sel_program : program1 -> program3 res **)

let sel_program p =
  bind (get_helpers p) (fun hf ->
    transform_partial_program (sel_fundef hf (Genv.globalenv p)) p)

type mapping = { map_vars : reg PTree.t; map_letvars : reg list }

(** val map_vars : mapping -> reg PTree.t **)

let map_vars x = x.map_vars

(** val map_letvars : mapping -> reg list **)

let map_letvars x = x.map_letvars

type state = { st_nextreg : positive; st_nextnode : positive; st_code : code }

(** val st_nextreg : state -> positive **)

let st_nextreg x = x.st_nextreg

(** val st_nextnode : state -> positive **)

let st_nextnode x = x.st_nextnode

(** val st_code : state -> code **)

let st_code x = x.st_code

type 'a res0 =
| Error0 of errmsg
| OK0 of 'a * state

type 'a mon = state -> 'a res0

(** val ret : 'a1 -> 'a1 mon **)

let ret x s =
  OK0 (x, s)

(** val error0 : errmsg -> 'a1 mon **)

let error0 msg0 s =
  Error0 msg0

(** val bind0 : 'a1 mon -> ('a1 -> 'a2 mon) -> 'a2 mon **)

let bind0 f g s =
  match f s with
  | Error0 msg0 -> Error0 msg0
  | OK0 (a, s') -> g a s'

(** val bind1 : ('a1, 'a2) prod mon -> ('a1 -> 'a2 -> 'a3 mon) -> 'a3 mon **)

let bind1 f g =
  bind0 f (fun xy -> g (fst xy) (snd xy))

(** val handle_error : 'a1 mon -> 'a1 mon -> 'a1 mon **)

let handle_error f g s =
  match f s with
  | Error0 e -> g s
  | OK0 (a, s') -> OK0 (a, s')

(** val init_state : state **)

let init_state =
  { st_nextreg = XH; st_nextnode = XH; st_code = PTree.empty }

(** val add_instr : instruction -> node mon **)

let add_instr i s =
  let n0 = s.st_nextnode in
  OK0 (n0, { st_nextreg = s.st_nextreg; st_nextnode = (Coq_Pos.succ n0);
  st_code = (PTree.set n0 i s.st_code) })

(** val reserve_instr : node mon **)

let reserve_instr s =
  let n0 = s.st_nextnode in
  OK0 (n0, { st_nextreg = s.st_nextreg; st_nextnode = (Coq_Pos.succ n0);
  st_code = s.st_code })

(** val check_empty_node : state -> node -> sumbool **)

let check_empty_node s n0 =
  match PTree.get n0 s.st_code with
  | Some i -> Right
  | None -> Left

(** val update_instr : node -> instruction -> unit0 mon **)

let update_instr n0 i s =
  match plt n0 s.st_nextnode with
  | Left ->
    (match check_empty_node s n0 with
     | Left ->
       OK0 (Tt, { st_nextreg = s.st_nextreg; st_nextnode = s.st_nextnode;
         st_code = (PTree.set n0 i s.st_code) })
     | Right ->
       Error0
         (msg (String ((Ascii (False, True, False, False, True, False, True,
           False)), (String ((Ascii (False, False, True, False, True, False,
           True, False)), (String ((Ascii (False, False, True, True, False,
           False, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, False, True, False, True, True, True, False)), (String
           ((Ascii (False, False, False, False, True, True, True, False)),
           (String ((Ascii (False, False, True, False, False, True, True,
           False)), (String ((Ascii (True, False, False, False, False, True,
           True, False)), (String ((Ascii (False, False, True, False, True,
           True, True, False)), (String ((Ascii (True, False, True, False,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, True, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (False, True, False, False, True, True, True,
           False)), EmptyString))))))))))))))))))))))))))))))))))))))))
  | Right ->
    Error0
      (msg (String ((Ascii (False, True, False, False, True, False, True,
        False)), (String ((Ascii (False, False, True, False, True, False,
        True, False)), (String ((Ascii (False, False, True, True, False,
        False, True, False)), (String ((Ascii (True, True, True, False,
        False, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (False, True,
        True, True, False, True, True, False)), (String ((Ascii (False, True,
        True, True, False, True, False, False)), (String ((Ascii (True,
        False, True, False, True, True, True, False)), (String ((Ascii
        (False, False, False, False, True, True, True, False)), (String
        ((Ascii (False, False, True, False, False, True, True, False)),
        (String ((Ascii (True, False, False, False, False, True, True,
        False)), (String ((Ascii (False, False, True, False, True, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (True, True, True, True, True,
        False, True, False)), (String ((Ascii (True, False, False, True,
        False, True, True, False)), (String ((Ascii (False, True, True, True,
        False, True, True, False)), (String ((Ascii (True, True, False,
        False, True, True, True, False)), (String ((Ascii (False, False,
        True, False, True, True, True, False)), (String ((Ascii (False, True,
        False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))

(** val new_reg : reg mon **)

let new_reg s =
  OK0 (s.st_nextreg, { st_nextreg = (Coq_Pos.succ s.st_nextreg);
    st_nextnode = s.st_nextnode; st_code = s.st_code })

(** val init_mapping : mapping **)

let init_mapping =
  { map_vars = PTree.empty; map_letvars = Nil }

(** val add_var : mapping -> ident -> (reg, mapping) prod mon **)

let add_var map2 name =
  bind0 new_reg (fun r ->
    ret (Pair (r, { map_vars = (PTree.set name r map2.map_vars);
      map_letvars = map2.map_letvars })))

(** val add_vars : mapping -> ident list -> (reg list, mapping) prod mon **)

let rec add_vars map2 = function
| Nil -> ret (Pair (Nil, map2))
| Cons (n1, nl) ->
  bind1 (add_vars map2 nl) (fun rl map3 ->
    bind1 (add_var map3 n1) (fun r1 map4 ->
      ret (Pair ((Cons (r1, rl)), map4))))

(** val find_var : mapping -> ident -> reg mon **)

let find_var map2 name =
  match PTree.get name map2.map_vars with
  | Some r -> ret r
  | None ->
    error0 (Cons ((MSG (String ((Ascii (False, True, False, False, True,
      False, True, False)), (String ((Ascii (False, False, True, False, True,
      False, True, False)), (String ((Ascii (False, False, True, True, False,
      False, True, False)), (String ((Ascii (True, True, True, False, False,
      True, True, False)), (String ((Ascii (True, False, True, False, False,
      True, True, False)), (String ((Ascii (False, True, True, True, False,
      True, True, False)), (String ((Ascii (False, True, False, True, True,
      True, False, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), (String ((Ascii (True, False, True, False,
      True, True, True, False)), (String ((Ascii (False, True, True, True,
      False, True, True, False)), (String ((Ascii (False, True, False, False,
      False, True, True, False)), (String ((Ascii (True, True, True, True,
      False, True, True, False)), (String ((Ascii (True, False, True, False,
      True, True, True, False)), (String ((Ascii (False, True, True, True,
      False, True, True, False)), (String ((Ascii (False, False, True, False,
      False, True, True, False)), (String ((Ascii (False, False, False,
      False, False, True, False, False)), (String ((Ascii (False, True, True,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      False, False, True, True, False)), (String ((Ascii (False, True, False,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      True, False, True, True, False)), (String ((Ascii (True, False, False,
      False, False, True, True, False)), (String ((Ascii (False, True, False,
      False, False, True, True, False)), (String ((Ascii (False, False, True,
      True, False, True, True, False)), (String ((Ascii (True, False, True,
      False, False, True, True, False)), (String ((Ascii (False, False,
      False, False, False, True, False, False)),
      EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))), (Cons
      ((CTX name), Nil))))

(** val add_letvar : mapping -> reg -> mapping **)

let add_letvar map2 r =
  { map_vars = map2.map_vars; map_letvars = (Cons (r, map2.map_letvars)) }

(** val find_letvar : mapping -> nat -> reg mon **)

let find_letvar map2 idx =
  match nth_error map2.map_letvars idx with
  | Some r -> ret r
  | None ->
    error0
      (msg (String ((Ascii (False, True, False, False, True, False, True,
        False)), (String ((Ascii (False, False, True, False, True, False,
        True, False)), (String ((Ascii (False, False, True, True, False,
        False, True, False)), (String ((Ascii (True, True, True, False,
        False, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (False, True,
        True, True, False, True, True, False)), (String ((Ascii (False, True,
        False, True, True, True, False, False)), (String ((Ascii (False,
        False, False, False, False, True, False, False)), (String ((Ascii
        (True, False, True, False, True, True, True, False)), (String ((Ascii
        (False, True, True, True, False, True, True, False)), (String ((Ascii
        (False, True, False, False, False, True, True, False)), (String
        ((Ascii (True, True, True, True, False, True, True, False)), (String
        ((Ascii (True, False, True, False, True, True, True, False)), (String
        ((Ascii (False, True, True, True, False, True, True, False)), (String
        ((Ascii (False, False, True, False, False, True, True, False)),
        (String ((Ascii (False, False, False, False, False, True, False,
        False)), (String ((Ascii (False, False, True, True, False, True,
        True, False)), (String ((Ascii (True, False, True, False, False,
        True, True, False)), (String ((Ascii (False, False, True, False,
        True, True, True, False)), (String ((Ascii (False, False, False,
        False, False, True, False, False)), (String ((Ascii (False, True,
        True, False, True, True, True, False)), (String ((Ascii (True, False,
        False, False, False, True, True, False)), (String ((Ascii (False,
        True, False, False, True, True, True, False)), (String ((Ascii (True,
        False, False, True, False, True, True, False)), (String ((Ascii
        (True, False, False, False, False, True, True, False)), (String
        ((Ascii (False, True, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, True, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val alloc_reg : mapping -> expr2 -> reg mon **)

let alloc_reg map2 = function
| Evar2 id -> find_var map2 id
| Eletvar n0 -> find_letvar map2 n0
| _ -> new_reg

(** val alloc_regs : mapping -> exprlist -> reg list mon **)

let rec alloc_regs map2 = function
| Enil -> ret Nil
| Econs (a, bl) ->
  bind0 (alloc_reg map2 a) (fun r ->
    bind0 (alloc_regs map2 bl) (fun rl -> ret (Cons (r, rl))))

(** val alloc_optreg : mapping -> ident option -> reg mon **)

let alloc_optreg map2 = function
| Some id -> find_var map2 id
| None -> new_reg

(** val add_move : reg -> reg -> node -> node mon **)

let add_move rs rd nd =
  match Reg.eq rs rd with
  | Left -> ret nd
  | Right -> add_instr (Iop (Omove, (Cons (rs, Nil)), rd, nd))

(** val exprlist_of_expr_list : expr2 list -> exprlist **)

let exprlist_of_expr_list l =
  fold_right (fun x x0 -> Econs (x, x0)) Enil l

(** val convert_builtin_arg :
    expr2 builtin_arg -> 'a1 list -> ('a1 builtin_arg, 'a1 list) prod **)

let rec convert_builtin_arg a rl =
  match a with
  | BA a0 ->
    (match rl with
     | Nil -> Pair ((BA_int Int.zero), Nil)
     | Cons (r, rs) -> Pair ((BA r), rs))
  | BA_int n0 -> Pair ((BA_int n0), rl)
  | BA_long n0 -> Pair ((BA_long n0), rl)
  | BA_float n0 -> Pair ((BA_float n0), rl)
  | BA_single n0 -> Pair ((BA_single n0), rl)
  | BA_loadstack (chunk, ofs) -> Pair ((BA_loadstack (chunk, ofs)), rl)
  | BA_addrstack ofs -> Pair ((BA_addrstack ofs), rl)
  | BA_loadglobal (chunk, id, ofs) ->
    Pair ((BA_loadglobal (chunk, id, ofs)), rl)
  | BA_addrglobal (id, ofs) -> Pair ((BA_addrglobal (id, ofs)), rl)
  | BA_splitlong (hi, lo) ->
    let Pair (hi', rl1) = convert_builtin_arg hi rl in
    let Pair (lo', rl2) = convert_builtin_arg lo rl1 in
    Pair ((BA_splitlong (hi', lo')), rl2)

(** val convert_builtin_args :
    expr2 builtin_arg list -> 'a1 list -> 'a1 builtin_arg list **)

let rec convert_builtin_args al rl =
  match al with
  | Nil -> Nil
  | Cons (a1, al0) ->
    let Pair (a1', rl1) = convert_builtin_arg a1 rl in
    Cons (a1', (convert_builtin_args al0 rl1))

(** val convert_builtin_res :
    mapping -> typ option -> ident builtin_res -> reg builtin_res mon **)

let convert_builtin_res map2 oty = function
| BR id -> bind0 (find_var map2 id) (fun r0 -> ret (BR r0))
| BR_none ->
  (match oty with
   | Some t1 -> bind0 new_reg (fun r0 -> ret (BR r0))
   | None -> ret BR_none)
| BR_splitlong (hi, lo) ->
  error0
    (msg (String ((Ascii (False, True, False, False, True, False, True,
      False)), (String ((Ascii (False, False, True, False, True, False, True,
      False)), (String ((Ascii (False, False, True, True, False, False, True,
      False)), (String ((Ascii (True, True, True, False, False, True, True,
      False)), (String ((Ascii (True, False, True, False, False, True, True,
      False)), (String ((Ascii (False, True, True, True, False, True, True,
      False)), (String ((Ascii (False, True, False, True, True, True, False,
      False)), (String ((Ascii (False, False, False, False, False, True,
      False, False)), (String ((Ascii (False, True, False, False, False,
      True, True, False)), (String ((Ascii (True, False, False, False, False,
      True, True, False)), (String ((Ascii (False, False, True, False, False,
      True, True, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), (String ((Ascii (False, True, False,
      False, False, True, True, False)), (String ((Ascii (True, False, True,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      True, False, True, True, False)), (String ((Ascii (False, False, True,
      True, False, True, True, False)), (String ((Ascii (False, False, True,
      False, True, True, True, False)), (String ((Ascii (True, False, False,
      True, False, True, True, False)), (String ((Ascii (False, True, True,
      True, False, True, True, False)), (String ((Ascii (True, True, True,
      True, True, False, True, False)), (String ((Ascii (False, True, False,
      False, True, True, True, False)), (String ((Ascii (True, False, True,
      False, False, True, True, False)), (String ((Ascii (True, True, False,
      False, True, True, True, False)),
      EmptyString)))))))))))))))))))))))))))))))))))))))))))))))

(** val transl_expr1 : mapping -> expr2 -> reg -> node -> node mon **)

let rec transl_expr1 map2 a rd nd =
  match a with
  | Evar2 v -> bind0 (find_var map2 v) (fun r -> add_move r rd nd)
  | Eop (op, al) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0 (add_instr (Iop (op, rl, rd, nd))) (fun no ->
        transl_exprlist0 map2 al rl no))
  | Eload1 (chunk, addr, al) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0 (add_instr (Iload (chunk, addr, rl, rd, nd))) (fun no ->
        transl_exprlist0 map2 al rl no))
  | Econdition (a0, b, c) ->
    bind0 (transl_expr1 map2 c rd nd) (fun nfalse ->
      bind0 (transl_expr1 map2 b rd nd) (fun ntrue ->
        transl_condexpr map2 a0 ntrue nfalse))
  | Elet (b, c) ->
    bind0 new_reg (fun r ->
      bind0 (transl_expr1 (add_letvar map2 r) c rd nd) (fun nc ->
        transl_expr1 map2 b r nc))
  | Eletvar n0 -> bind0 (find_letvar map2 n0) (fun r -> add_move r rd nd)
  | Ebuiltin (ef, al) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0
        (add_instr (Ibuiltin (ef, (map (fun x -> BA x) rl), (BR rd), nd)))
        (fun no -> transl_exprlist0 map2 al rl no))
  | Eexternal (id, sg, al) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0 (add_instr (Icall (sg, (Inr id), rl, rd, nd))) (fun no ->
        transl_exprlist0 map2 al rl no))

(** val transl_exprlist0 :
    mapping -> exprlist -> reg list -> node -> node mon **)

and transl_exprlist0 map2 al rl nd =
  match al with
  | Enil ->
    (match rl with
     | Nil -> ret nd
     | Cons (r, l) ->
       error0
         (msg (String ((Ascii (False, True, False, False, True, False, True,
           False)), (String ((Ascii (False, False, True, False, True, False,
           True, False)), (String ((Ascii (False, False, True, True, False,
           False, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           True, False, False, True, True, False)), (String ((Ascii (False,
           False, False, True, True, True, True, False)), (String ((Ascii
           (False, False, False, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (False, False, True, True, False, True, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, False,
           True, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))
  | Econs (b, bs) ->
    (match rl with
     | Nil ->
       error0
         (msg (String ((Ascii (False, True, False, False, True, False, True,
           False)), (String ((Ascii (False, False, True, False, True, False,
           True, False)), (String ((Ascii (False, False, True, True, False,
           False, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           True, False, False, True, True, False)), (String ((Ascii (False,
           False, False, True, True, True, True, False)), (String ((Ascii
           (False, False, False, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (False, False, True, True, False, True, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, False,
           True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))
     | Cons (r, rs) ->
       bind0 (transl_exprlist0 map2 bs rs nd) (fun no ->
         transl_expr1 map2 b r no))

(** val transl_condexpr : mapping -> condexpr -> node -> node -> node mon **)

and transl_condexpr map2 a ntrue nfalse =
  match a with
  | CEcond (c, al) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0 (add_instr (Icond (c, rl, ntrue, nfalse))) (fun nt ->
        transl_exprlist0 map2 al rl nt))
  | CEcondition (a0, b, c) ->
    bind0 (transl_condexpr map2 c ntrue nfalse) (fun nc ->
      bind0 (transl_condexpr map2 b ntrue nfalse) (fun nb ->
        transl_condexpr map2 a0 nb nc))
  | CElet (b, c) ->
    bind0 new_reg (fun r ->
      bind0 (transl_condexpr (add_letvar map2 r) c ntrue nfalse) (fun nc ->
        transl_expr1 map2 b r nc))

(** val transl_exit : node list -> nat -> node mon **)

let transl_exit nexits n0 =
  match nth_error nexits n0 with
  | Some ne -> ret ne
  | None ->
    error0
      (msg (String ((Ascii (False, True, False, False, True, False, True,
        False)), (String ((Ascii (False, False, True, False, True, False,
        True, False)), (String ((Ascii (False, False, True, True, False,
        False, True, False)), (String ((Ascii (True, True, True, False,
        False, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (False, True,
        True, True, False, True, True, False)), (String ((Ascii (False, True,
        False, True, True, True, False, False)), (String ((Ascii (False,
        False, False, False, False, True, False, False)), (String ((Ascii
        (True, True, True, False, True, True, True, False)), (String ((Ascii
        (False, True, False, False, True, True, True, False)), (String
        ((Ascii (True, True, True, True, False, True, True, False)), (String
        ((Ascii (False, True, True, True, False, True, True, False)), (String
        ((Ascii (True, True, True, False, False, True, True, False)), (String
        ((Ascii (False, False, False, False, False, True, False, False)),
        (String ((Ascii (True, False, True, False, False, True, True,
        False)), (String ((Ascii (False, False, False, True, True, True,
        True, False)), (String ((Ascii (True, False, False, True, False,
        True, True, False)), (String ((Ascii (False, False, True, False,
        True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))

(** val transl_jumptable : node list -> nat list -> node list mon **)

let rec transl_jumptable nexits = function
| Nil -> ret Nil
| Cons (t1, tl0) ->
  bind0 (transl_exit nexits t1) (fun n1 ->
    bind0 (transl_jumptable nexits tl0) (fun nl -> ret (Cons (n1, nl))))

(** val transl_exitexpr : mapping -> exitexpr -> node list -> node mon **)

let rec transl_exitexpr map2 a nexits =
  match a with
  | XEexit n0 -> transl_exit nexits n0
  | XEjumptable (a0, tbl) ->
    bind0 (alloc_reg map2 a0) (fun r ->
      bind0 (transl_jumptable nexits tbl) (fun tbl' ->
        bind0 (add_instr (Ijumptable (r, tbl'))) (fun n1 ->
          transl_expr1 map2 a0 r n1)))
  | XEcondition (a0, b, c) ->
    bind0 (transl_exitexpr map2 c nexits) (fun nc ->
      bind0 (transl_exitexpr map2 b nexits) (fun nb ->
        transl_condexpr map2 a0 nb nc))
  | XElet (a0, b) ->
    bind0 new_reg (fun r ->
      bind0 (transl_exitexpr (add_letvar map2 r) b nexits) (fun n1 ->
        transl_expr1 map2 a0 r n1))

(** val more_likely : condexpr -> stmt1 -> stmt1 -> bool **)

let more_likely =
  failwith "AXIOM TO BE REALIZED"

type labelmap = node PTree.t

(** val transl_stmt0 :
    mapping -> stmt1 -> node -> node list -> labelmap -> node -> reg option
    -> node mon **)

let rec transl_stmt0 map2 s nd nexits ngoto nret rret =
  match s with
  | Sskip2 -> ret nd
  | Sassign1 (v, b) ->
    bind0 (find_var map2 v) (fun r -> transl_expr1 map2 b r nd)
  | Sstore1 (chunk, addr, al, b) ->
    bind0 (alloc_regs map2 al) (fun rl ->
      bind0 (alloc_reg map2 b) (fun r ->
        bind0 (add_instr (Istore (chunk, addr, rl, r, nd))) (fun no ->
          bind0 (transl_expr1 map2 b r no) (fun ns ->
            transl_exprlist0 map2 al rl ns))))
  | Scall2 (optid, sig1, s0, cl) ->
    (match s0 with
     | Inl b ->
       bind0 (alloc_reg map2 b) (fun rf ->
         bind0 (alloc_regs map2 cl) (fun rargs ->
           bind0 (alloc_optreg map2 optid) (fun r ->
             bind0 (add_instr (Icall (sig1, (Inl rf), rargs, r, nd)))
               (fun n1 ->
               bind0 (transl_exprlist0 map2 cl rargs n1) (fun n2 ->
                 transl_expr1 map2 b rf n2)))))
     | Inr id ->
       bind0 (alloc_regs map2 cl) (fun rargs ->
         bind0 (alloc_optreg map2 optid) (fun r ->
           bind0 (add_instr (Icall (sig1, (Inr id), rargs, r, nd)))
             (fun n1 -> transl_exprlist0 map2 cl rargs n1))))
  | Stailcall0 (sig1, s0, cl) ->
    (match s0 with
     | Inl b ->
       bind0 (alloc_reg map2 b) (fun rf ->
         bind0 (alloc_regs map2 cl) (fun rargs ->
           bind0 (add_instr (Itailcall (sig1, (Inl rf), rargs))) (fun n1 ->
             bind0 (transl_exprlist0 map2 cl rargs n1) (fun n2 ->
               transl_expr1 map2 b rf n2))))
     | Inr id ->
       bind0 (alloc_regs map2 cl) (fun rargs ->
         bind0 (add_instr (Itailcall (sig1, (Inr id), rargs))) (fun n1 ->
           transl_exprlist0 map2 cl rargs n1)))
  | Sbuiltin2 (res2, ef, args) ->
    let al = exprlist_of_expr_list (params_of_builtin_args args) in
    bind0 (alloc_regs map2 al) (fun rargs ->
      let args' = convert_builtin_args args rargs in
      bind0 (convert_builtin_res map2 (ef_sig ef).sig_res res2) (fun res' ->
        bind0 (add_instr (Ibuiltin (ef, args', res', nd))) (fun n1 ->
          transl_exprlist0 map2 al rargs n1)))
  | Sseq1 (s1, s2) ->
    bind0 (transl_stmt0 map2 s2 nd nexits ngoto nret rret) (fun ns ->
      transl_stmt0 map2 s1 ns nexits ngoto nret rret)
  | Sifthenelse2 (c, strue, sfalse) ->
    (match more_likely c strue sfalse with
     | True ->
       bind0 (transl_stmt0 map2 sfalse nd nexits ngoto nret rret)
         (fun nfalse ->
         bind0 (transl_stmt0 map2 strue nd nexits ngoto nret rret)
           (fun ntrue -> transl_condexpr map2 c ntrue nfalse))
     | False ->
       bind0 (transl_stmt0 map2 strue nd nexits ngoto nret rret)
         (fun ntrue ->
         bind0 (transl_stmt0 map2 sfalse nd nexits ngoto nret rret)
           (fun nfalse -> transl_condexpr map2 c ntrue nfalse)))
  | Sloop2 sbody ->
    bind0 reserve_instr (fun n1 ->
      bind0 (transl_stmt0 map2 sbody n1 nexits ngoto nret rret) (fun n2 ->
        bind0 (update_instr n1 (Inop n2)) (fun xx -> add_instr (Inop n2))))
  | Sblock1 sbody ->
    transl_stmt0 map2 sbody nd (Cons (nd, nexits)) ngoto nret rret
  | Sexit1 n0 -> transl_exit nexits n0
  | Sswitch2 a -> transl_exitexpr map2 a nexits
  | Sreturn2 opt_a ->
    (match opt_a with
     | Some a ->
       (match rret with
        | Some r -> transl_expr1 map2 a r nret
        | None ->
          error0
            (msg (String ((Ascii (False, True, False, False, True, False,
              True, False)), (String ((Ascii (False, False, True, False,
              True, False, True, False)), (String ((Ascii (False, False,
              True, True, False, False, True, False)), (String ((Ascii (True,
              True, True, False, False, True, True, False)), (String ((Ascii
              (True, False, True, False, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, True, False)),
              (String ((Ascii (False, True, False, True, True, True, False,
              False)), (String ((Ascii (False, False, False, False, False,
              True, False, False)), (String ((Ascii (False, False, True,
              False, True, True, True, False)), (String ((Ascii (True, False,
              False, True, True, True, True, False)), (String ((Ascii (False,
              False, False, False, True, True, True, False)), (String ((Ascii
              (True, False, True, False, False, True, True, False)), (String
              ((Ascii (False, False, False, False, False, True, False,
              False)), (String ((Ascii (True, False, True, True, False, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (True, True, False,
              False, True, True, True, False)), (String ((Ascii (True, False,
              True, True, False, True, True, False)), (String ((Ascii (True,
              False, False, False, False, True, True, False)), (String
              ((Ascii (False, False, True, False, True, True, True, False)),
              (String ((Ascii (True, True, False, False, False, True, True,
              False)), (String ((Ascii (False, False, False, True, False,
              True, True, False)), (String ((Ascii (False, False, False,
              False, False, True, False, False)), (String ((Ascii (True,
              True, True, True, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, False, False, False, False, True, False,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, False,
              False, True, True, False)), (String ((Ascii (False, False,
              True, False, True, True, True, False)), (String ((Ascii (True,
              False, True, False, True, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, True, False)),
              EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
     | None -> ret nret)
  | Slabel2 (lbl, s') ->
    bind0 (transl_stmt0 map2 s' nd nexits ngoto nret rret) (fun ns ->
      match PTree.get lbl ngoto with
      | Some n0 ->
        bind0
          (handle_error (update_instr n0 (Inop ns))
            (error0 (Cons ((MSG (String ((Ascii (True, False, True, True,
              False, False, True, False)), (String ((Ascii (True, False,
              True, False, True, True, True, False)), (String ((Ascii (False,
              False, True, True, False, True, True, False)), (String ((Ascii
              (False, False, True, False, True, True, True, False)), (String
              ((Ascii (True, False, False, True, False, True, True, False)),
              (String ((Ascii (False, False, False, False, True, True, True,
              False)), (String ((Ascii (False, False, True, True, False,
              True, True, False)), (String ((Ascii (True, False, False, True,
              True, True, True, False)), (String ((Ascii (True, False, True,
              True, False, True, False, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (True, False, True, False, False, True, True, False)), (String
              ((Ascii (False, True, True, False, False, True, True, False)),
              (String ((Ascii (True, False, False, True, False, True, True,
              False)), (String ((Ascii (False, True, True, True, False, True,
              True, False)), (String ((Ascii (True, False, True, False,
              False, True, True, False)), (String ((Ascii (False, False,
              True, False, False, True, True, False)), (String ((Ascii
              (False, False, False, False, False, True, False, False)),
              (String ((Ascii (False, False, True, True, False, True, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, True, False,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, False, True, True, False, True, True, False)), (String
              ((Ascii (False, False, False, False, False, True, False,
              False)),
              EmptyString))))))))))))))))))))))))))))))))))))))))))))))),
              (Cons ((CTX lbl), Nil)))))) (fun xx -> ret ns)
      | None ->
        error0
          (msg (String ((Ascii (False, True, False, False, True, False, True,
            False)), (String ((Ascii (False, False, True, False, True, False,
            True, False)), (String ((Ascii (False, False, True, True, False,
            False, True, False)), (String ((Ascii (True, True, True, False,
            False, True, True, False)), (String ((Ascii (True, False, True,
            False, False, True, True, False)), (String ((Ascii (False, True,
            True, True, False, True, True, False)), (String ((Ascii (False,
            True, False, True, True, True, False, False)), (String ((Ascii
            (False, False, False, False, False, True, False, False)), (String
            ((Ascii (True, False, True, False, True, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), (String ((Ascii (False, True, False, False, False, True,
            True, False)), (String ((Ascii (True, True, True, True, False,
            True, True, False)), (String ((Ascii (True, False, True, False,
            True, True, True, False)), (String ((Ascii (False, True, True,
            True, False, True, True, False)), (String ((Ascii (False, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, False, False, False, True, False, False)), (String ((Ascii
            (False, False, True, True, False, True, True, False)), (String
            ((Ascii (True, False, False, False, False, True, True, False)),
            (String ((Ascii (False, True, False, False, False, True, True,
            False)), (String ((Ascii (True, False, True, False, False, True,
            True, False)), (String ((Ascii (False, False, True, True, False,
            True, True, False)),
            EmptyString))))))))))))))))))))))))))))))))))))))))))))
  | Sgoto2 lbl ->
    (match PTree.get lbl ngoto with
     | Some n0 -> ret n0
     | None ->
       error0 (Cons ((MSG (String ((Ascii (True, False, True, False, True,
         False, True, False)), (String ((Ascii (False, True, True, True,
         False, True, True, False)), (String ((Ascii (False, False, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, False, False, True, True, False)), (String ((Ascii
         (True, False, False, True, False, True, True, False)), (String
         ((Ascii (False, True, True, True, False, True, True, False)),
         (String ((Ascii (True, False, True, False, False, True, True,
         False)), (String ((Ascii (False, False, True, False, False, True,
         True, False)), (String ((Ascii (False, False, False, False, False,
         True, False, False)), (String ((Ascii (False, False, True, False,
         False, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (False, True,
         True, False, False, True, True, False)), (String ((Ascii (True,
         False, False, True, False, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, True, False)), (String
         ((Ascii (True, False, True, False, False, True, True, False)),
         (String ((Ascii (False, False, True, False, False, True, True,
         False)), (String ((Ascii (False, False, False, False, False, True,
         False, False)), (String ((Ascii (False, False, True, True, False,
         True, True, False)), (String ((Ascii (True, False, False, False,
         False, True, True, False)), (String ((Ascii (False, True, False,
         False, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         False, True, True, False, True, True, False)), (String ((Ascii
         (False, False, False, False, False, True, False, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))), (Cons
         ((CTX lbl), Nil)))))

(** val alloc_label :
    label0 -> (labelmap, state) prod -> (labelmap, state) prod **)

let alloc_label lbl = function
| Pair (map2, s) ->
  let n0 = s.st_nextnode in
  Pair ((PTree.set lbl n0 map2), { st_nextreg = s.st_nextreg; st_nextnode =
  (Coq_Pos.succ s.st_nextnode); st_code = s.st_code })

(** val reserve_labels :
    stmt1 -> (labelmap, state) prod -> (labelmap, state) prod **)

let rec reserve_labels s ms =
  match s with
  | Sseq1 (s1, s2) -> reserve_labels s1 (reserve_labels s2 ms)
  | Sifthenelse2 (c, s1, s2) -> reserve_labels s1 (reserve_labels s2 ms)
  | Sloop2 s1 -> reserve_labels s1 ms
  | Sblock1 s1 -> reserve_labels s1 ms
  | Slabel2 (lbl, s1) -> alloc_label lbl (reserve_labels s1 ms)
  | _ -> ms

(** val ret_reg : signature -> reg -> reg option **)

let ret_reg sig1 rd =
  match sig1.sig_res with
  | Some ty -> Some rd
  | None -> None

(** val transl_fun : function3 -> labelmap -> (node, reg list) prod mon **)

let transl_fun f ngoto =
  bind1 (add_vars init_mapping f.fn_params2) (fun rparams map2 ->
    bind1 (add_vars map2 f.fn_vars2) (fun rvars map3 ->
      bind0 new_reg (fun rret ->
        let orret = ret_reg f.fn_sig1 rret in
        bind0 (add_instr (Ireturn orret)) (fun nret ->
          bind0 (transl_stmt0 map3 f.fn_body2 nret Nil ngoto nret orret)
            (fun nentry -> ret (Pair (nentry, rparams)))))))

(** val transl_function1 : function3 -> function4 res **)

let transl_function1 f =
  let Pair (ngoto, s0) =
    reserve_labels f.fn_body2 (Pair (PTree.empty, init_state))
  in
  (match transl_fun f ngoto s0 with
   | Error0 msg0 -> Error msg0
   | OK0 (p, s) ->
     let Pair (nentry, rparams) = p in
     OK { fn_sig2 = f.fn_sig1; fn_params3 = rparams; fn_stacksize =
     f.fn_stackspace0; fn_code = s.st_code; fn_entrypoint = nentry })

(** val transl_fundef1 : function3 fundef -> function4 fundef res **)

let transl_fundef1 =
  transf_partial_fundef transl_function1

(** val transl_program1 : program3 -> program4 res **)

let transl_program1 p =
  transform_partial_program transl_fundef1 p

(** val is_return : nat -> function4 -> node -> reg -> bool **)

let rec is_return n0 f pc rret =
  match n0 with
  | O -> False
  | S n' ->
    (match PTree.get pc f.fn_code with
     | Some i ->
       (match i with
        | Inop s -> is_return n' f s rret
        | Iop (op, args, dst, s) ->
          (match is_move_operation op args with
           | Some src ->
             (match Reg.eq rret src with
              | Left -> is_return n' f s dst
              | Right -> False)
           | None -> False)
        | Ireturn o ->
          (match o with
           | Some r -> proj_sumbool (Reg.eq r rret)
           | None -> True)
        | _ -> False)
     | None -> False)

(** val niter : nat **)

let niter =
  S (S (S (S (S O))))

(** val transf_instr : function4 -> node -> instruction -> instruction **)

let transf_instr f pc instr = match instr with
| Icall (sig1, ros, args, res2, s) ->
  (match match match is_return niter f s res2 with
               | True -> tailcall_is_possible sig1
               | False -> False with
         | True -> proj_sumbool (opt_typ_eq sig1.sig_res f.fn_sig2.sig_res)
         | False -> False with
   | True -> Itailcall (sig1, ros, args)
   | False -> instr)
| _ -> instr

(** val transf_function1 : function4 -> function4 **)

let transf_function1 f =
  match zeq f.fn_stacksize Z0 with
  | Left -> transf_function (transf_instr f) f
  | Right -> f

(** val transf_fundef1 : fundef4 -> fundef4 **)

let transf_fundef1 fd =
  transf_fundef transf_function1 fd

(** val transf_program0 : program4 -> program4 **)

let transf_program0 p =
  transform_program transf_fundef1 p

(** val fix : ('a1 -> ('a1 -> __ -> 'a2) -> 'a2) -> 'a1 -> 'a2 **)

let rec fix f x =
  f x (fun y _ -> fix f y)

(** val fixm :
    ('a1 -> nat) -> ('a1 -> ('a1 -> __ -> 'a2) -> 'a2) -> 'a1 -> 'a2 **)

let rec fixm measure f x =
  f x (fun y _ -> fixm measure f y)

type funenv = function4 PTree.t

(** val size_fenv : funenv -> nat **)

let size_fenv fenv =
  PTree_Properties.cardinal fenv

(** val should_inline : ident -> function4 -> bool **)

let should_inline =
  failwith "AXIOM TO BE REALIZED"

(** val add_globdef :
    funenv -> (ident, (fundef4, unit0) globdef) prod -> funenv **)

let add_globdef fenv = function
| Pair (id, g) ->
  (match g with
   | Gfun f0 ->
     (match f0 with
      | Internal f ->
        (match should_inline id f with
         | True -> PTree.set id f fenv
         | False -> PTree.remove id fenv)
      | External e -> PTree.remove id fenv)
   | Gvar v -> PTree.remove id fenv)

(** val funenv_program : program4 -> funenv **)

let funenv_program p =
  fold_left add_globdef p.prog_defs PTree.empty

type state0 = { st_nextreg0 : positive; st_nextnode0 : positive;
                st_code0 : code; st_stksize : z }

(** val st_nextreg0 : state0 -> positive **)

let st_nextreg0 x = x.st_nextreg0

(** val st_nextnode0 : state0 -> positive **)

let st_nextnode0 x = x.st_nextnode0

(** val st_code0 : state0 -> code **)

let st_code0 x = x.st_code0

(** val st_stksize : state0 -> z **)

let st_stksize x = x.st_stksize

type 'a res1 =
| R0 of 'a * state0

type 'a mon0 = state0 -> 'a res1

(** val ret0 : 'a1 -> 'a1 mon0 **)

let ret0 x s =
  R0 (x, s)

(** val bind3 : 'a1 mon0 -> ('a1 -> 'a2 mon0) -> 'a2 mon0 **)

let bind3 x f s1 =
  let R0 (vx, s2) = x s1 in f vx s2

(** val initstate : state0 **)

let initstate =
  { st_nextreg0 = XH; st_nextnode0 = XH; st_code0 = PTree.empty; st_stksize =
    Z0 }

(** val set_instr : node -> instruction -> unit0 mon0 **)

let set_instr pc i s =
  R0 (Tt, { st_nextreg0 = s.st_nextreg0; st_nextnode0 = s.st_nextnode0;
    st_code0 = (PTree.set pc i s.st_code0); st_stksize = s.st_stksize })

(** val add_instr0 : instruction -> node mon0 **)

let add_instr0 i s =
  let pc = s.st_nextnode0 in
  R0 (pc, { st_nextreg0 = s.st_nextreg0; st_nextnode0 = (Coq_Pos.succ pc);
  st_code0 = (PTree.set pc i s.st_code0); st_stksize = s.st_stksize })

(** val reserve_nodes : positive -> positive mon0 **)

let reserve_nodes numnodes s =
  R0 (s.st_nextnode0, { st_nextreg0 = s.st_nextreg0; st_nextnode0 =
    (Coq_Pos.add s.st_nextnode0 numnodes); st_code0 = s.st_code0;
    st_stksize = s.st_stksize })

(** val reserve_regs : positive -> positive mon0 **)

let reserve_regs numregs s =
  R0 (s.st_nextreg0, { st_nextreg0 = (Coq_Pos.add s.st_nextreg0 numregs);
    st_nextnode0 = s.st_nextnode0; st_code0 = s.st_code0; st_stksize =
    s.st_stksize })

(** val request_stack : z -> unit0 mon0 **)

let request_stack sz s =
  R0 (Tt, { st_nextreg0 = s.st_nextreg0; st_nextnode0 = s.st_nextnode0;
    st_code0 = s.st_code0; st_stksize = (Z.max s.st_stksize sz) })

(** val ptree_mfold :
    (positive -> 'a1 -> unit0 mon0) -> 'a1 PTree.t -> unit0 mon0 **)

let ptree_mfold f t1 s =
  R0 (Tt, (PTree.fold (fun s1 k v -> let R0 (x, s2) = f k v s1 in s2) t1 s))

type context = { dpc : positive; dreg : positive; dstk : z; mreg0 : positive;
                 mstk : z; retinfo : (node, reg) prod option }

(** val dpc : context -> positive **)

let dpc x = x.dpc

(** val dreg : context -> positive **)

let dreg x = x.dreg

(** val dstk : context -> z **)

let dstk x = x.dstk

(** val mstk : context -> z **)

let mstk x = x.mstk

(** val retinfo : context -> (node, reg) prod option **)

let retinfo x = x.retinfo

(** val shiftpos : positive -> positive -> positive **)

let shiftpos p amount =
  Coq_Pos.pred (Coq_Pos.add p amount)

(** val spc : context -> node -> positive **)

let spc ctx pc =
  shiftpos pc ctx.dpc

(** val sreg : context -> reg -> positive **)

let sreg ctx r =
  shiftpos r ctx.dreg

(** val sregs : context -> reg list -> positive list **)

let sregs ctx rl =
  map (sreg ctx) rl

(** val sros : context -> (reg, ident) sum -> (positive, ident) sum **)

let sros ctx ros =
  sum_left_map (sreg ctx) ros

(** val sop : context -> operation -> operation **)

let sop ctx op =
  shift_stack_operation (Int.repr ctx.dstk) op

(** val saddr : context -> addressing -> addressing **)

let saddr ctx addr =
  shift_stack_addressing (Int.repr ctx.dstk) addr

(** val sbuiltinarg : context -> reg builtin_arg -> reg builtin_arg **)

let rec sbuiltinarg ctx a = match a with
| BA x -> BA (sreg ctx x)
| BA_loadstack (chunk, ofs) ->
  BA_loadstack (chunk, (Int.add ofs (Int.repr ctx.dstk)))
| BA_addrstack ofs -> BA_addrstack (Int.add ofs (Int.repr ctx.dstk))
| BA_splitlong (hi, lo) ->
  BA_splitlong ((sbuiltinarg ctx hi), (sbuiltinarg ctx lo))
| _ -> a

(** val sbuiltinres : context -> reg builtin_res -> reg builtin_res **)

let sbuiltinres ctx = function
| BR x -> BR (sreg ctx x)
| _ -> BR_none

(** val initcontext : positive -> positive -> positive -> z -> context **)

let initcontext dpc0 dreg0 nreg0 sz =
  { dpc = dpc0; dreg = dreg0; dstk = Z0; mreg0 = nreg0; mstk = (Z.max sz Z0);
    retinfo = None }

(** val min_alignment : z -> z **)

let min_alignment sz =
  match zle sz (Zpos XH) with
  | Left -> Zpos XH
  | Right ->
    (match zle sz (Zpos (XO XH)) with
     | Left -> Zpos (XO XH)
     | Right ->
       (match zle sz (Zpos (XO (XO XH))) with
        | Left -> Zpos (XO (XO XH))
        | Right -> Zpos (XO (XO (XO XH)))))

(** val callcontext :
    context -> positive -> positive -> positive -> z -> node -> reg ->
    context **)

let callcontext ctx dpc0 dreg0 nreg0 sz retpc retreg =
  { dpc = dpc0; dreg = dreg0; dstk =
    (align (Z.add ctx.dstk ctx.mstk) (min_alignment sz)); mreg0 = nreg0;
    mstk = (Z.max sz Z0); retinfo = (Some (Pair ((spc ctx retpc),
    (sreg ctx retreg)))) }

(** val tailcontext :
    context -> positive -> positive -> positive -> z -> context **)

let tailcontext ctx dpc0 dreg0 nreg0 sz =
  { dpc = dpc0; dreg = dreg0; dstk = (align ctx.dstk (min_alignment sz));
    mreg0 = nreg0; mstk = (Z.max sz Z0); retinfo = ctx.retinfo }

(** val add_moves : reg list -> reg list -> node -> node mon0 **)

let rec add_moves srcs dsts succ0 =
  match srcs with
  | Nil -> ret0 succ0
  | Cons (s1, sl) ->
    (match dsts with
     | Nil -> ret0 succ0
     | Cons (d1, dl) ->
       bind3 (add_instr0 (Iop (Omove, (Cons (s1, Nil)), d1, succ0)))
         (fun n0 -> add_moves sl dl n0))

type inline_decision =
| Cannot_inline
| Can_inline of ident * function4

(** val can_inline : funenv -> (reg, ident) sum -> inline_decision **)

let can_inline fenv = function
| Inl r -> Cannot_inline
| Inr id ->
  let filtered_var = PTree.get id fenv in
  (match filtered_var with
   | Some f -> Can_inline (id, f)
   | None -> Cannot_inline)

(** val inline_function :
    funenv -> (funenv -> __ -> context -> function4 -> unit0 mon0) -> context
    -> ident -> function4 -> reg list -> node -> reg -> node mon0 **)

let inline_function fenv rec0 ctx id f args retpc retreg =
  let npc = max_pc_function f in
  let nreg0 = max_reg_function f in
  bind3 (reserve_nodes npc) (fun dpc0 ->
    bind3 (reserve_regs nreg0) (fun dreg0 ->
      let ctx' = callcontext ctx dpc0 dreg0 nreg0 f.fn_stacksize retpc retreg
      in
      bind3 (rec0 (PTree.remove id fenv) __ ctx' f) (fun x ->
        add_moves (sregs ctx args) (sregs ctx' f.fn_params3)
          (spc ctx' f.fn_entrypoint))))

(** val inline_tail_function :
    funenv -> (funenv -> __ -> context -> function4 -> unit0 mon0) -> context
    -> ident -> function4 -> reg list -> node mon0 **)

let inline_tail_function fenv rec0 ctx id f args =
  let npc = max_pc_function f in
  let nreg0 = max_reg_function f in
  bind3 (reserve_nodes npc) (fun dpc0 ->
    bind3 (reserve_regs nreg0) (fun dreg0 ->
      let ctx' = tailcontext ctx dpc0 dreg0 nreg0 f.fn_stacksize in
      bind3 (rec0 (PTree.remove id fenv) __ ctx' f) (fun x ->
        add_moves (sregs ctx args) (sregs ctx' f.fn_params3)
          (spc ctx' f.fn_entrypoint))))

(** val inline_return :
    context -> reg option -> (node, reg) prod -> instruction **)

let inline_return ctx or2 = function
| Pair (retpc, retreg) ->
  (match or2 with
   | Some r -> Iop (Omove, (Cons ((sreg ctx r), Nil)), retreg, retpc)
   | None -> Inop retpc)

(** val expand_instr :
    funenv -> (funenv -> __ -> context -> function4 -> unit0 mon0) -> context
    -> node -> instruction -> unit0 mon0 **)

let expand_instr fenv rec0 ctx pc = function
| Inop s -> set_instr (spc ctx pc) (Inop (spc ctx s))
| Iop (op, args, res2, s) ->
  set_instr (spc ctx pc) (Iop ((sop ctx op), (sregs ctx args),
    (sreg ctx res2), (spc ctx s)))
| Iload (chunk, addr, args, dst, s) ->
  set_instr (spc ctx pc) (Iload (chunk, (saddr ctx addr), (sregs ctx args),
    (sreg ctx dst), (spc ctx s)))
| Istore (chunk, addr, args, src, s) ->
  set_instr (spc ctx pc) (Istore (chunk, (saddr ctx addr), (sregs ctx args),
    (sreg ctx src), (spc ctx s)))
| Icall (sg, ros, args, res2, s) ->
  (match can_inline fenv ros with
   | Cannot_inline ->
     set_instr (spc ctx pc) (Icall (sg, (sros ctx ros), (sregs ctx args),
       (sreg ctx res2), (spc ctx s)))
   | Can_inline (id, f) ->
     bind3 (inline_function fenv rec0 ctx id f args s res2) (fun n0 ->
       set_instr (spc ctx pc) (Inop n0)))
| Itailcall (sg, ros, args) ->
  (match can_inline fenv ros with
   | Cannot_inline ->
     (match ctx.retinfo with
      | Some p ->
        let Pair (rpc, rreg) = p in
        set_instr (spc ctx pc) (Icall (sg, (sros ctx ros), (sregs ctx args),
          rreg, rpc))
      | None ->
        set_instr (spc ctx pc) (Itailcall (sg, (sros ctx ros),
          (sregs ctx args))))
   | Can_inline (id, f) ->
     bind3 (inline_tail_function fenv rec0 ctx id f args) (fun n0 ->
       set_instr (spc ctx pc) (Inop n0)))
| Ibuiltin (ef, args, res2, s) ->
  set_instr (spc ctx pc) (Ibuiltin (ef, (map (sbuiltinarg ctx) args),
    (sbuiltinres ctx res2), (spc ctx s)))
| Icond (cond, args, s1, s2) ->
  set_instr (spc ctx pc) (Icond (cond, (sregs ctx args), (spc ctx s1),
    (spc ctx s2)))
| Ijumptable (r, tbl) ->
  set_instr (spc ctx pc) (Ijumptable ((sreg ctx r), (map (spc ctx) tbl)))
| Ireturn or2 ->
  (match ctx.retinfo with
   | Some rinfo -> set_instr (spc ctx pc) (inline_return ctx or2 rinfo)
   | None -> set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) or2)))

(** val expand_cfg_rec :
    funenv -> (funenv -> __ -> context -> function4 -> unit0 mon0) -> context
    -> function4 -> unit0 mon0 **)

let expand_cfg_rec fenv rec0 ctx f =
  bind3 (request_stack (Z.add ctx.dstk ctx.mstk)) (fun x ->
    ptree_mfold (expand_instr fenv rec0 ctx) f.fn_code)

(** val expand_cfg : funenv -> context -> function4 -> unit0 mon0 **)

let expand_cfg =
  fixm size_fenv expand_cfg_rec

(** val expand_function : funenv -> function4 -> context mon0 **)

let expand_function fenv f =
  let npc = max_pc_function f in
  let nreg0 = max_reg_function f in
  bind3 (reserve_nodes npc) (fun dpc0 ->
    bind3 (reserve_regs nreg0) (fun dreg0 ->
      let ctx = initcontext dpc0 dreg0 nreg0 f.fn_stacksize in
      bind3 (expand_cfg fenv ctx f) (fun x -> ret0 ctx)))

(** val transf_function2 : funenv -> function4 -> function4 res **)

let transf_function2 fenv f =
  let R0 (ctx, s) = expand_function fenv f initstate in
  (match zlt s.st_stksize Int.max_unsigned with
   | Left ->
     OK { fn_sig2 = f.fn_sig2; fn_params3 = (sregs ctx f.fn_params3);
       fn_stacksize = s.st_stksize; fn_code = s.st_code0; fn_entrypoint =
       (spc ctx f.fn_entrypoint) }
   | Right ->
     Error
       (msg (String ((Ascii (True, False, False, True, False, False, True,
         False)), (String ((Ascii (False, True, True, True, False, True,
         True, False)), (String ((Ascii (False, False, True, True, False,
         True, True, False)), (String ((Ascii (True, False, False, True,
         False, True, True, False)), (String ((Ascii (False, True, True,
         True, False, True, True, False)), (String ((Ascii (True, False,
         False, True, False, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii (True,
         True, True, False, False, True, True, False)), (String ((Ascii
         (False, True, False, True, True, True, False, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (True, True, False, False, True, True, True,
         False)), (String ((Ascii (False, False, True, False, True, True,
         True, False)), (String ((Ascii (True, False, False, False, False,
         True, True, False)), (String ((Ascii (True, True, False, False,
         False, True, True, False)), (String ((Ascii (True, True, False,
         True, False, True, True, False)), (String ((Ascii (False, False,
         False, False, False, True, False, False)), (String ((Ascii (False,
         False, True, False, True, True, True, False)), (String ((Ascii
         (True, True, True, True, False, True, True, False)), (String ((Ascii
         (True, True, True, True, False, True, True, False)), (String ((Ascii
         (False, False, False, False, False, True, False, False)), (String
         ((Ascii (False, True, False, False, False, True, True, False)),
         (String ((Ascii (True, False, False, True, False, True, True,
         False)), (String ((Ascii (True, True, True, False, False, True,
         True, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))

(** val transf_fundef2 : funenv -> fundef4 -> fundef4 res **)

let transf_fundef2 fenv fd =
  transf_partial_fundef (transf_function2 fenv) fd

(** val transf_program1 : program4 -> program4 res **)

let transf_program1 p =
  let fenv = funenv_program p in
  transform_partial_program (transf_fundef2 fenv) p

module WfIter = 
 struct 
  (** val step_info :
      ('a1 -> ('a2, 'a1) sum) -> 'a1 -> ('a2, 'a1 sig2) sum **)
  
  let step_info step0 a =
    match step0 a with
    | Inl b -> Inl b
    | Inr a0 -> Inr a0
  
  (** val iterate_F :
      ('a1 -> ('a2, 'a1) sum) -> 'a1 -> ('a1 -> __ -> 'a2) -> 'a2 **)
  
  let iterate_F step0 a rec0 =
    match step_info step0 a with
    | Inl s -> s
    | Inr s -> rec0 s __
  
  (** val iterate : ('a1 -> ('a2, 'a1) sum) -> 'a1 -> 'a2 **)
  
  let iterate step0 a =
    fix (iterate_F step0) a
 end

module PrimIter = 
 struct 
  (** val num_iterations : positive **)
  
  let num_iterations =
    XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XO (XI (XO (XO (XO (XI (XO
      (XI (XO (XO (XI (XO (XI (XO (XO (XI (XO (XI (XO (XI (XI (XO (XO (XO (XI
      (XO (XI (XI XH))))))))))))))))))))))))))))))))))))))
  
  (** val iter_step :
      ('a1 -> ('a2, 'a1) sum) -> positive -> (positive -> __ -> 'a1 -> 'a2
      option) -> 'a1 -> 'a2 option **)
  
  let iter_step step0 x next0 s =
    match peq x XH with
    | Left -> None
    | Right ->
      (match step0 s with
       | Inl res2 -> Some res2
       | Inr s' -> next0 (Coq_Pos.pred x) __ s')
  
  (** val iter : ('a1 -> ('a2, 'a1) sum) -> positive -> 'a1 -> 'a2 option **)
  
  let iter step0 =
    fix (iter_step step0)
  
  (** val iterate : ('a1 -> ('a2, 'a1) sum) -> 'a1 -> 'a2 option **)
  
  let iterate step0 =
    iter step0 num_iterations
 end

type node1 = positive

type graph = node1 list PTree.t

module PositiveOrd = 
 struct 
  type t = positive
  
  (** val leb : t -> t -> bool **)
  
  let leb x y =
    match plt y x with
    | Left -> False
    | Right -> True
 end

module Coq_Sort = Sort(PositiveOrd)

type state1 = { gr : graph; wrk : (node1, node1 list) prod list;
                map0 : positive PTree.t; next : positive }

(** val gr : state1 -> graph **)

let gr x = x.gr

(** val wrk : state1 -> (node1, node1 list) prod list **)

let wrk x = x.wrk

(** val map0 : state1 -> positive PTree.t **)

let map0 x = x.map0

(** val next : state1 -> positive **)

let next x = x.next

(** val init_state0 : graph -> node1 -> state1 **)

let init_state0 g root =
  match PTree.get root g with
  | Some succs ->
    { gr = (PTree.remove root g); wrk = (Cons ((Pair (root,
      (Coq_Sort.sort succs))), Nil)); map0 = PTree.empty; next = XH }
  | None -> { gr = g; wrk = Nil; map0 = PTree.empty; next = XH }

(** val transition : state1 -> (positive PTree.t, state1) sum **)

let transition s =
  match s.wrk with
  | Nil -> Inl s.map0
  | Cons (p, l) ->
    let Pair (x, l0) = p in
    (match l0 with
     | Nil ->
       Inr { gr = s.gr; wrk = l; map0 = (PTree.set x s.next s.map0); next =
         (Coq_Pos.succ s.next) }
     | Cons (y, succs_x) ->
       (match PTree.get y s.gr with
        | Some succs_y ->
          Inr { gr = (PTree.remove y s.gr); wrk = (Cons ((Pair (y,
            (Coq_Sort.sort succs_y))), (Cons ((Pair (x, succs_x)), l))));
            map0 = s.map0; next = s.next }
        | None ->
          Inr { gr = s.gr; wrk = (Cons ((Pair (x, succs_x)), l)); map0 =
            s.map0; next = s.next }))

(** val postorder : graph -> node1 -> positive PTree.t **)

let postorder g root =
  WfIter.iterate transition (init_state0 g root)

(** val renum_pc : positive PTree.t -> node -> node **)

let renum_pc pnum pc =
  match PTree.get pc pnum with
  | Some pc' -> pc'
  | None -> XH

(** val renum_instr : positive PTree.t -> instruction -> instruction **)

let renum_instr pnum i = match i with
| Inop s -> Inop (renum_pc pnum s)
| Iop (op, args, res2, s) -> Iop (op, args, res2, (renum_pc pnum s))
| Iload (chunk, addr, args, res2, s) ->
  Iload (chunk, addr, args, res2, (renum_pc pnum s))
| Istore (chunk, addr, args, src, s) ->
  Istore (chunk, addr, args, src, (renum_pc pnum s))
| Icall (sg, ros, args, res2, s) ->
  Icall (sg, ros, args, res2, (renum_pc pnum s))
| Ibuiltin (ef, args, res2, s) ->
  Ibuiltin (ef, args, res2, (renum_pc pnum s))
| Icond (cond, args, s1, s2) ->
  Icond (cond, args, (renum_pc pnum s1), (renum_pc pnum s2))
| Ijumptable (arg, tbl) -> Ijumptable (arg, (map (renum_pc pnum) tbl))
| _ -> i

(** val renum_node :
    positive PTree.t -> code -> node -> instruction -> code **)

let renum_node pnum c' pc i =
  match PTree.get pc pnum with
  | Some pc' -> PTree.set pc' (renum_instr pnum i) c'
  | None -> c'

(** val renum_cfg : positive PTree.t -> code -> code **)

let renum_cfg pnum c =
  PTree.fold (renum_node pnum) c PTree.empty

(** val transf_function3 : function4 -> function4 **)

let transf_function3 f =
  let pnum = postorder (successors_map f) f.fn_entrypoint in
  { fn_sig2 = f.fn_sig2; fn_params3 = f.fn_params3; fn_stacksize =
  f.fn_stacksize; fn_code = (renum_cfg pnum f.fn_code); fn_entrypoint =
  (renum_pc pnum f.fn_entrypoint) }

(** val transf_fundef3 : fundef4 -> fundef4 **)

let transf_fundef3 fd =
  transf_fundef transf_function3 fd

(** val transf_program2 : program4 -> program4 **)

let transf_program2 p =
  transform_program transf_fundef3 p

module type SEMILATTICE = 
 sig 
  type t 
  
  val beq : t -> t -> bool
  
  val bot : t
  
  val lub : t -> t -> t
 end

module type SEMILATTICE_WITH_TOP = 
 sig 
  type t 
  
  val beq : t -> t -> bool
  
  val bot : t
  
  val lub : t -> t -> t
  
  val top : t
 end

module LPMap1 = 
 functor (L:SEMILATTICE) ->
 struct 
  type t = L.t PTree.t
  
  (** val get : positive -> t -> L.t **)
  
  let get p x =
    match PTree.get p x with
    | Some x0 -> x0
    | None -> L.bot
  
  (** val set : positive -> L.t -> t -> t **)
  
  let set p v x =
    match L.beq v L.bot with
    | True -> PTree.remove p x
    | False -> PTree.set p v x
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    PTree.beq L.beq x y
  
  (** val bot : t **)
  
  let bot =
    PTree.empty
  
  (** val opt_beq : L.t option -> L.t option -> bool **)
  
  let opt_beq ox oy =
    match ox with
    | Some x ->
      (match oy with
       | Some y -> L.beq x y
       | None -> False)
    | None ->
      (match oy with
       | Some t1 -> False
       | None -> True)
  
  type changed =
  | Unchanged
  | Changed of L.t PTree.t
  
  (** val combine_l :
      (L.t option -> L.t option -> L.t option) -> L.t PTree.t -> changed **)
  
  let rec combine_l f = function
  | PTree.Leaf -> Unchanged
  | PTree.Node (l, o, r) ->
    let o' = f o None in
    (match combine_l f l with
     | Unchanged ->
       (match combine_l f r with
        | Unchanged ->
          (match opt_beq o' o with
           | True -> Unchanged
           | False -> Changed (PTree.coq_Node' l o' r))
        | Changed r' -> Changed (PTree.coq_Node' l o' r'))
     | Changed l' ->
       (match combine_l f r with
        | Unchanged -> Changed (PTree.coq_Node' l' o' r)
        | Changed r' -> Changed (PTree.coq_Node' l' o' r')))
  
  (** val combine_r :
      (L.t option -> L.t option -> L.t option) -> L.t PTree.t -> changed **)
  
  let rec combine_r f = function
  | PTree.Leaf -> Unchanged
  | PTree.Node (l, o, r) ->
    let o' = f None o in
    (match combine_r f l with
     | Unchanged ->
       (match combine_r f r with
        | Unchanged ->
          (match opt_beq o' o with
           | True -> Unchanged
           | False -> Changed (PTree.coq_Node' l o' r))
        | Changed r' -> Changed (PTree.coq_Node' l o' r'))
     | Changed l' ->
       (match combine_r f r with
        | Unchanged -> Changed (PTree.coq_Node' l' o' r)
        | Changed r' -> Changed (PTree.coq_Node' l' o' r')))
  
  type changed2 =
  | Same
  | Same1
  | Same2
  | CC of L.t PTree.t
  
  (** val xcombine :
      (L.t option -> L.t option -> L.t option) -> L.t PTree.t -> L.t PTree.t
      -> changed2 **)
  
  let rec xcombine f m1 m2 =
    match m1 with
    | PTree.Leaf ->
      (match m2 with
       | PTree.Leaf -> Same
       | PTree.Node (t1, o, t2) ->
         (match combine_r f m2 with
          | Unchanged -> Same2
          | Changed m0 -> CC m0))
    | PTree.Node (l1, o1, r1) ->
      (match m2 with
       | PTree.Leaf ->
         (match combine_l f m1 with
          | Unchanged -> Same1
          | Changed m0 -> CC m0)
       | PTree.Node (l2, o2, r2) ->
         let o = f o1 o2 in
         (match xcombine f l1 l2 with
          | Same ->
            (match xcombine f r1 r2 with
             | Same ->
               (match opt_beq o o1 with
                | True ->
                  (match opt_beq o o2 with
                   | True -> Same
                   | False -> Same1)
                | False ->
                  (match opt_beq o o2 with
                   | True -> Same2
                   | False -> CC (PTree.coq_Node' l1 o r1)))
             | Same1 ->
               (match opt_beq o o1 with
                | True -> Same1
                | False -> CC (PTree.coq_Node' l1 o r1))
             | Same2 ->
               (match opt_beq o o2 with
                | True -> Same2
                | False -> CC (PTree.coq_Node' l2 o r2))
             | CC r -> CC (PTree.coq_Node' l1 o r))
          | Same1 ->
            (match xcombine f r1 r2 with
             | Same2 -> CC (PTree.coq_Node' l1 o r2)
             | CC r -> CC (PTree.coq_Node' l1 o r)
             | _ ->
               (match opt_beq o o1 with
                | True -> Same1
                | False -> CC (PTree.coq_Node' l1 o r1)))
          | Same2 ->
            (match xcombine f r1 r2 with
             | Same1 -> CC (PTree.coq_Node' l2 o r1)
             | CC r -> CC (PTree.coq_Node' l2 o r)
             | _ ->
               (match opt_beq o o2 with
                | True -> Same2
                | False -> CC (PTree.coq_Node' l2 o r2)))
          | CC l ->
            (match xcombine f r1 r2 with
             | Same2 -> CC (PTree.coq_Node' l o r2)
             | CC r -> CC (PTree.coq_Node' l o r)
             | _ -> CC (PTree.coq_Node' l o r1))))
  
  (** val combine :
      (L.t option -> L.t option -> L.t option) -> L.t PTree.t -> L.t PTree.t
      -> L.t PTree.t **)
  
  let combine f m1 m2 =
    match xcombine f m1 m2 with
    | Same2 -> m2
    | CC m0 -> m0
    | _ -> m1
  
  (** val lub : t -> t -> t **)
  
  let lub x y =
    combine (fun a b ->
      match a with
      | Some u ->
        (match b with
         | Some v -> Some (L.lub u v)
         | None -> a)
      | None -> b) x y
 end

module LPMap = 
 functor (L:SEMILATTICE_WITH_TOP) ->
 struct 
  type t' =
  | Bot
  | Top_except of L.t PTree.t
  
  type t = t'
  
  (** val get : positive -> t -> L.t **)
  
  let get p = function
  | Bot -> L.bot
  | Top_except m0 ->
    (match PTree.get p m0 with
     | Some x0 -> x0
     | None -> L.top)
  
  (** val set : positive -> L.t -> t -> t **)
  
  let set p v = function
  | Bot -> Bot
  | Top_except m0 ->
    (match L.beq v L.bot with
     | True -> Bot
     | False ->
       Top_except
         (match L.beq v L.top with
          | True -> PTree.remove p m0
          | False -> PTree.set p v m0))
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    match x with
    | Bot ->
      (match y with
       | Bot -> True
       | Top_except t1 -> False)
    | Top_except m0 ->
      (match y with
       | Bot -> False
       | Top_except n0 -> PTree.beq L.beq m0 n0)
  
  (** val bot : t' **)
  
  let bot =
    Bot
  
  (** val top : t' **)
  
  let top =
    Top_except PTree.empty
  
  module LM = LPMap1(L)
  
  (** val opt_lub : L.t -> L.t -> L.t option **)
  
  let opt_lub x y =
    let z0 = L.lub x y in
    (match L.beq z0 L.top with
     | True -> None
     | False -> Some z0)
  
  (** val lub : t -> t -> t **)
  
  let lub x y =
    match x with
    | Bot -> y
    | Top_except m0 ->
      (match y with
       | Bot -> x
       | Top_except n0 ->
         Top_except
           (LM.combine (fun a b ->
             match a with
             | Some u ->
               (match b with
                | Some v -> opt_lub u v
                | None -> None)
             | None -> None) m0 n0))
 end

module LFSet = 
 functor (S:WS) ->
 struct 
  type t = S.t
  
  (** val beq : t -> t -> bool **)
  
  let beq =
    S.equal
  
  (** val bot : t **)
  
  let bot =
    S.empty
  
  (** val lub : t -> t -> t **)
  
  let lub =
    S.union
 end

module LBoolean = 
 struct 
  type t = bool
  
  (** val beq : t -> t -> bool **)
  
  let beq =
    eqb
  
  (** val bot : bool **)
  
  let bot =
    False
  
  (** val top : bool **)
  
  let top =
    True
  
  (** val lub : t -> t -> bool **)
  
  let lub x y =
    match x with
    | True -> True
    | False -> y
 end

module SplayHeapSet = 
 functor (E:Coq_OrderedType) ->
 struct 
  module R = 
   struct 
    type heap =
    | Empty
    | Node of heap * E.t * heap
    
    (** val partition : E.t -> heap -> (heap, heap) prod **)
    
    let rec partition pivot h = match h with
    | Empty -> Pair (Empty, Empty)
    | Node (a, x, b) ->
      (match E.compare x pivot with
       | LT ->
         (match b with
          | Empty -> Pair (h, Empty)
          | Node (b1, y, b2) ->
            (match E.compare y pivot with
             | LT ->
               let Pair (small, big) = partition pivot b2 in
               Pair ((Node ((Node (a, x, b1)), y, small)), big)
             | EQ -> Pair ((Node (a, x, b1)), b2)
             | GT ->
               let Pair (small, big) = partition pivot b1 in
               Pair ((Node (a, x, small)), (Node (big, y, b2)))))
       | EQ -> Pair (a, b)
       | GT ->
         (match a with
          | Empty -> Pair (Empty, h)
          | Node (a1, y, a2) ->
            (match E.compare y pivot with
             | LT ->
               let Pair (small, big) = partition pivot a2 in
               Pair ((Node (a1, y, small)), (Node (big, x, b)))
             | EQ -> Pair (a1, (Node (a2, x, b)))
             | GT ->
               let Pair (small, big) = partition pivot a1 in
               Pair (small, (Node (big, y, (Node (a2, x, b))))))))
    
    (** val insert : E.t -> heap -> heap **)
    
    let insert x h =
      let Pair (a, b) = partition x h in Node (a, x, b)
    
    (** val findMin : heap -> E.t option **)
    
    let rec findMin = function
    | Empty -> None
    | Node (a, x, b) ->
      (match a with
       | Empty -> Some x
       | Node (l, x0, r) -> findMin a)
    
    (** val deleteMin : heap -> heap **)
    
    let rec deleteMin = function
    | Empty -> Empty
    | Node (l, y, c) ->
      (match l with
       | Empty -> c
       | Node (a, x, b) ->
         (match a with
          | Empty -> Node (b, y, c)
          | Node (l0, x0, r) -> Node ((deleteMin a), x, (Node (b, y, c)))))
    
    (** val findMax : heap -> E.t option **)
    
    let rec findMax = function
    | Empty -> None
    | Node (a, x, b) ->
      (match b with
       | Empty -> Some x
       | Node (l, x0, r) -> findMax b)
    
    (** val deleteMax : heap -> heap **)
    
    let rec deleteMax = function
    | Empty -> Empty
    | Node (a, x, r) ->
      (match r with
       | Empty -> a
       | Node (b, y, c) ->
         (match c with
          | Empty -> Node (a, x, b)
          | Node (l, x0, r0) -> Node ((Node (a, x, b)), y, (deleteMax c))))
    
    type coq_R_partition =
    | R_partition_0 of heap
    | R_partition_1 of heap * heap * E.t * heap
    | R_partition_2 of heap * heap * E.t * heap * heap * E.t * heap
       * (heap, heap) prod * coq_R_partition * heap * heap
    | R_partition_3 of heap * heap * E.t * heap * heap * E.t * heap
    | R_partition_4 of heap * heap * E.t * heap * heap * E.t * heap
       * (heap, heap) prod * coq_R_partition * heap * heap
    | R_partition_5 of heap * heap * E.t * heap
    | R_partition_6 of heap * heap * E.t * heap
    | R_partition_7 of heap * heap * E.t * heap * heap * E.t * heap
       * (heap, heap) prod * coq_R_partition * heap * heap
    | R_partition_8 of heap * heap * E.t * heap * heap * E.t * heap
    | R_partition_9 of heap * heap * E.t * heap * heap * E.t * heap
       * (heap, heap) prod * coq_R_partition * heap * heap
    
    type coq_R_deleteMin =
    | R_deleteMin_0 of heap
    | R_deleteMin_1 of heap * heap * E.t * heap
    | R_deleteMin_2 of heap * heap * E.t * heap * heap * E.t * heap
    | R_deleteMin_3 of heap * heap * E.t * heap * heap * E.t * heap * 
       heap * E.t * heap * heap * coq_R_deleteMin
    
    type coq_R_deleteMax =
    | R_deleteMax_0 of heap
    | R_deleteMax_1 of heap * heap * E.t * heap
    | R_deleteMax_2 of heap * heap * E.t * heap * heap * E.t * heap
    | R_deleteMax_3 of heap * heap * E.t * heap * heap * E.t * heap * 
       heap * E.t * heap * heap * coq_R_deleteMax
   end
  
  type t = R.heap
  
  (** val empty : t **)
  
  let empty =
    R.Empty
  
  (** val insert : E.t -> t -> t **)
  
  let insert x h =
    R.insert x h
  
  (** val findMin : t -> E.t option **)
  
  let findMin h =
    R.findMin h
  
  (** val deleteMin : t -> t **)
  
  let deleteMin h =
    R.deleteMin h
  
  (** val findMax : t -> E.t option **)
  
  let findMax h =
    R.findMax h
  
  (** val deleteMax : t -> t **)
  
  let deleteMax h =
    R.deleteMax h
 end

module PHeap = SplayHeapSet(OrderedPositive)

module type NODE_SET = 
 sig 
  type t 
  
  val empty : t
  
  val add : positive -> t -> t
  
  val pick : t -> (positive, t) prod option
  
  val all_nodes : 'a1 PTree.t -> t
 end

module Dataflow_Solver = 
 functor (LAT:SEMILATTICE) ->
 functor (NS:NODE_SET) ->
 struct 
  module L = LAT
  
  type state = { aval : L.t PTree.t; worklist : NS.t }
  
  (** val aval : state -> L.t PTree.t **)
  
  let aval s =
    s.aval
  
  (** val worklist : state -> NS.t **)
  
  let worklist s =
    s.worklist
  
  (** val abstr_value : positive -> state -> L.t **)
  
  let abstr_value n0 s =
    match PTree.get n0 (aval s) with
    | Some v -> v
    | None -> L.bot
  
  (** val propagate_succ : state -> L.t -> positive -> state **)
  
  let propagate_succ s out n0 =
    match PTree.get n0 (aval s) with
    | Some oldl ->
      let newl = L.lub oldl out in
      (match L.beq oldl newl with
       | True -> s
       | False ->
         { aval = (PTree.set n0 newl (aval s)); worklist =
           (NS.add n0 (worklist s)) })
    | None ->
      { aval = (PTree.set n0 out (aval s)); worklist =
        (NS.add n0 (worklist s)) }
  
  (** val propagate_succ_list : state -> L.t -> positive list -> state **)
  
  let rec propagate_succ_list s out = function
  | Nil -> s
  | Cons (n0, rem0) -> propagate_succ_list (propagate_succ s out n0) out rem0
  
  (** val step :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      state -> (L.t PMap.t, state) sum **)
  
  let step code4 successors transf s =
    match NS.pick (worklist s) with
    | Some p ->
      let Pair (n0, rem0) = p in
      (match PTree.get n0 code4 with
       | Some instr ->
         Inr
           (propagate_succ_list { aval = (aval s); worklist = rem0 }
             (transf n0 (abstr_value n0 s)) (successors instr))
       | None -> Inr { aval = (aval s); worklist = rem0 })
    | None -> Inl (Pair (L.bot, (aval s)))
  
  (** val fixpoint_from :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      state -> L.t PMap.t option **)
  
  let fixpoint_from code4 successors transf start =
    PrimIter.iterate (step code4 successors transf) start
  
  (** val start_state : positive -> L.t -> state **)
  
  let start_state enode eval =
    { aval = (PTree.set enode eval PTree.empty); worklist =
      (NS.add enode NS.empty) }
  
  (** val fixpoint :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      positive -> L.t -> L.t PMap.t option **)
  
  let fixpoint code4 successors transf enode eval =
    fixpoint_from code4 successors transf (start_state enode eval)
  
  (** val start_state_nodeset : NS.t -> state **)
  
  let start_state_nodeset enodes =
    { aval = PTree.empty; worklist = enodes }
  
  (** val fixpoint_nodeset :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      NS.t -> L.t PMap.t option **)
  
  let fixpoint_nodeset code4 successors transf enodes =
    fixpoint_from code4 successors transf (start_state_nodeset enodes)
  
  (** val start_state_allnodes : 'a1 PTree.t -> state **)
  
  let start_state_allnodes code4 =
    { aval = PTree.empty; worklist = (NS.all_nodes code4) }
  
  (** val fixpoint_allnodes :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      L.t PMap.t option **)
  
  let fixpoint_allnodes code4 successors transf =
    fixpoint_from code4 successors transf (start_state_allnodes code4)
 end

(** val successors_list :
    positive list PTree.t -> positive -> positive list **)

let successors_list successors pc =
  match PTree.get pc successors with
  | Some l -> l
  | None -> Nil

(** val add_successors :
    positive list PTree.t -> positive -> positive list -> positive list
    PTree.t **)

let rec add_successors pred0 from = function
| Nil -> pred0
| Cons (to0, rem0) ->
  add_successors
    (PTree.set to0 (Cons (from, (successors_list pred0 to0))) pred0) from
    rem0

(** val make_predecessors :
    'a1 PTree.t -> ('a1 -> positive list) -> positive list PTree.t **)

let make_predecessors code4 successors =
  PTree.fold (fun pred0 pc instr ->
    add_successors pred0 pc (successors instr)) code4 PTree.empty

module type BACKWARD_DATAFLOW_SOLVER = 
 sig 
  module L : 
   SEMILATTICE
  
  val fixpoint :
    'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) -> L.t
    PMap.t option
  
  val fixpoint_allnodes :
    'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) -> L.t
    PMap.t option
 end

module Backward_Dataflow_Solver = 
 functor (LAT:SEMILATTICE) ->
 functor (NS:NODE_SET) ->
 struct 
  module L = LAT
  
  module DS = Dataflow_Solver(L)(NS)
  
  (** val sequential_node :
      'a1 PTree.t -> ('a1 -> positive list) -> positive -> 'a1 -> bool **)
  
  let sequential_node code4 successors pc instr =
    existsb (fun s ->
      match PTree.get s code4 with
      | Some a -> proj_sumbool (plt s pc)
      | None -> False) (successors instr)
  
  (** val exit_points : 'a1 PTree.t -> ('a1 -> positive list) -> NS.t **)
  
  let exit_points code4 successors =
    PTree.fold (fun ep pc instr ->
      match sequential_node code4 successors pc instr with
      | True -> ep
      | False -> NS.add pc ep) code4 NS.empty
  
  (** val fixpoint :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      DS.L.t PMap.t option **)
  
  let fixpoint code4 successors transf =
    DS.fixpoint_nodeset (make_predecessors code4 successors) (fun l -> l)
      transf (exit_points code4 successors)
  
  (** val fixpoint_allnodes :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      DS.L.t PMap.t option **)
  
  let fixpoint_allnodes code4 successors transf =
    DS.fixpoint_allnodes (make_predecessors code4 successors) (fun l -> l)
      transf
 end

module type ORDERED_TYPE_WITH_TOP = 
 sig 
  type t 
  
  val top : t
 end

module type BBLOCK_SOLVER = 
 sig 
  module L : 
   ORDERED_TYPE_WITH_TOP
  
  val fixpoint :
    'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
    positive -> L.t PMap.t option
 end

module BBlock_solver = 
 functor (LAT:ORDERED_TYPE_WITH_TOP) ->
 struct 
  module L = LAT
  
  type bbmap = positive -> bool
  
  type result = L.t PMap.t
  
  type state = { aval : result; worklist : positive list }
  
  (** val aval : state -> result **)
  
  let aval s =
    s.aval
  
  (** val worklist : state -> positive list **)
  
  let worklist s =
    s.worklist
  
  (** val propagate_successors :
      bbmap -> positive list -> L.t -> state -> state **)
  
  let rec propagate_successors bb succs l st =
    match succs with
    | Nil -> st
    | Cons (s1, sl) ->
      (match bb s1 with
       | True -> propagate_successors bb sl l st
       | False ->
         propagate_successors bb sl l { aval = (PMap.set s1 l (aval st));
           worklist = (Cons (s1, (worklist st))) })
  
  (** val step :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      bbmap -> state -> (result, state) sum **)
  
  let step code4 successors transf bb st =
    match worklist st with
    | Nil -> Inl (aval st)
    | Cons (pc, rem0) ->
      (match PTree.get pc code4 with
       | Some instr ->
         Inr
           (propagate_successors bb (successors instr)
             (transf pc (PMap.get pc (aval st))) { aval = (aval st);
             worklist = rem0 })
       | None -> Inr { aval = (aval st); worklist = rem0 })
  
  (** val is_basic_block_head :
      positive -> positive list PTree.t -> positive -> bool **)
  
  let is_basic_block_head entrypoint preds pc =
    match peq pc entrypoint with
    | Left -> True
    | Right ->
      (match successors_list preds pc with
       | Nil -> False
       | Cons (s, l) ->
         (match l with
          | Nil -> proj_sumbool (peq s pc)
          | Cons (p, l0) -> True))
  
  (** val basic_block_map :
      'a1 PTree.t -> ('a1 -> positive list) -> positive -> bbmap **)
  
  let basic_block_map code4 successors entrypoint =
    is_basic_block_head entrypoint (make_predecessors code4 successors)
  
  (** val basic_block_list : 'a1 PTree.t -> bbmap -> positive list **)
  
  let basic_block_list code4 bb =
    PTree.fold (fun l pc instr ->
      match bb pc with
      | True -> Cons (pc, l)
      | False -> l) code4 Nil
  
  (** val fixpoint :
      'a1 PTree.t -> ('a1 -> positive list) -> (positive -> L.t -> L.t) ->
      positive -> result option **)
  
  let fixpoint code4 successors transf entrypoint =
    let bb = basic_block_map code4 successors entrypoint in
    PrimIter.iterate (step code4 successors transf bb) { aval =
      (PMap.init L.top); worklist = (basic_block_list code4 bb) }
  
  (** val predecessors :
      'a1 PTree.t -> ('a1 -> positive list) -> positive list PTree.t **)
  
  let predecessors code4 successors =
    make_predecessors code4 successors
 end

module NodeSetForward = 
 struct 
  type t = PHeap.t
  
  (** val empty : PHeap.t **)
  
  let empty =
    PHeap.empty
  
  (** val add : positive -> t -> t **)
  
  let add n0 s =
    PHeap.insert n0 s
  
  (** val pick : t -> (positive, PHeap.t) prod option **)
  
  let pick s =
    match PHeap.findMax s with
    | Some n0 -> Some (Pair (n0, (PHeap.deleteMax s)))
    | None -> None
  
  (** val all_nodes : 'a1 PTree.t -> PHeap.t **)
  
  let all_nodes code4 =
    PTree.fold (fun s pc instr -> PHeap.insert pc s) code4 PHeap.empty
 end

module NodeSetBackward = 
 struct 
  type t = PHeap.t
  
  (** val empty : PHeap.t **)
  
  let empty =
    PHeap.empty
  
  (** val add : positive -> t -> t **)
  
  let add n0 s =
    PHeap.insert n0 s
  
  (** val pick : t -> (positive, PHeap.t) prod option **)
  
  let pick s =
    match PHeap.findMin s with
    | Some n0 -> Some (Pair (n0, (PHeap.deleteMin s)))
    | None -> None
  
  (** val all_nodes : 'a1 PTree.t -> PHeap.t **)
  
  let all_nodes code4 =
    PTree.fold (fun s pc instr -> PHeap.insert pc s) code4 PHeap.empty
 end

(** val reg_option_live : reg option -> Regset.t -> Regset.t **)

let reg_option_live or2 lv =
  match or2 with
  | Some r -> Regset.add r lv
  | None -> lv

(** val reg_sum_live : (reg, ident) sum -> Regset.t -> Regset.t **)

let reg_sum_live ros lv =
  match ros with
  | Inl r -> Regset.add r lv
  | Inr s -> lv

(** val reg_list_live : reg list -> Regset.t -> Regset.t **)

let rec reg_list_live rl lv =
  match rl with
  | Nil -> lv
  | Cons (r1, rs) -> reg_list_live rs (Regset.add r1 lv)

(** val reg_list_dead : reg list -> Regset.t -> Regset.t **)

let rec reg_list_dead rl lv =
  match rl with
  | Nil -> lv
  | Cons (r1, rs) -> reg_list_dead rs (Regset.remove r1 lv)

(** val transfer : function4 -> node -> Regset.t -> Regset.t **)

let transfer f pc after =
  match PTree.get pc f.fn_code with
  | Some i ->
    (match i with
     | Inop s -> after
     | Iop (op, args, res2, s) ->
       (match Regset.mem res2 after with
        | True -> reg_list_live args (Regset.remove res2 after)
        | False -> after)
     | Iload (chunk, addr, args, dst, s) ->
       (match Regset.mem dst after with
        | True -> reg_list_live args (Regset.remove dst after)
        | False -> after)
     | Istore (chunk, addr, args, src, s) ->
       reg_list_live args (Regset.add src after)
     | Icall (sig1, ros, args, res2, s) ->
       reg_list_live args (reg_sum_live ros (Regset.remove res2 after))
     | Itailcall (sig1, ros, args) ->
       reg_list_live args (reg_sum_live ros Regset.empty)
     | Ibuiltin (ef, args, res2, s) ->
       reg_list_live (params_of_builtin_args args)
         (reg_list_dead (params_of_builtin_res res2) after)
     | Icond (cond, args, ifso, ifnot) -> reg_list_live args after
     | Ijumptable (arg, tbl) -> Regset.add arg after
     | Ireturn optarg -> reg_option_live optarg Regset.empty)
  | None -> Regset.empty

module RegsetLat = LFSet(Regset)

module DS = Backward_Dataflow_Solver(RegsetLat)(NodeSetBackward)

(** val analyze : function4 -> Regset.t PMap.t option **)

let analyze f =
  DS.fixpoint f.fn_code successors_instr (transfer f)

(** val last_uses_at : Regset.t PMap.t -> node -> instruction -> reg list **)

let last_uses_at live pc i =
  let l = PMap.get pc live in
  let lu = filter (fun r -> negb (Regset.mem r l)) (instr_uses i) in
  (match instr_defs i with
   | Some r ->
     (match Regset.mem r l with
      | True -> lu
      | False -> Cons (r, lu))
   | None -> lu)

(** val last_uses : function4 -> reg list PTree.t **)

let last_uses f =
  match analyze f with
  | Some live -> PTree.map (last_uses_at live) f.fn_code
  | None -> PTree.empty

type abool =
| Bnone
| Just of bool
| Maybe of bool
| Btop

(** val club : abool -> abool -> abool **)

let club x y =
  match x with
  | Bnone ->
    (match y with
     | Just b -> Maybe b
     | x0 -> x0)
  | Just b1 ->
    (match y with
     | Bnone -> Maybe b1
     | Just b2 ->
       (match eqb b1 b2 with
        | True -> x
        | False -> Btop)
     | Maybe b2 ->
       (match eqb b1 b2 with
        | True -> y
        | False -> Btop)
     | Btop -> Btop)
  | Maybe b1 ->
    (match y with
     | Bnone -> Maybe b1
     | Just b2 ->
       (match eqb b1 b2 with
        | True -> x
        | False -> Btop)
     | Maybe b2 ->
       (match eqb b1 b2 with
        | True -> x
        | False -> Btop)
     | Btop -> Btop)
  | Btop -> Btop

(** val cnot : abool -> abool **)

let cnot x = match x with
| Just b -> Just (negb b)
| Maybe b -> Maybe (negb b)
| _ -> x

type aptr =
| Pbot
| Gl of ident * Int.int
| Glo of ident
| Glob
| Stk of Int.int
| Stack
| Nonstack
| Ptop

(** val eq_aptr : aptr -> aptr -> sumbool **)

let eq_aptr p1 p2 =
  match p1 with
  | Pbot ->
    (match p2 with
     | Pbot -> Left
     | _ -> Right)
  | Gl (x, x0) ->
    (match p2 with
     | Gl (id0, ofs0) ->
       (match ident_eq x id0 with
        | Left -> Int.eq_dec x0 ofs0
        | Right -> Right)
     | _ -> Right)
  | Glo x ->
    (match p2 with
     | Glo id0 -> ident_eq x id0
     | _ -> Right)
  | Glob ->
    (match p2 with
     | Glob -> Left
     | _ -> Right)
  | Stk x ->
    (match p2 with
     | Stk ofs0 -> Int.eq_dec x ofs0
     | _ -> Right)
  | Stack ->
    (match p2 with
     | Stack -> Left
     | _ -> Right)
  | Nonstack ->
    (match p2 with
     | Nonstack -> Left
     | _ -> Right)
  | Ptop ->
    (match p2 with
     | Ptop -> Left
     | _ -> Right)

(** val plub : aptr -> aptr -> aptr **)

let plub p q =
  match p with
  | Pbot -> q
  | Gl (id1, ofs1) ->
    (match q with
     | Pbot -> p
     | Gl (id2, ofs2) ->
       (match ident_eq id1 id2 with
        | Left ->
          (match Int.eq_dec ofs1 ofs2 with
           | Left -> p
           | Right -> Glo id1)
        | Right -> Glob)
     | Glo id2 ->
       (match ident_eq id1 id2 with
        | Left -> q
        | Right -> Glob)
     | Glob -> Glob
     | Nonstack -> Nonstack
     | _ -> Ptop)
  | Glo id1 ->
    (match q with
     | Pbot -> p
     | Gl (id2, ofs2) ->
       (match ident_eq id1 id2 with
        | Left -> p
        | Right -> Glob)
     | Glo id2 ->
       (match ident_eq id1 id2 with
        | Left -> p
        | Right -> Glob)
     | Glob -> Glob
     | Nonstack -> Nonstack
     | _ -> Ptop)
  | Glob ->
    (match q with
     | Pbot -> p
     | Stk ofs -> Ptop
     | Stack -> Ptop
     | Nonstack -> Nonstack
     | Ptop -> Ptop
     | _ -> Glob)
  | Stk ofs1 ->
    (match q with
     | Pbot -> p
     | Stk ofs2 ->
       (match Int.eq_dec ofs1 ofs2 with
        | Left -> p
        | Right -> Stack)
     | Stack -> Stack
     | _ -> Ptop)
  | Stack ->
    (match q with
     | Pbot -> p
     | Stk ofs -> Stack
     | Stack -> Stack
     | _ -> Ptop)
  | Nonstack ->
    (match q with
     | Pbot -> p
     | Stk ofs -> Ptop
     | Stack -> Ptop
     | Ptop -> Ptop
     | _ -> Nonstack)
  | Ptop ->
    (match q with
     | Pbot -> p
     | _ -> Ptop)

(** val pincl : aptr -> aptr -> bool **)

let pincl p q =
  match p with
  | Pbot -> True
  | Gl (id1, ofs1) ->
    (match q with
     | Pbot -> False
     | Gl (id2, ofs2) ->
       (match proj_sumbool (peq id1 id2) with
        | True -> proj_sumbool (Int.eq_dec ofs1 ofs2)
        | False -> False)
     | Glo id2 -> proj_sumbool (peq id1 id2)
     | Stk ofs -> False
     | Stack -> False
     | _ -> True)
  | Glo id1 ->
    (match q with
     | Glo id2 -> proj_sumbool (peq id1 id2)
     | Glob -> True
     | Nonstack -> True
     | Ptop -> True
     | _ -> False)
  | Glob ->
    (match q with
     | Glob -> True
     | Nonstack -> True
     | Ptop -> True
     | _ -> False)
  | Stk ofs1 ->
    (match q with
     | Stk ofs2 -> proj_sumbool (Int.eq_dec ofs1 ofs2)
     | Stack -> True
     | Ptop -> True
     | _ -> False)
  | Stack ->
    (match q with
     | Stack -> True
     | Ptop -> True
     | _ -> False)
  | Nonstack ->
    (match q with
     | Nonstack -> True
     | Ptop -> True
     | _ -> False)
  | Ptop ->
    (match q with
     | Ptop -> True
     | _ -> False)

(** val padd : aptr -> Int.int -> aptr **)

let padd p n0 =
  match p with
  | Gl (id, ofs) -> Gl (id, (Int.add ofs n0))
  | Stk ofs -> Stk (Int.add ofs n0)
  | _ -> p

(** val psub : aptr -> Int.int -> aptr **)

let psub p n0 =
  match p with
  | Gl (id, ofs) -> Gl (id, (Int.sub ofs n0))
  | Stk ofs -> Stk (Int.sub ofs n0)
  | _ -> p

(** val poffset : aptr -> aptr **)

let poffset p = match p with
| Gl (id, ofs) -> Glo id
| Stk ofs -> Stack
| _ -> p

(** val cmp_different_blocks0 : comparison0 -> abool **)

let cmp_different_blocks0 = function
| Ceq -> Maybe False
| Cne -> Maybe True
| _ -> Bnone

(** val pcmp : comparison0 -> aptr -> aptr -> abool **)

let pcmp c p1 p2 =
  match p1 with
  | Pbot -> Bnone
  | Gl (id1, ofs1) ->
    (match p2 with
     | Pbot -> Bnone
     | Gl (id2, ofs2) ->
       (match peq id1 id2 with
        | Left -> Maybe (Int.cmpu c ofs1 ofs2)
        | Right -> cmp_different_blocks0 c)
     | Glo id2 ->
       (match peq id1 id2 with
        | Left -> Btop
        | Right -> cmp_different_blocks0 c)
     | Stk ofs -> cmp_different_blocks0 c
     | Stack -> cmp_different_blocks0 c
     | _ -> Btop)
  | Glo id1 ->
    (match p2 with
     | Pbot -> Bnone
     | Gl (id2, ofs2) ->
       (match peq id1 id2 with
        | Left -> Btop
        | Right -> cmp_different_blocks0 c)
     | Glo id2 ->
       (match peq id1 id2 with
        | Left -> Btop
        | Right -> cmp_different_blocks0 c)
     | Stk ofs -> cmp_different_blocks0 c
     | Stack -> cmp_different_blocks0 c
     | _ -> Btop)
  | Stk ofs1 ->
    (match p2 with
     | Pbot -> Bnone
     | Stk ofs2 -> Maybe (Int.cmpu c ofs1 ofs2)
     | Stack -> Btop
     | Ptop -> Btop
     | _ -> cmp_different_blocks0 c)
  | Stack ->
    (match p2 with
     | Pbot -> Bnone
     | Stk ofs -> Btop
     | Stack -> Btop
     | Ptop -> Btop
     | _ -> cmp_different_blocks0 c)
  | Ptop ->
    (match p2 with
     | Pbot -> Bnone
     | _ -> Btop)
  | _ ->
    (match p2 with
     | Pbot -> Bnone
     | Stk ofs -> cmp_different_blocks0 c
     | Stack -> cmp_different_blocks0 c
     | _ -> Btop)

(** val pdisjoint : aptr -> z -> aptr -> z -> bool **)

let pdisjoint p1 sz1 p2 sz2 =
  match p1 with
  | Pbot -> True
  | Gl (id1, ofs1) ->
    (match p2 with
     | Gl (id2, ofs2) ->
       (match peq id1 id2 with
        | Left ->
          (match proj_sumbool
                   (zle (Z.add (Int.unsigned ofs1) sz1) (Int.unsigned ofs2)) with
           | True -> True
           | False ->
             proj_sumbool
               (zle (Z.add (Int.unsigned ofs2) sz2) (Int.unsigned ofs1)))
        | Right -> True)
     | Glo id2 -> negb (proj_sumbool (peq id1 id2))
     | Glob -> False
     | Nonstack -> False
     | Ptop -> False
     | _ -> True)
  | Glo id1 ->
    (match p2 with
     | Gl (id2, ofs2) -> negb (proj_sumbool (peq id1 id2))
     | Glo id2 -> negb (proj_sumbool (peq id1 id2))
     | Glob -> False
     | Nonstack -> False
     | Ptop -> False
     | _ -> True)
  | Stk ofs1 ->
    (match p2 with
     | Stk ofs2 ->
       (match proj_sumbool
                (zle (Z.add (Int.unsigned ofs1) sz1) (Int.unsigned ofs2)) with
        | True -> True
        | False ->
          proj_sumbool
            (zle (Z.add (Int.unsigned ofs2) sz2) (Int.unsigned ofs1)))
     | Stack -> False
     | Ptop -> False
     | _ -> True)
  | Stack ->
    (match p2 with
     | Stk ofs -> False
     | Stack -> False
     | Ptop -> False
     | _ -> True)
  | Ptop ->
    (match p2 with
     | Pbot -> True
     | _ -> False)
  | _ ->
    (match p2 with
     | Pbot -> True
     | Stk ofs -> True
     | Stack -> True
     | _ -> False)

type aval0 =
| Vbot
| I of Int.int
| Uns of aptr * z
| Sgn of aptr * z
| L of Int64.int
| F of float
| FS of float32
| Ptr of aptr
| Ifptr of aptr

(** val vtop : aval0 **)

let vtop =
  Ifptr Ptop

(** val eq_aval : aval0 -> aval0 -> sumbool **)

let eq_aval v1 v2 =
  match v1 with
  | Vbot ->
    (match v2 with
     | Vbot -> Left
     | _ -> Right)
  | I x ->
    (match v2 with
     | I n0 -> Int.eq_dec x n0
     | _ -> Right)
  | Uns (x, x0) ->
    (match v2 with
     | Uns (p0, n0) ->
       (match eq_aptr x p0 with
        | Left -> zeq x0 n0
        | Right -> Right)
     | _ -> Right)
  | Sgn (x, x0) ->
    (match v2 with
     | Sgn (p0, n0) ->
       (match eq_aptr x p0 with
        | Left -> zeq x0 n0
        | Right -> Right)
     | _ -> Right)
  | L x ->
    (match v2 with
     | L n0 -> Int64.eq_dec x n0
     | _ -> Right)
  | F x ->
    (match v2 with
     | F f0 -> Float.eq_dec x f0
     | _ -> Right)
  | FS x ->
    (match v2 with
     | FS f0 -> Float32.eq_dec x f0
     | _ -> Right)
  | Ptr x ->
    (match v2 with
     | Ptr p0 -> eq_aptr x p0
     | _ -> Right)
  | Ifptr x ->
    (match v2 with
     | Ifptr p0 -> eq_aptr x p0
     | _ -> Right)

(** val usize : Int.int -> z **)

let usize =
  Int.size

(** val ssize : Int.int -> z **)

let ssize i =
  Z.add
    (Int.size
      (match Int.lt i Int.zero with
       | True -> Int.not i
       | False -> i)) (Zpos XH)

(** val provenance : aval0 -> aptr **)

let provenance x =
  match va_strict Tt with
  | True -> Pbot
  | False ->
    (match x with
     | Uns (p, n0) -> poffset p
     | Sgn (p, n0) -> poffset p
     | Ptr p -> poffset p
     | Ifptr p -> poffset p
     | _ -> Pbot)

(** val ntop : aval0 **)

let ntop =
  Ifptr Pbot

(** val ntop1 : aval0 -> aval0 **)

let ntop1 x =
  Ifptr (provenance x)

(** val ntop2 : aval0 -> aval0 -> aval0 **)

let ntop2 x y =
  Ifptr (plub (provenance x) (provenance y))

(** val uns : aptr -> z -> aval0 **)

let uns p n0 =
  match zle n0 (Zpos XH) with
  | Left -> Uns (p, (Zpos XH))
  | Right ->
    (match zle n0 (Zpos (XI (XI XH))) with
     | Left -> Uns (p, (Zpos (XI (XI XH))))
     | Right ->
       (match zle n0 (Zpos (XO (XO (XO XH)))) with
        | Left -> Uns (p, (Zpos (XO (XO (XO XH)))))
        | Right ->
          (match zle n0 (Zpos (XI (XI (XI XH)))) with
           | Left -> Uns (p, (Zpos (XI (XI (XI XH)))))
           | Right ->
             (match zle n0 (Zpos (XO (XO (XO (XO XH))))) with
              | Left -> Uns (p, (Zpos (XO (XO (XO (XO XH))))))
              | Right -> Ifptr p))))

(** val sgn0 : aptr -> z -> aval0 **)

let sgn0 p n0 =
  match zle n0 (Zpos (XO (XO (XO XH)))) with
  | Left -> Sgn (p, (Zpos (XO (XO (XO XH)))))
  | Right ->
    (match zle n0 (Zpos (XO (XO (XO (XO XH))))) with
     | Left -> Sgn (p, (Zpos (XO (XO (XO (XO XH))))))
     | Right -> Ifptr p)

(** val vlub : aval0 -> aval0 -> aval0 **)

let vlub v w =
  match v with
  | Vbot -> w
  | I i ->
    (match w with
     | Vbot -> v
     | I i2 ->
       (match Int.eq i i2 with
        | True -> v
        | False ->
          (match match Int.lt i Int.zero with
                 | True -> True
                 | False -> Int.lt i2 Int.zero with
           | True -> sgn0 Pbot (Z.max (ssize i) (ssize i2))
           | False -> uns Pbot (Z.max (usize i) (usize i2))))
     | Uns (p, n0) ->
       (match Int.lt i Int.zero with
        | True -> sgn0 p (Z.max (ssize i) (Z.add n0 (Zpos XH)))
        | False -> uns p (Z.max (usize i) n0))
     | Sgn (p, n0) -> sgn0 p (Z.max (ssize i) n0)
     | Ptr p ->
       (match match va_strict Tt with
              | True -> True
              | False -> Int.eq i Int.zero with
        | True -> Ifptr p
        | False -> vtop)
     | Ifptr p ->
       (match match va_strict Tt with
              | True -> True
              | False -> Int.eq i Int.zero with
        | True -> Ifptr p
        | False -> vtop)
     | _ -> vtop)
  | Uns (p1, n1) ->
    (match w with
     | Vbot -> v
     | I i ->
       (match Int.lt i Int.zero with
        | True -> sgn0 p1 (Z.max (ssize i) (Z.add n1 (Zpos XH)))
        | False -> uns p1 (Z.max (usize i) n1))
     | Uns (p2, n2) -> Uns ((plub p1 p2), (Z.max n1 n2))
     | Sgn (p2, n2) -> sgn0 (plub p1 p2) (Z.max (Z.add n1 (Zpos XH)) n2)
     | Ptr p -> Ifptr (plub p1 p)
     | Ifptr p -> Ifptr (plub p1 p)
     | _ -> vtop)
  | Sgn (p1, n1) ->
    (match w with
     | Vbot -> v
     | I i -> sgn0 p1 (Z.max (ssize i) n1)
     | Uns (p2, n2) -> sgn0 (plub p1 p2) (Z.max n1 (Z.add n2 (Zpos XH)))
     | Sgn (p2, n2) -> sgn0 (plub p1 p2) (Z.max n1 n2)
     | Ptr p -> Ifptr (plub p1 p)
     | Ifptr p -> Ifptr (plub p1 p)
     | _ -> vtop)
  | L i1 ->
    (match w with
     | Vbot -> v
     | L i2 ->
       (match Int64.eq i1 i2 with
        | True -> v
        | False -> ntop)
     | Ptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | Ifptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | _ -> vtop)
  | F f1 ->
    (match w with
     | Vbot -> v
     | F f2 ->
       (match Float.eq_dec f1 f2 with
        | Left -> v
        | Right -> ntop)
     | Ptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | Ifptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | _ -> vtop)
  | FS f1 ->
    (match w with
     | Vbot -> v
     | FS f2 ->
       (match Float32.eq_dec f1 f2 with
        | Left -> v
        | Right -> ntop)
     | Ptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | Ifptr p ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop)
     | _ -> vtop)
  | Ptr p ->
    (match w with
     | Vbot -> v
     | I i ->
       (match match va_strict Tt with
              | True -> True
              | False -> Int.eq i Int.zero with
        | True -> Ifptr p
        | False -> vtop)
     | Uns (p2, n0) -> Ifptr (plub p p2)
     | Sgn (p2, n0) -> Ifptr (plub p p2)
     | Ptr p0 -> Ptr (plub p p0)
     | Ifptr p0 -> Ifptr (plub p p0)
     | _ ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop))
  | Ifptr p ->
    (match w with
     | Vbot -> v
     | I i ->
       (match match va_strict Tt with
              | True -> True
              | False -> Int.eq i Int.zero with
        | True -> Ifptr p
        | False -> vtop)
     | Uns (p2, n0) -> Ifptr (plub p p2)
     | Sgn (p2, n0) -> Ifptr (plub p p2)
     | Ptr p0 -> Ifptr (plub p p0)
     | Ifptr p0 -> Ifptr (plub p p0)
     | _ ->
       (match va_strict Tt with
        | True -> Ifptr p
        | False -> vtop))

(** val aptr_of_aval : aval0 -> aptr **)

let aptr_of_aval = function
| Ptr p -> p
| Ifptr p -> p
| _ ->
  (match va_strict Tt with
   | True -> Pbot
   | False -> Nonstack)

(** val vplub : aval0 -> aptr -> aptr **)

let vplub v p =
  match v with
  | Ptr q -> plub q p
  | Ifptr q -> plub q p
  | _ -> p

(** val vpincl : aval0 -> aptr -> bool **)

let vpincl v p =
  match v with
  | Uns (q, n0) -> pincl q p
  | Sgn (q, n0) -> pincl q p
  | Ptr q -> pincl q p
  | Ifptr q -> pincl q p
  | _ -> True

(** val vincl : aval0 -> aval0 -> bool **)

let vincl v w =
  match v with
  | Vbot -> True
  | I i ->
    (match w with
     | I j -> proj_sumbool (Int.eq_dec i j)
     | Uns (p, n0) ->
       (match proj_sumbool (Int.eq_dec (Int.zero_ext n0 i) i) with
        | True -> proj_sumbool (zle Z0 n0)
        | False -> False)
     | Sgn (p, n0) ->
       (match proj_sumbool (Int.eq_dec (Int.sign_ext n0 i) i) with
        | True -> proj_sumbool (zlt Z0 n0)
        | False -> False)
     | Ifptr p -> True
     | _ -> False)
  | Uns (p, n0) ->
    (match w with
     | Uns (q, m0) ->
       (match proj_sumbool (zle n0 m0) with
        | True -> pincl p q
        | False -> False)
     | Sgn (q, m0) ->
       (match proj_sumbool (zlt n0 m0) with
        | True -> pincl p q
        | False -> False)
     | Ifptr q -> pincl p q
     | _ -> False)
  | Sgn (p, n0) ->
    (match w with
     | Sgn (q, m0) ->
       (match proj_sumbool (zle n0 m0) with
        | True -> pincl p q
        | False -> False)
     | Ifptr q -> pincl p q
     | _ -> False)
  | L i ->
    (match w with
     | L j -> proj_sumbool (Int64.eq_dec i j)
     | Ifptr p -> True
     | _ -> False)
  | F i ->
    (match w with
     | F j -> proj_sumbool (Float.eq_dec i j)
     | Ifptr p -> True
     | _ -> False)
  | FS i ->
    (match w with
     | FS j -> proj_sumbool (Float32.eq_dec i j)
     | Ifptr p -> True
     | _ -> False)
  | Ptr p ->
    (match w with
     | Ptr q -> pincl p q
     | Ifptr q -> pincl p q
     | _ -> False)
  | Ifptr p ->
    (match w with
     | Ifptr q -> pincl p q
     | _ -> False)

(** val unop_int : (Int.int -> Int.int) -> aval0 -> aval0 **)

let unop_int sem x = match x with
| I n0 -> I (sem n0)
| _ -> ntop1 x

(** val binop_int :
    (Int.int -> Int.int -> Int.int) -> aval0 -> aval0 -> aval0 **)

let binop_int sem x y =
  match x with
  | I n0 ->
    (match y with
     | I m0 -> I (sem n0 m0)
     | _ -> ntop2 x y)
  | _ -> ntop2 x y

(** val unop_float : (float -> float) -> aval0 -> aval0 **)

let unop_float sem x = match x with
| F n0 -> F (sem n0)
| _ -> ntop1 x

(** val binop_float :
    (float -> float -> float) -> aval0 -> aval0 -> aval0 **)

let binop_float sem x y =
  match x with
  | F n0 ->
    (match y with
     | F m0 -> F (sem n0 m0)
     | _ -> ntop2 x y)
  | _ -> ntop2 x y

(** val unop_single : (float32 -> float32) -> aval0 -> aval0 **)

let unop_single sem x = match x with
| FS n0 -> FS (sem n0)
| _ -> ntop1 x

(** val binop_single :
    (float32 -> float32 -> float32) -> aval0 -> aval0 -> aval0 **)

let binop_single sem x y =
  match x with
  | FS n0 ->
    (match y with
     | FS m0 -> FS (sem n0 m0)
     | _ -> ntop2 x y)
  | _ -> ntop2 x y

(** val shl1 : aval0 -> aval0 -> aval0 **)

let shl1 v = function
| I amount ->
  (match Int.ltu amount Int.iwordsize with
   | True ->
     (match v with
      | I i -> I (Int.shl i amount)
      | Uns (p, n0) -> uns p (Z.add n0 (Int.unsigned amount))
      | Sgn (p, n0) -> sgn0 p (Z.add n0 (Int.unsigned amount))
      | _ -> ntop1 v)
   | False -> ntop1 v)
| _ -> ntop1 v

(** val shru1 : aval0 -> aval0 -> aval0 **)

let shru1 v = function
| I amount ->
  (match Int.ltu amount Int.iwordsize with
   | True ->
     (match v with
      | I i -> I (Int.shru i amount)
      | Uns (p, n0) -> uns p (Z.sub n0 (Int.unsigned amount))
      | _ -> uns (provenance v) (Z.sub Int.zwordsize (Int.unsigned amount)))
   | False -> ntop1 v)
| _ -> ntop1 v

(** val shr2 : aval0 -> aval0 -> aval0 **)

let shr2 v = function
| I amount ->
  (match Int.ltu amount Int.iwordsize with
   | True ->
     (match v with
      | I i -> I (Int.shr i amount)
      | Uns (p, n0) ->
        sgn0 p (Z.sub (Z.add n0 (Zpos XH)) (Int.unsigned amount))
      | Sgn (p, n0) -> sgn0 p (Z.sub n0 (Int.unsigned amount))
      | _ -> sgn0 (provenance v) (Z.sub Int.zwordsize (Int.unsigned amount)))
   | False -> ntop1 v)
| _ -> ntop1 v

(** val and1 : aval0 -> aval0 -> aval0 **)

let and1 v w =
  match v with
  | I i ->
    (match w with
     | I i0 -> I (Int.coq_and i i0)
     | Uns (p, n0) -> uns p (Z.min n0 (usize i))
     | _ -> uns (provenance w) (usize i))
  | Uns (p, n0) ->
    (match w with
     | I i -> uns p (Z.min n0 (usize i))
     | Uns (p0, n1) -> uns (plub p p0) (Z.min n0 n1)
     | _ -> uns (plub p (provenance w)) n0)
  | Sgn (p1, n1) ->
    (match w with
     | I i -> uns (provenance v) (usize i)
     | Uns (p, n0) -> uns (plub (provenance v) p) n0
     | Sgn (p2, n2) -> sgn0 (plub p1 p2) (Z.max n1 n2)
     | _ -> ntop2 v w)
  | _ ->
    (match w with
     | I i -> uns (provenance v) (usize i)
     | Uns (p, n0) -> uns (plub (provenance v) p) n0
     | _ -> ntop2 v w)

(** val or1 : aval0 -> aval0 -> aval0 **)

let or1 v w =
  match v with
  | I i ->
    (match w with
     | I i2 -> I (Int.coq_or i i2)
     | Uns (p, n0) -> uns p (Z.max n0 (usize i))
     | _ -> ntop2 v w)
  | Uns (p1, n1) ->
    (match w with
     | I i -> uns p1 (Z.max n1 (usize i))
     | Uns (p2, n2) -> uns (plub p1 p2) (Z.max n1 n2)
     | _ -> ntop2 v w)
  | Sgn (p1, n1) ->
    (match w with
     | Sgn (p2, n2) -> sgn0 (plub p1 p2) (Z.max n1 n2)
     | _ -> ntop2 v w)
  | _ -> ntop2 v w

(** val xor1 : aval0 -> aval0 -> aval0 **)

let xor1 v w =
  match v with
  | I i ->
    (match w with
     | I i2 -> I (Int.xor i i2)
     | Uns (p, n0) -> uns p (Z.max n0 (usize i))
     | _ -> ntop2 v w)
  | Uns (p1, n1) ->
    (match w with
     | I i -> uns p1 (Z.max n1 (usize i))
     | Uns (p2, n2) -> uns (plub p1 p2) (Z.max n1 n2)
     | _ -> ntop2 v w)
  | Sgn (p1, n1) ->
    (match w with
     | Sgn (p2, n2) -> sgn0 (plub p1 p2) (Z.max n1 n2)
     | _ -> ntop2 v w)
  | _ -> ntop2 v w

(** val notint1 : aval0 -> aval0 **)

let notint1 v = match v with
| I i -> I (Int.not i)
| Uns (p, n0) -> sgn0 p (Z.add n0 (Zpos XH))
| Sgn (p, n0) -> Sgn (p, n0)
| _ -> ntop1 v

(** val ror0 : aval0 -> aval0 -> aval0 **)

let ror0 x = function
| I j ->
  (match x with
   | I i ->
     (match Int.ltu j Int.iwordsize with
      | True -> I (Int.ror i j)
      | False -> ntop)
   | _ -> ntop1 x)
| _ -> ntop1 x

(** val neg0 : aval0 -> aval0 **)

let neg0 =
  unop_int Int.neg

(** val add1 : aval0 -> aval0 -> aval0 **)

let add1 x y =
  match x with
  | I i ->
    (match y with
     | I j -> I (Int.add i j)
     | Ptr p -> Ptr (padd p i)
     | Ifptr p -> Ifptr (padd p i)
     | _ -> ntop2 x y)
  | Ptr p ->
    (match y with
     | I i -> Ptr (padd p i)
     | _ -> Ptr (poffset p))
  | Ifptr p ->
    (match y with
     | I i -> Ifptr (padd p i)
     | Ptr p0 -> Ptr (poffset p0)
     | Ifptr p0 -> Ifptr (plub (poffset p) (poffset p0))
     | _ -> Ifptr (poffset p))
  | _ ->
    (match y with
     | Ptr p -> Ptr (poffset p)
     | Ifptr p -> Ifptr (poffset p)
     | _ -> ntop2 x y)

(** val sub1 : aval0 -> aval0 -> aval0 **)

let sub1 v w =
  match v with
  | I i1 ->
    (match w with
     | I i2 -> I (Int.sub i1 i2)
     | _ -> ntop2 v w)
  | Ptr p ->
    (match w with
     | I i -> Ptr (psub p i)
     | _ -> Ifptr (poffset p))
  | Ifptr p ->
    (match w with
     | I i -> Ifptr (psub p i)
     | _ -> Ifptr (plub (poffset p) (provenance w)))
  | _ -> ntop2 v w

(** val mul1 : aval0 -> aval0 -> aval0 **)

let mul1 =
  binop_int Int.mul

(** val mulhs0 : aval0 -> aval0 -> aval0 **)

let mulhs0 =
  binop_int Int.mulhs

(** val mulhu0 : aval0 -> aval0 -> aval0 **)

let mulhu0 =
  binop_int Int.mulhu

(** val divs1 : aval0 -> aval0 -> aval0 **)

let divs1 v w = match w with
| I i2 ->
  (match v with
   | I i1 ->
     (match match Int.eq i2 Int.zero with
            | True -> True
            | False ->
              (match Int.eq i1 (Int.repr Int.min_signed) with
               | True -> Int.eq i2 Int.mone
               | False -> False) with
      | True ->
        (match va_strict Tt with
         | True -> Vbot
         | False -> ntop)
      | False -> I (Int.divs i1 i2))
   | _ -> ntop2 v w)
| _ -> ntop2 v w

(** val divu1 : aval0 -> aval0 -> aval0 **)

let divu1 v w = match w with
| I i2 ->
  (match v with
   | I i1 ->
     (match Int.eq i2 Int.zero with
      | True ->
        (match va_strict Tt with
         | True -> Vbot
         | False -> ntop)
      | False -> I (Int.divu i1 i2))
   | _ -> ntop2 v w)
| _ -> ntop2 v w

(** val mods1 : aval0 -> aval0 -> aval0 **)

let mods1 v w = match w with
| I i2 ->
  (match v with
   | I i1 ->
     (match match Int.eq i2 Int.zero with
            | True -> True
            | False ->
              (match Int.eq i1 (Int.repr Int.min_signed) with
               | True -> Int.eq i2 Int.mone
               | False -> False) with
      | True ->
        (match va_strict Tt with
         | True -> Vbot
         | False -> ntop)
      | False -> I (Int.mods i1 i2))
   | _ -> ntop2 v w)
| _ -> ntop2 v w

(** val modu1 : aval0 -> aval0 -> aval0 **)

let modu1 v w = match w with
| I i2 ->
  (match v with
   | I i1 ->
     (match Int.eq i2 Int.zero with
      | True ->
        (match va_strict Tt with
         | True -> Vbot
         | False -> ntop)
      | False -> I (Int.modu i1 i2))
   | _ -> uns (provenance v) (usize i2))
| _ -> ntop2 v w

(** val shrx0 : aval0 -> aval0 -> aval0 **)

let shrx0 v w =
  match v with
  | I i ->
    (match w with
     | I j ->
       (match Int.ltu j (Int.repr (Zpos (XI (XI (XI (XI XH)))))) with
        | True -> I (Int.shrx i j)
        | False -> ntop)
     | _ -> ntop1 v)
  | _ -> ntop1 v

(** val negf1 : aval0 -> aval0 **)

let negf1 =
  unop_float Float.neg

(** val absf1 : aval0 -> aval0 **)

let absf1 =
  unop_float Float.abs

(** val addf1 : aval0 -> aval0 -> aval0 **)

let addf1 =
  binop_float Float.add

(** val subf1 : aval0 -> aval0 -> aval0 **)

let subf1 =
  binop_float Float.sub

(** val mulf1 : aval0 -> aval0 -> aval0 **)

let mulf1 =
  binop_float Float.mul

(** val divf1 : aval0 -> aval0 -> aval0 **)

let divf1 =
  binop_float Float.div

(** val negfs1 : aval0 -> aval0 **)

let negfs1 =
  unop_single Float32.neg

(** val absfs1 : aval0 -> aval0 **)

let absfs1 =
  unop_single Float32.abs

(** val addfs1 : aval0 -> aval0 -> aval0 **)

let addfs1 =
  binop_single Float32.add

(** val subfs1 : aval0 -> aval0 -> aval0 **)

let subfs1 =
  binop_single Float32.sub

(** val mulfs1 : aval0 -> aval0 -> aval0 **)

let mulfs1 =
  binop_single Float32.mul

(** val divfs1 : aval0 -> aval0 -> aval0 **)

let divfs1 =
  binop_single Float32.div

(** val zero_ext0 : z -> aval0 -> aval0 **)

let zero_ext0 nbits v = match v with
| I i -> I (Int.zero_ext nbits i)
| Uns (p, n0) -> uns p (Z.min n0 nbits)
| _ -> uns (provenance v) nbits

(** val sign_ext0 : z -> aval0 -> aval0 **)

let sign_ext0 nbits v = match v with
| I i -> I (Int.sign_ext nbits i)
| Uns (p, n0) ->
  (match zlt n0 nbits with
   | Left -> Uns (p, n0)
   | Right -> sgn0 p nbits)
| Sgn (p, n0) -> sgn0 p (Z.min n0 nbits)
| _ -> sgn0 (provenance v) nbits

(** val singleoffloat1 : aval0 -> aval0 **)

let singleoffloat1 v = match v with
| F f -> FS (Float.to_single f)
| _ -> ntop1 v

(** val floatofsingle1 : aval0 -> aval0 **)

let floatofsingle1 v = match v with
| FS f -> F (Float.of_single f)
| _ -> ntop1 v

(** val intoffloat1 : aval0 -> aval0 **)

let intoffloat1 x = match x with
| F f ->
  (match Float.to_int f with
   | Some i -> I i
   | None ->
     (match va_strict Tt with
      | True -> Vbot
      | False -> ntop))
| _ -> ntop1 x

(** val floatofint1 : aval0 -> aval0 **)

let floatofint1 x = match x with
| I i -> F (Float.of_int i)
| _ -> ntop1 x

(** val intofsingle1 : aval0 -> aval0 **)

let intofsingle1 x = match x with
| FS f ->
  (match Float32.to_int f with
   | Some i -> I i
   | None ->
     (match va_strict Tt with
      | True -> Vbot
      | False -> ntop))
| _ -> ntop1 x

(** val singleofint1 : aval0 -> aval0 **)

let singleofint1 x = match x with
| I i -> FS (Float32.of_int i)
| _ -> ntop1 x

(** val longofwords0 : aval0 -> aval0 -> aval0 **)

let longofwords0 x y = match y with
| I j ->
  (match x with
   | I i -> L (Int64.ofwords i j)
   | _ -> ntop2 x y)
| _ -> ntop2 x y

(** val loword0 : aval0 -> aval0 **)

let loword0 x = match x with
| L i -> I (Int64.loword i)
| _ -> ntop1 x

(** val hiword0 : aval0 -> aval0 **)

let hiword0 x = match x with
| L i -> I (Int64.hiword i)
| _ -> ntop1 x

(** val cmp_intv : comparison0 -> (z, z) prod -> z -> abool **)

let cmp_intv c i n0 =
  let Pair (lo, hi) = i in
  (match c with
   | Ceq ->
     (match match proj_sumbool (zlt n0 lo) with
            | True -> True
            | False -> proj_sumbool (zlt hi n0) with
      | True -> Maybe False
      | False -> Btop)
   | Cne -> Btop
   | Clt ->
     (match zlt hi n0 with
      | Left -> Maybe True
      | Right ->
        (match zle n0 lo with
         | Left -> Maybe False
         | Right -> Btop))
   | Cle ->
     (match zle hi n0 with
      | Left -> Maybe True
      | Right ->
        (match zlt n0 lo with
         | Left -> Maybe False
         | Right -> Btop))
   | Cgt ->
     (match zlt n0 lo with
      | Left -> Maybe True
      | Right ->
        (match zle hi n0 with
         | Left -> Maybe False
         | Right -> Btop))
   | Cge ->
     (match zle n0 lo with
      | Left -> Maybe True
      | Right ->
        (match zlt hi n0 with
         | Left -> Maybe False
         | Right -> Btop)))

(** val uintv : aval0 -> (z, z) prod **)

let uintv = function
| I n0 -> Pair ((Int.unsigned n0), (Int.unsigned n0))
| Uns (p, n0) ->
  (match zlt n0 Int.zwordsize with
   | Left -> Pair (Z0, (Z.sub (two_p n0) (Zpos XH)))
   | Right -> Pair (Z0, Int.max_unsigned))
| _ -> Pair (Z0, Int.max_unsigned)

(** val sintv : aval0 -> (z, z) prod **)

let sintv = function
| I n0 -> Pair ((Int.signed n0), (Int.signed n0))
| Uns (p, n0) ->
  (match zlt n0 Int.zwordsize with
   | Left -> Pair (Z0, (Z.sub (two_p n0) (Zpos XH)))
   | Right -> Pair (Int.min_signed, Int.max_signed))
| Sgn (p, n0) ->
  (match zlt n0 Int.zwordsize with
   | Left ->
     let x = two_p (Z.sub n0 (Zpos XH)) in
     Pair ((Z.opp x), (Z.sub x (Zpos XH)))
   | Right -> Pair (Int.min_signed, Int.max_signed))
| _ -> Pair (Int.min_signed, Int.max_signed)

(** val cmpu_bool0 : comparison0 -> aval0 -> aval0 -> abool **)

let cmpu_bool0 c v w =
  match v with
  | I i ->
    (match w with
     | I i0 -> Just (Int.cmpu c i i0)
     | Ptr p -> cmp_different_blocks0 c
     | _ ->
       club (cmp_intv (swap_comparison c) (uintv w) (Int.unsigned i))
         (cmp_different_blocks0 c))
  | Uns (p1, n0) ->
    (match w with
     | I i ->
       club (cmp_intv c (uintv v) (Int.unsigned i)) (cmp_different_blocks0 c)
     | Ptr p2 -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | _ -> Btop)
  | Sgn (p1, n0) ->
    (match w with
     | I i ->
       club (cmp_intv c (uintv v) (Int.unsigned i)) (cmp_different_blocks0 c)
     | Ptr p2 -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | _ -> Btop)
  | Ptr p1 ->
    (match w with
     | I i -> cmp_different_blocks0 c
     | Uns (p2, n0) -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | Sgn (p2, n0) -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | Ptr p2 -> pcmp c p1 p2
     | Ifptr p2 -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | _ -> Btop)
  | Ifptr p1 ->
    (match w with
     | I i ->
       club (cmp_intv c (uintv v) (Int.unsigned i)) (cmp_different_blocks0 c)
     | Ptr p2 -> club (pcmp c p1 p2) (cmp_different_blocks0 c)
     | _ -> Btop)
  | _ ->
    (match w with
     | I i ->
       club (cmp_intv c (uintv v) (Int.unsigned i)) (cmp_different_blocks0 c)
     | _ -> Btop)

(** val cmp_bool0 : comparison0 -> aval0 -> aval0 -> abool **)

let cmp_bool0 c v w =
  match v with
  | I i ->
    (match w with
     | I i0 -> Just (Int.cmp c i i0)
     | _ -> cmp_intv (swap_comparison c) (sintv w) (Int.signed i))
  | _ ->
    (match w with
     | I i -> cmp_intv c (sintv v) (Int.signed i)
     | _ -> Btop)

(** val cmpf_bool0 : comparison0 -> aval0 -> aval0 -> abool **)

let cmpf_bool0 c v w =
  match v with
  | F f1 ->
    (match w with
     | F f2 -> Just (Float.cmp c f1 f2)
     | _ -> Btop)
  | _ -> Btop

(** val cmpfs_bool0 : comparison0 -> aval0 -> aval0 -> abool **)

let cmpfs_bool0 c v w =
  match v with
  | FS f1 ->
    (match w with
     | FS f2 -> Just (Float32.cmp c f1 f2)
     | _ -> Btop)
  | _ -> Btop

(** val maskzero : aval0 -> Int.int -> abool **)

let maskzero x mask0 =
  match x with
  | I i -> Just (Int.eq (Int.coq_and i mask0) Int.zero)
  | Uns (p, n0) ->
    (match Int.eq (Int.zero_ext n0 mask0) Int.zero with
     | True -> Maybe True
     | False -> Btop)
  | _ -> Btop

(** val of_optbool0 : abool -> aval0 **)

let of_optbool0 = function
| Just b ->
  I
    (match b with
     | True -> Int.one
     | False -> Int.zero)
| _ -> Uns (Pbot, (Zpos XH))

(** val resolve_branch : abool -> bool option **)

let resolve_branch = function
| Just b -> Some b
| Maybe b -> Some b
| _ -> None

(** val vnormalize : memory_chunk -> aval0 -> aval0 **)

let vnormalize chunk v =
  match chunk with
  | Mint8signed ->
    (match v with
     | Vbot -> Vbot
     | I i -> I (Int.sign_ext (Zpos (XO (XO (XO XH)))) i)
     | Uns (p, n0) ->
       (match zlt n0 (Zpos (XO (XO (XO XH)))) with
        | Left -> Uns ((provenance v), n0)
        | Right -> Sgn ((provenance v), (Zpos (XO (XO (XO XH))))))
     | Sgn (p, n0) ->
       Sgn ((provenance v), (Z.min n0 (Zpos (XO (XO (XO XH))))))
     | _ -> Sgn ((provenance v), (Zpos (XO (XO (XO XH))))))
  | Mint8unsigned ->
    (match v with
     | Vbot -> Vbot
     | I i -> I (Int.zero_ext (Zpos (XO (XO (XO XH)))) i)
     | Uns (p, n0) ->
       Uns ((provenance v), (Z.min n0 (Zpos (XO (XO (XO XH))))))
     | _ -> Uns ((provenance v), (Zpos (XO (XO (XO XH))))))
  | Mint16signed ->
    (match v with
     | Vbot -> Vbot
     | I i -> I (Int.sign_ext (Zpos (XO (XO (XO (XO XH))))) i)
     | Uns (p, n0) ->
       (match zlt n0 (Zpos (XO (XO (XO (XO XH))))) with
        | Left -> Uns ((provenance v), n0)
        | Right -> Sgn ((provenance v), (Zpos (XO (XO (XO (XO XH)))))))
     | Sgn (p, n0) ->
       Sgn ((provenance v), (Z.min n0 (Zpos (XO (XO (XO (XO XH)))))))
     | _ -> Sgn ((provenance v), (Zpos (XO (XO (XO (XO XH)))))))
  | Mint16unsigned ->
    (match v with
     | Vbot -> Vbot
     | I i -> I (Int.zero_ext (Zpos (XO (XO (XO (XO XH))))) i)
     | Uns (p, n0) ->
       Uns ((provenance v), (Z.min n0 (Zpos (XO (XO (XO (XO XH)))))))
     | _ -> Uns ((provenance v), (Zpos (XO (XO (XO (XO XH)))))))
  | Mint32 ->
    (match v with
     | Vbot -> Vbot
     | L n0 -> Ifptr (provenance v)
     | F f -> Ifptr (provenance v)
     | FS f -> Ifptr (provenance v)
     | _ -> v)
  | Mint64 ->
    (match v with
     | Vbot -> Vbot
     | Uns (p, n0) ->
       Ifptr
         (match va_strict Tt with
          | True -> Pbot
          | False -> p)
     | Sgn (p, n0) ->
       Ifptr
         (match va_strict Tt with
          | True -> Pbot
          | False -> p)
     | L n0 -> v
     | Ptr p ->
       Ifptr
         (match va_strict Tt with
          | True -> Pbot
          | False -> p)
     | Ifptr p ->
       Ifptr
         (match va_strict Tt with
          | True -> Pbot
          | False -> p)
     | _ -> Ifptr (provenance v))
  | Mfloat32 ->
    (match v with
     | Vbot -> Vbot
     | FS f -> v
     | _ -> Ifptr (provenance v))
  | Mfloat64 ->
    (match v with
     | Vbot -> Vbot
     | F f -> v
     | _ -> Ifptr (provenance v))
  | Many32 ->
    (match v with
     | Vbot -> Vbot
     | L n0 -> Ifptr (provenance v)
     | F f -> Ifptr (provenance v)
     | _ -> v)
  | Many64 ->
    (match v with
     | Vbot -> Vbot
     | _ -> v)

type acontent =
| ACany
| ACval of memory_chunk * aval0

(** val eq_acontent : acontent -> acontent -> sumbool **)

let eq_acontent c1 c2 =
  match c1 with
  | ACany ->
    (match c2 with
     | ACany -> Left
     | ACval (chunk, av) -> Right)
  | ACval (x, x0) ->
    (match c2 with
     | ACany -> Right
     | ACval (chunk0, av0) ->
       (match chunk_eq x chunk0 with
        | Left -> eq_aval x0 av0
        | Right -> Right))

type ablock = { ab_contents : acontent ZMap.t; ab_summary : aptr }

(** val ab_contents : ablock -> acontent ZMap.t **)

let ab_contents x = x.ab_contents

(** val ab_summary : ablock -> aptr **)

let ab_summary x = x.ab_summary

(** val ablock_init : aptr -> ablock **)

let ablock_init p =
  { ab_contents = (ZMap.init ACany); ab_summary = p }

(** val chunk_compat : memory_chunk -> memory_chunk -> bool **)

let chunk_compat chunk chunk' =
  match chunk with
  | Mint8signed ->
    (match chunk' with
     | Mint8signed -> True
     | Mint8unsigned -> True
     | _ -> False)
  | Mint8unsigned ->
    (match chunk' with
     | Mint8signed -> True
     | Mint8unsigned -> True
     | _ -> False)
  | Mint32 ->
    (match chunk' with
     | Mint32 -> True
     | _ -> False)
  | Mint64 ->
    (match chunk' with
     | Mint64 -> True
     | _ -> False)
  | Mfloat32 ->
    (match chunk' with
     | Mfloat32 -> True
     | _ -> False)
  | Mfloat64 ->
    (match chunk' with
     | Mfloat64 -> True
     | _ -> False)
  | Many32 ->
    (match chunk' with
     | Many32 -> True
     | _ -> False)
  | Many64 ->
    (match chunk' with
     | Many64 -> True
     | _ -> False)
  | _ ->
    (match chunk' with
     | Mint16signed -> True
     | Mint16unsigned -> True
     | _ -> False)

(** val ablock_load : memory_chunk -> ablock -> z -> aval0 **)

let ablock_load chunk ab i =
  match ZMap.get i ab.ab_contents with
  | ACany -> vnormalize chunk (Ifptr ab.ab_summary)
  | ACval (chunk', av) ->
    (match chunk_compat chunk chunk' with
     | True -> vnormalize chunk av
     | False -> vnormalize chunk (Ifptr ab.ab_summary))

(** val ablock_load_anywhere : memory_chunk -> ablock -> aval0 **)

let ablock_load_anywhere chunk ab =
  vnormalize chunk (Ifptr ab.ab_summary)

(** val inval_after : z -> z -> acontent ZMap.t -> acontent ZMap.t **)

let rec inval_after lo hi c =
  match zle lo hi with
  | Left -> inval_after lo (Z.sub hi (Zpos XH)) (ZMap.set hi ACany c)
  | Right -> c

(** val inval_if : z -> z -> acontent ZMap.t -> acontent ZMap.t **)

let inval_if hi lo c =
  match ZMap.get lo c with
  | ACany -> c
  | ACval (chunk, av) ->
    (match zle (Z.add lo (size_chunk chunk)) hi with
     | Left -> c
     | Right -> ZMap.set lo ACany c)

(** val inval_before : z -> z -> acontent ZMap.t -> acontent ZMap.t **)

let rec inval_before hi lo c =
  match zlt lo hi with
  | Left -> inval_before hi (Z.add lo (Zpos XH)) (inval_if hi lo c)
  | Right -> c

(** val ablock_store : memory_chunk -> ablock -> z -> aval0 -> ablock **)

let ablock_store chunk ab i av =
  { ab_contents =
    (ZMap.set i (ACval (chunk, av))
      (inval_before i (Z.sub i (Zpos (XI (XI XH))))
        (inval_after (Z.add i (Zpos XH))
          (Z.sub (Z.add i (size_chunk chunk)) (Zpos XH)) ab.ab_contents)));
    ab_summary = (vplub av ab.ab_summary) }

(** val ablock_store_anywhere : memory_chunk -> ablock -> aval0 -> ablock **)

let ablock_store_anywhere chunk ab av =
  ablock_init (vplub av ab.ab_summary)

(** val ablock_loadbytes : ablock -> aptr **)

let ablock_loadbytes ab =
  ab.ab_summary

(** val ablock_storebytes : ablock -> aptr -> z -> z -> ablock **)

let ablock_storebytes ab p ofs sz =
  { ab_contents =
    (inval_before ofs (Z.sub ofs (Zpos (XI (XI XH))))
      (inval_after ofs (Z.sub (Z.add ofs sz) (Zpos XH)) ab.ab_contents));
    ab_summary = (plub p ab.ab_summary) }

(** val ablock_storebytes_anywhere : ablock -> aptr -> ablock **)

let ablock_storebytes_anywhere ab p =
  ablock_init (plub p ab.ab_summary)

(** val bbeq : ablock -> ablock -> bool **)

let bbeq ab1 ab2 =
  match proj_sumbool (eq_aptr ab1.ab_summary ab2.ab_summary) with
  | True ->
    PTree.beq (fun c1 c2 -> proj_sumbool (eq_acontent c1 c2))
      (snd ab1.ab_contents) (snd ab2.ab_contents)
  | False -> False

(** val combine_acontents_opt :
    acontent option -> acontent option -> acontent option **)

let combine_acontents_opt c1 c2 =
  match c1 with
  | Some a ->
    (match a with
     | ACany -> None
     | ACval (chunk1, v1) ->
       (match c2 with
        | Some a0 ->
          (match a0 with
           | ACany -> None
           | ACval (chunk2, v2) ->
             (match chunk_eq chunk1 chunk2 with
              | Left -> Some (ACval (chunk1, (vlub v1 v2)))
              | Right -> None))
        | None -> None))
  | None -> None

(** val combine_contentmaps :
    acontent ZMap.t -> acontent ZMap.t -> acontent ZMap.t **)

let combine_contentmaps m1 m2 =
  Pair (ACany, (PTree.combine combine_acontents_opt (snd m1) (snd m2)))

(** val blub : ablock -> ablock -> ablock **)

let blub ab1 ab2 =
  { ab_contents = (combine_contentmaps ab1.ab_contents ab2.ab_contents);
    ab_summary = (plub ab1.ab_summary ab2.ab_summary) }

type romem = ablock PTree.t

type amem = { am_stack : ablock; am_glob : ablock PTree.t;
              am_nonstack : aptr; am_top : aptr }

(** val am_stack : amem -> ablock **)

let am_stack x = x.am_stack

(** val am_glob : amem -> ablock PTree.t **)

let am_glob x = x.am_glob

(** val am_nonstack : amem -> aptr **)

let am_nonstack x = x.am_nonstack

(** val am_top : amem -> aptr **)

let am_top x = x.am_top

(** val minit : aptr -> amem **)

let minit p =
  { am_stack = (ablock_init p); am_glob = PTree.empty; am_nonstack = p;
    am_top = p }

(** val mtop : amem **)

let mtop =
  minit Ptop

(** val load1 : memory_chunk -> romem -> amem -> aptr -> aval0 **)

let load1 chunk rm m0 = function
| Pbot ->
  (match va_strict Tt with
   | True -> Vbot
   | False -> vtop)
| Gl (id, ofs) ->
  (match PTree.get id rm with
   | Some ab -> ablock_load chunk ab (Int.unsigned ofs)
   | None ->
     (match PTree.get id m0.am_glob with
      | Some ab -> ablock_load chunk ab (Int.unsigned ofs)
      | None -> vnormalize chunk (Ifptr m0.am_nonstack)))
| Glo id ->
  (match PTree.get id rm with
   | Some ab -> ablock_load_anywhere chunk ab
   | None ->
     (match PTree.get id m0.am_glob with
      | Some ab -> ablock_load_anywhere chunk ab
      | None -> vnormalize chunk (Ifptr m0.am_nonstack)))
| Stk ofs -> ablock_load chunk m0.am_stack (Int.unsigned ofs)
| Stack -> ablock_load_anywhere chunk m0.am_stack
| Ptop -> vnormalize chunk (Ifptr m0.am_top)
| _ -> vnormalize chunk (Ifptr m0.am_nonstack)

(** val loadv0 : memory_chunk -> romem -> amem -> aval0 -> aval0 **)

let loadv0 chunk rm m0 addr =
  load1 chunk rm m0 (aptr_of_aval addr)

(** val store1 : memory_chunk -> amem -> aptr -> aval0 -> amem **)

let store1 chunk m0 p av =
  { am_stack =
    (match p with
     | Stk ofs -> ablock_store chunk m0.am_stack (Int.unsigned ofs) av
     | Stack -> ablock_store_anywhere chunk m0.am_stack av
     | Ptop -> ablock_store_anywhere chunk m0.am_stack av
     | _ -> m0.am_stack); am_glob =
    (match p with
     | Gl (id, ofs) ->
       let ab =
         match PTree.get id m0.am_glob with
         | Some ab -> ab
         | None -> ablock_init m0.am_nonstack
       in
       PTree.set id (ablock_store chunk ab (Int.unsigned ofs) av) m0.am_glob
     | Glo id ->
       let ab =
         match PTree.get id m0.am_glob with
         | Some ab -> ab
         | None -> ablock_init m0.am_nonstack
       in
       PTree.set id (ablock_store_anywhere chunk ab av) m0.am_glob
     | Glob -> PTree.empty
     | Nonstack -> PTree.empty
     | Ptop -> PTree.empty
     | _ -> m0.am_glob); am_nonstack =
    (match p with
     | Pbot -> m0.am_nonstack
     | Stk ofs -> m0.am_nonstack
     | Stack -> m0.am_nonstack
     | _ -> vplub av m0.am_nonstack); am_top = (vplub av m0.am_top) }

(** val storev0 : memory_chunk -> amem -> aval0 -> aval0 -> amem **)

let storev0 chunk m0 addr v =
  store1 chunk m0 (aptr_of_aval addr) v

(** val loadbytes0 : amem -> romem -> aptr -> aptr **)

let loadbytes0 m0 rm = function
| Pbot ->
  (match va_strict Tt with
   | True -> Pbot
   | False -> Ptop)
| Gl (id, ofs) ->
  (match PTree.get id rm with
   | Some ab -> ablock_loadbytes ab
   | None ->
     (match PTree.get id m0.am_glob with
      | Some ab -> ablock_loadbytes ab
      | None -> m0.am_nonstack))
| Glo id ->
  (match PTree.get id rm with
   | Some ab -> ablock_loadbytes ab
   | None ->
     (match PTree.get id m0.am_glob with
      | Some ab -> ablock_loadbytes ab
      | None -> m0.am_nonstack))
| Glob -> m0.am_nonstack
| Nonstack -> m0.am_nonstack
| Ptop -> m0.am_top
| _ -> ablock_loadbytes m0.am_stack

(** val storebytes0 : amem -> aptr -> z -> aptr -> amem **)

let storebytes0 m0 dst sz p =
  { am_stack =
    (match dst with
     | Stk ofs -> ablock_storebytes m0.am_stack p (Int.unsigned ofs) sz
     | Stack -> ablock_storebytes_anywhere m0.am_stack p
     | Ptop -> ablock_storebytes_anywhere m0.am_stack p
     | _ -> m0.am_stack); am_glob =
    (match dst with
     | Gl (id, ofs) ->
       let ab =
         match PTree.get id m0.am_glob with
         | Some ab -> ab
         | None -> ablock_init m0.am_nonstack
       in
       PTree.set id (ablock_storebytes ab p (Int.unsigned ofs) sz) m0.am_glob
     | Glo id ->
       let ab =
         match PTree.get id m0.am_glob with
         | Some ab -> ab
         | None -> ablock_init m0.am_nonstack
       in
       PTree.set id (ablock_storebytes_anywhere ab p) m0.am_glob
     | Glob -> PTree.empty
     | Nonstack -> PTree.empty
     | Ptop -> PTree.empty
     | _ -> m0.am_glob); am_nonstack =
    (match dst with
     | Pbot -> m0.am_nonstack
     | Stk ofs -> m0.am_nonstack
     | Stack -> m0.am_nonstack
     | _ -> plub p m0.am_nonstack); am_top = (plub p m0.am_top) }

(** val mbeq : amem -> amem -> bool **)

let mbeq m1 m2 =
  match match match proj_sumbool (eq_aptr m1.am_top m2.am_top) with
              | True -> proj_sumbool (eq_aptr m1.am_nonstack m2.am_nonstack)
              | False -> False with
        | True -> bbeq m1.am_stack m2.am_stack
        | False -> False with
  | True -> PTree.beq bbeq m1.am_glob m2.am_glob
  | False -> False

(** val combine_ablock : ablock option -> ablock option -> ablock option **)

let combine_ablock ob1 ob2 =
  match ob1 with
  | Some b1 ->
    (match ob2 with
     | Some b2 -> Some (blub b1 b2)
     | None -> None)
  | None -> None

(** val mlub : amem -> amem -> amem **)

let mlub m1 m2 =
  { am_stack = (blub m1.am_stack m2.am_stack); am_glob =
    (PTree.combine combine_ablock m1.am_glob m2.am_glob); am_nonstack =
    (plub m1.am_nonstack m2.am_nonstack); am_top =
    (plub m1.am_top m2.am_top) }

module AVal = 
 struct 
  type t = aval0
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    proj_sumbool (eq_aval x y)
  
  (** val bot : t **)
  
  let bot =
    Vbot
  
  (** val top : t **)
  
  let top =
    vtop
  
  (** val lub : aval0 -> aval0 -> aval0 **)
  
  let lub =
    vlub
 end

module AE = LPMap(AVal)

type aenv = AE.t

(** val einit_regs : reg list -> aenv **)

let rec einit_regs = function
| Nil -> AE.top
| Cons (r1, rs) -> AE.set r1 (Ifptr Nonstack) (einit_regs rs)

(** val eforget : reg list -> aenv -> aenv **)

let rec eforget rl ae =
  match rl with
  | Nil -> ae
  | Cons (r1, rs) -> eforget rs (AE.set r1 vtop ae)

module VA = 
 struct 
  type t' =
  | Bot
  | State of aenv * amem
  
  (** val t'_rect : 'a1 -> (aenv -> amem -> 'a1) -> t' -> 'a1 **)
  
  let t'_rect f f0 = function
  | Bot -> f
  | State (x, x0) -> f0 x x0
  
  (** val t'_rec : 'a1 -> (aenv -> amem -> 'a1) -> t' -> 'a1 **)
  
  let t'_rec f f0 = function
  | Bot -> f
  | State (x, x0) -> f0 x x0
  
  type t = t'
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    match x with
    | Bot ->
      (match y with
       | Bot -> True
       | State (ae, am) -> False)
    | State (ae1, am1) ->
      (match y with
       | Bot -> False
       | State (ae2, am2) ->
         (match AE.beq ae1 ae2 with
          | True -> mbeq am1 am2
          | False -> False))
  
  (** val bot : t **)
  
  let bot =
    Bot
  
  (** val lub : t -> t -> t **)
  
  let lub x y =
    match x with
    | Bot -> y
    | State (ae1, am1) ->
      (match y with
       | Bot -> x
       | State (ae2, am2) -> State ((AE.lub ae1 ae2), (mlub am1 am2)))
 end

(** val eval_static_condition : condition -> aval0 list -> abool **)

let eval_static_condition cond vl =
  match cond with
  | Ccomp c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cmp_bool0 c v1 v2
           | Cons (a, l1) -> Bnone)))
  | Ccompu c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cmpu_bool0 c v1 v2
           | Cons (a, l1) -> Bnone)))
  | Ccompimm (c, n0) ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> cmp_bool0 c v1 (I n0)
        | Cons (a, l0) -> Bnone))
  | Ccompuimm (c, n0) ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> cmpu_bool0 c v1 (I n0)
        | Cons (a, l0) -> Bnone))
  | Ccompf c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cmpf_bool0 c v1 v2
           | Cons (a, l1) -> Bnone)))
  | Cnotcompf c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cnot (cmpf_bool0 c v1 v2)
           | Cons (a, l1) -> Bnone)))
  | Ccompfs c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cmpfs_bool0 c v1 v2
           | Cons (a, l1) -> Bnone)))
  | Cnotcompfs c ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> Bnone
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> cnot (cmpfs_bool0 c v1 v2)
           | Cons (a, l1) -> Bnone)))
  | Cmaskzero n0 ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> maskzero v1 n0
        | Cons (a, l0) -> Bnone))
  | Cmasknotzero n0 ->
    (match vl with
     | Nil -> Bnone
     | Cons (v1, l) ->
       (match l with
        | Nil -> cnot (maskzero v1 n0)
        | Cons (a, l0) -> Bnone))

(** val eval_static_addressing : addressing -> aval0 list -> aval0 **)

let eval_static_addressing addr vl =
  match addr with
  | Aindexed n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> add1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Aindexed2 n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> add1 (add1 v1 v2) (I n0)
           | Cons (a, l1) -> Vbot)))
  | Ascaled (sc, ofs) ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> add1 (mul1 v1 (I sc)) (I ofs)
        | Cons (a, l0) -> Vbot))
  | Aindexed2scaled (sc, ofs) ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> add1 v1 (add1 (mul1 v2 (I sc)) (I ofs))
           | Cons (a, l1) -> Vbot)))
  | Aglobal (s, ofs) ->
    (match vl with
     | Nil -> Ptr (Gl (s, ofs))
     | Cons (a, l) -> Vbot)
  | Abased (s, ofs) ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> add1 (Ptr (Gl (s, ofs))) v1
        | Cons (a, l0) -> Vbot))
  | Abasedscaled (sc, s, ofs) ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> add1 (Ptr (Gl (s, ofs))) (mul1 v1 (I sc))
        | Cons (a, l0) -> Vbot))
  | Ainstack ofs ->
    (match vl with
     | Nil -> Ptr (Stk ofs)
     | Cons (a, l) -> Vbot)

(** val eval_static_operation : operation -> aval0 list -> aval0 **)

let eval_static_operation op vl =
  match op with
  | Omove ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> v1
        | Cons (a, l0) -> Vbot))
  | Ointconst1 n0 ->
    (match vl with
     | Nil -> I n0
     | Cons (a, l) -> Vbot)
  | Ofloatconst1 n0 ->
    (match vl with
     | Nil ->
       (match propagate_float_constants Tt with
        | True -> F n0
        | False -> ntop)
     | Cons (a, l) -> Vbot)
  | Osingleconst1 n0 ->
    (match vl with
     | Nil ->
       (match propagate_float_constants Tt with
        | True -> FS n0
        | False -> ntop)
     | Cons (a, l) -> Vbot)
  | Oindirectsymbol id ->
    (match vl with
     | Nil -> Ifptr (Gl (id, Int.zero))
     | Cons (a, l) -> Vbot)
  | Ocast8signed0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> sign_ext0 (Zpos (XO (XO (XO XH)))) v1
        | Cons (a, l0) -> Vbot))
  | Ocast8unsigned0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> zero_ext0 (Zpos (XO (XO (XO XH)))) v1
        | Cons (a, l0) -> Vbot))
  | Ocast16signed0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> sign_ext0 (Zpos (XO (XO (XO (XO XH))))) v1
        | Cons (a, l0) -> Vbot))
  | Ocast16unsigned0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> zero_ext0 (Zpos (XO (XO (XO (XO XH))))) v1
        | Cons (a, l0) -> Vbot))
  | Oneg0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> neg0 v1
        | Cons (a, l0) -> Vbot))
  | Osub1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> sub1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omul1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mul1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omulimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> mul1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Omulhs ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mulhs0 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omulhu ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mulhu0 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Odiv1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> divs1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Odivu0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> divu1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omod1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mods1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omodu0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> modu1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oand1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> and1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oandimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> and1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oor1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> or1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oorimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> or1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oxor1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> xor1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oxorimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> xor1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Onot ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> notint1 v1
        | Cons (a, l0) -> Vbot))
  | Oshl1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> shl1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oshlimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> shl1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oshr1 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> shr2 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oshrimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> shr2 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oshrximm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> shrx0 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oshru0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> shru1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Oshruimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> shru1 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Ororimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> ror0 v1 (I n0)
        | Cons (a, l0) -> Vbot))
  | Oshldimm n0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil ->
             or1 (shl1 v1 (I n0)) (shru1 v2 (I (Int.sub Int.iwordsize n0)))
           | Cons (a, l1) -> Vbot)))
  | Olea addr -> eval_static_addressing addr vl
  | Onegf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> negf1 v1
        | Cons (a, l0) -> Vbot))
  | Oabsf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> absf1 v1
        | Cons (a, l0) -> Vbot))
  | Oaddf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> addf1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Osubf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> subf1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omulf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mulf1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Odivf0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> divf1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Onegfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> negfs1 v1
        | Cons (a, l0) -> Vbot))
  | Oabsfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> absfs1 v1
        | Cons (a, l0) -> Vbot))
  | Oaddfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> addfs1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Osubfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> subfs1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Omulfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> mulfs1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Odivfs0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> divfs1 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Osingleoffloat0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> singleoffloat1 v1
        | Cons (a, l0) -> Vbot))
  | Ofloatofsingle0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> floatofsingle1 v1
        | Cons (a, l0) -> Vbot))
  | Ointoffloat0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> intoffloat1 v1
        | Cons (a, l0) -> Vbot))
  | Ofloatofint0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> floatofint1 v1
        | Cons (a, l0) -> Vbot))
  | Ointofsingle0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> intofsingle1 v1
        | Cons (a, l0) -> Vbot))
  | Osingleofint0 ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> singleofint1 v1
        | Cons (a, l0) -> Vbot))
  | Omakelong ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> Vbot
        | Cons (v2, l0) ->
          (match l0 with
           | Nil -> longofwords0 v1 v2
           | Cons (a, l1) -> Vbot)))
  | Olowlong ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> loword0 v1
        | Cons (a, l0) -> Vbot))
  | Ohighlong ->
    (match vl with
     | Nil -> Vbot
     | Cons (v1, l) ->
       (match l with
        | Nil -> hiword0 v1
        | Cons (a, l0) -> Vbot))
  | Ocmp0 c -> of_optbool0 (eval_static_condition c vl)

(** val areg : aenv -> reg -> aval0 **)

let areg ae r =
  AE.get r ae

(** val aregs : aenv -> reg list -> aval0 list **)

let aregs ae rl =
  map (areg ae) rl

(** val mafter_public_call : amem **)

let mafter_public_call =
  mtop

(** val mafter_private_call : amem -> amem **)

let mafter_private_call am_before =
  { am_stack = am_before.am_stack; am_glob = PTree.empty; am_nonstack =
    Nonstack; am_top = (plub am_before.am_stack.ab_summary Nonstack) }

(** val analyze_call : amem -> aval0 list -> (aval0, amem) prod **)

let analyze_call am aargs =
  match match pincl am.am_nonstack Nonstack with
        | True -> forallb (fun av -> vpincl av Nonstack) aargs
        | False -> False with
  | True -> Pair ((Ifptr Nonstack), (mafter_private_call am))
  | False -> Pair (vtop, mafter_public_call)

(** val transfer_call : aenv -> amem -> reg list -> reg -> VA.t' **)

let transfer_call ae am args res2 =
  let Pair (av, am') = analyze_call am (aregs ae args) in
  VA.State ((AE.set res2 av ae), am')

(** val abuiltin_arg : aenv -> amem -> romem -> reg builtin_arg -> aval0 **)

let rec abuiltin_arg ae am rm = function
| BA r -> areg ae r
| BA_int n0 -> I n0
| BA_long n0 -> L n0
| BA_float n0 -> F n0
| BA_single n0 -> FS n0
| BA_loadstack (chunk, ofs) -> loadv0 chunk rm am (Ptr (Stk ofs))
| BA_addrstack ofs -> Ptr (Stk ofs)
| BA_loadglobal (chunk, id, ofs) -> loadv0 chunk rm am (Ptr (Gl (id, ofs)))
| BA_addrglobal (id, ofs) -> Ptr (Gl (id, ofs))
| BA_splitlong (hi, lo) ->
  longofwords0 (abuiltin_arg ae am rm hi) (abuiltin_arg ae am rm lo)

(** val set_builtin_res : reg builtin_res -> aval0 -> aenv -> aenv **)

let set_builtin_res br av ae =
  match br with
  | BR r -> AE.set r av ae
  | _ -> ae

(** val transfer_builtin_default :
    aenv -> amem -> romem -> reg builtin_arg list -> reg builtin_res -> VA.t' **)

let transfer_builtin_default ae am rm args res2 =
  let Pair (av, am') = analyze_call am (map (abuiltin_arg ae am rm) args) in
  VA.State ((set_builtin_res res2 av ae), am')

(** val transfer_builtin :
    aenv -> amem -> romem -> external_function -> reg builtin_arg list -> reg
    builtin_res -> VA.t' **)

let transfer_builtin ae am rm ef args res2 =
  match ef with
  | EF_vload chunk ->
    (match args with
     | Nil -> transfer_builtin_default ae am rm args res2
     | Cons (addr, l) ->
       (match l with
        | Nil ->
          let aaddr = abuiltin_arg ae am rm addr in
          let a =
            match va_strict Tt with
            | True ->
              vlub (loadv0 chunk rm am aaddr) (vnormalize chunk (Ifptr Glob))
            | False -> vnormalize chunk vtop
          in
          VA.State ((set_builtin_res res2 a ae), am)
        | Cons (b, l0) -> transfer_builtin_default ae am rm args res2))
  | EF_vstore chunk ->
    (match args with
     | Nil -> transfer_builtin_default ae am rm args res2
     | Cons (addr, l) ->
       (match l with
        | Nil -> transfer_builtin_default ae am rm args res2
        | Cons (v, l0) ->
          (match l0 with
           | Nil ->
             let aaddr = abuiltin_arg ae am rm addr in
             let av = abuiltin_arg ae am rm v in
             let am' = storev0 chunk am aaddr av in
             VA.State ((set_builtin_res res2 ntop ae), (mlub am am'))
           | Cons (b, l1) -> transfer_builtin_default ae am rm args res2)))
  | EF_memcpy (sz, al) ->
    (match args with
     | Nil -> transfer_builtin_default ae am rm args res2
     | Cons (dst, l) ->
       (match l with
        | Nil -> transfer_builtin_default ae am rm args res2
        | Cons (src, l0) ->
          (match l0 with
           | Nil ->
             let adst = abuiltin_arg ae am rm dst in
             let asrc = abuiltin_arg ae am rm src in
             let p = loadbytes0 am rm (aptr_of_aval asrc) in
             let am' = storebytes0 am (aptr_of_aval adst) sz p in
             VA.State ((set_builtin_res res2 ntop ae), am')
           | Cons (b, l1) -> transfer_builtin_default ae am rm args res2)))
  | EF_annot (text, targs) -> VA.State ((set_builtin_res res2 ntop ae), am)
  | EF_annot_val (text, targ) ->
    (match args with
     | Nil -> transfer_builtin_default ae am rm args res2
     | Cons (v, l) ->
       (match l with
        | Nil ->
          let av = abuiltin_arg ae am rm v in
          VA.State ((set_builtin_res res2 av ae), am)
        | Cons (b, l0) -> transfer_builtin_default ae am rm args res2))
  | EF_debug (kind, text, targs) ->
    VA.State ((set_builtin_res res2 ntop ae), am)
  | _ -> transfer_builtin_default ae am rm args res2

(** val transfer0 : function4 -> romem -> node -> aenv -> amem -> VA.t **)

let transfer0 f rm pc ae am =
  match PTree.get pc f.fn_code with
  | Some i ->
    (match i with
     | Iop (op, args, res2, s) ->
       let a = eval_static_operation op (aregs ae args) in
       VA.State ((AE.set res2 a ae), am)
     | Iload (chunk, addr, args, dst, s) ->
       let a =
         loadv0 chunk rm am (eval_static_addressing addr (aregs ae args))
       in
       VA.State ((AE.set dst a ae), am)
     | Istore (chunk, addr, args, src, s) ->
       let am' =
         storev0 chunk am (eval_static_addressing addr (aregs ae args))
           (areg ae src)
       in
       VA.State (ae, am')
     | Icall (sig1, ros, args, res2, s) -> transfer_call ae am args res2
     | Itailcall (sig1, ros, args) -> VA.Bot
     | Ibuiltin (ef, args, res2, s) -> transfer_builtin ae am rm ef args res2
     | Ireturn arg -> VA.Bot
     | _ -> VA.State (ae, am))
  | None -> VA.Bot

(** val transfer' :
    function4 -> reg list PTree.t -> romem -> node -> VA.t -> VA.t **)

let transfer' f lastuses rm pc = function
| VA.Bot -> VA.Bot
| VA.State (ae, am) ->
  (match transfer0 f rm pc ae am with
   | VA.Bot -> VA.Bot
   | VA.State (ae', am') ->
     let ae'' =
       match PTree.get pc lastuses with
       | Some regs -> eforget regs ae'
       | None -> ae'
     in
     VA.State (ae'', am'))

module Coq_DS = Dataflow_Solver(VA)(NodeSetForward)

(** val mfunction_entry : amem **)

let mfunction_entry =
  { am_stack = (ablock_init Pbot); am_glob = PTree.empty; am_nonstack =
    Nonstack; am_top = Nonstack }

(** val analyze0 : romem -> function4 -> VA.t PMap.t **)

let analyze0 rm f =
  let lu = last_uses f in
  let entry = VA.State ((einit_regs f.fn_params3), mfunction_entry) in
  (match Coq_DS.fixpoint f.fn_code successors_instr (transfer' f lu rm)
           f.fn_entrypoint entry with
   | Some res2 -> res2
   | None -> PMap.init (VA.State (AE.top, mtop)))

(** val store_init_data0 : ablock -> z -> init_data -> ablock **)

let store_init_data0 ab p = function
| Init_int8 n0 -> ablock_store Mint8unsigned ab p (I n0)
| Init_int16 n0 -> ablock_store Mint16unsigned ab p (I n0)
| Init_int32 n0 -> ablock_store Mint32 ab p (I n0)
| Init_int64 n0 -> ablock_store Mint64 ab p (L n0)
| Init_float32 n0 ->
  ablock_store Mfloat32 ab p
    (match propagate_float_constants Tt with
     | True -> FS n0
     | False -> ntop)
| Init_float64 n0 ->
  ablock_store Mfloat64 ab p
    (match propagate_float_constants Tt with
     | True -> F n0
     | False -> ntop)
| Init_space n0 -> ab
| Init_addrof (symb, ofs) -> ablock_store Mint32 ab p (Ptr (Gl (symb, ofs)))

(** val store_init_data_list0 : ablock -> z -> init_data list -> ablock **)

let rec store_init_data_list0 ab p = function
| Nil -> ab
| Cons (id, idl') ->
  store_init_data_list0 (store_init_data0 ab p id)
    (Z.add p (Genv.init_data_size id)) idl'

(** val definitive_initializer : init_data list -> bool **)

let definitive_initializer = function
| Nil -> False
| Cons (i, l) ->
  (match i with
   | Init_space z0 ->
     (match l with
      | Nil -> False
      | Cons (i0, l0) -> True)
   | _ -> True)

(** val alloc_global0 :
    romem -> (ident, (fundef4, unit0) globdef) prod -> romem **)

let alloc_global0 rm = function
| Pair (id, g) ->
  (match g with
   | Gfun f -> PTree.remove id rm
   | Gvar v ->
     (match match match v.gvar_readonly with
                  | True -> negb v.gvar_volatile
                  | False -> False with
            | True -> definitive_initializer v.gvar_init
            | False -> False with
      | True ->
        PTree.set id
          (store_init_data_list0 (ablock_init Pbot) Z0 v.gvar_init) rm
      | False -> PTree.remove id rm))

(** val romem_for_program : program4 -> romem **)

let romem_for_program p =
  fold_left alloc_global0 p.prog_defs PTree.empty

(** val avalue : VA.t -> reg -> aval0 **)

let avalue a r =
  match a with
  | VA.Bot -> Vbot
  | VA.State (ae, am) -> AE.get r ae

(** val aaddressing : VA.t -> addressing -> reg list -> aptr **)

let aaddressing a addr args =
  match a with
  | VA.Bot -> Pbot
  | VA.State (ae, am) ->
    aptr_of_aval (eval_static_addressing addr (aregs ae args))

(** val aaddr_arg : VA.t -> reg builtin_arg -> aptr **)

let aaddr_arg a ba =
  match a with
  | VA.Bot -> Pbot
  | VA.State (ae, am) ->
    (match ba with
     | BA r -> aptr_of_aval (AE.get r ae)
     | BA_addrstack ofs -> Stk ofs
     | BA_addrglobal (id, ofs) -> Gl (id, ofs)
     | _ -> Ptop)

type cond_strength_reduction_cases =
| Cond_strength_reduction_case1 of comparison0 * reg * reg * Int.int * aval0
| Cond_strength_reduction_case2 of comparison0 * reg * reg * aval0 * Int.int
| Cond_strength_reduction_case3 of comparison0 * reg * reg * Int.int * aval0
| Cond_strength_reduction_case4 of comparison0 * reg * reg * aval0 * Int.int
| Cond_strength_reduction_default of condition * reg list * aval0 list

(** val cond_strength_reduction_match :
    condition -> reg list -> aval0 list -> cond_strength_reduction_cases **)

let cond_strength_reduction_match cond args vl =
  match cond with
  | Ccomp c ->
    let cond0 = Ccomp c in
    (match args with
     | Nil -> Cond_strength_reduction_default (cond0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          Cond_strength_reduction_default (cond0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Cond_strength_reduction_default (cond0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        (Vbot, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Cond_strength_reduction_case2 (c, r1, r2, Vbot,
                              n2)
                          | Cons (a0, l3) ->
                            Cond_strength_reduction_default (cond0, args0,
                              (Cons (Vbot, (Cons ((I n2), (Cons (a0,
                              l3))))))))
                       | x ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        ((I n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil ->
                         Cond_strength_reduction_case1 (c, r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           ((I n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        (x, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Cond_strength_reduction_case2 (c, r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Cond_strength_reduction_default (cond0, args0,
                              (Cons (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (x, (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Cond_strength_reduction_default (cond0, (Cons (r1, (Cons (r2,
               (Cons (r, l1)))))), vl))))
  | Ccompu c ->
    let cond0 = Ccompu c in
    (match args with
     | Nil -> Cond_strength_reduction_default (cond0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          Cond_strength_reduction_default (cond0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Cond_strength_reduction_default (cond0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        (Vbot, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Cond_strength_reduction_case4 (c, r1, r2, Vbot,
                              n2)
                          | Cons (a0, l3) ->
                            Cond_strength_reduction_default (cond0, args0,
                              (Cons (Vbot, (Cons ((I n2), (Cons (a0,
                              l3))))))))
                       | x ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        ((I n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil ->
                         Cond_strength_reduction_case3 (c, r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           ((I n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Cond_strength_reduction_default (cond0, args0, (Cons
                        (x, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Cond_strength_reduction_case4 (c, r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Cond_strength_reduction_default (cond0, args0,
                              (Cons (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Cond_strength_reduction_default (cond0, args0, (Cons
                           (x, (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Cond_strength_reduction_default (cond0, (Cons (r1, (Cons (r2,
               (Cons (r, l1)))))), vl))))
  | x -> Cond_strength_reduction_default (x, args, vl)

(** val cond_strength_reduction :
    condition -> reg list -> aval0 list -> (condition, reg list) prod **)

let cond_strength_reduction cond args vl =
  match cond_strength_reduction_match cond args vl with
  | Cond_strength_reduction_case1 (c, r1, r2, n1, v2) ->
    Pair ((Ccompimm ((swap_comparison c), n1)), (Cons (r2, Nil)))
  | Cond_strength_reduction_case2 (c, r1, r2, v1, n2) ->
    Pair ((Ccompimm (c, n2)), (Cons (r1, Nil)))
  | Cond_strength_reduction_case3 (c, r1, r2, n1, v2) ->
    Pair ((Ccompuimm ((swap_comparison c), n1)), (Cons (r2, Nil)))
  | Cond_strength_reduction_case4 (c, r1, r2, v1, n2) ->
    Pair ((Ccompuimm (c, n2)), (Cons (r1, Nil)))
  | Cond_strength_reduction_default (cond0, args0, vl0) ->
    Pair (cond0, args0)

(** val make_cmp_base :
    condition -> reg list -> aval0 list -> (operation, reg list) prod **)

let make_cmp_base c args vl =
  let Pair (c', args') = cond_strength_reduction c args vl in
  Pair ((Ocmp0 c'), args')

type make_cmp_cases =
| Make_cmp_case1 of Int.int * reg * aval0
| Make_cmp_case2 of Int.int * reg * aval0
| Make_cmp_default of condition * reg list * aval0 list

(** val make_cmp_match :
    condition -> reg list -> aval0 list -> make_cmp_cases **)

let make_cmp_match c args vl =
  match c with
  | Ccompimm (c0, n0) ->
    (match c0 with
     | Ceq ->
       let c1 = Ccompimm (Ceq, n0) in
       (match args with
        | Nil -> Make_cmp_default (c1, Nil, vl)
        | Cons (r1, l) ->
          (match l with
           | Nil ->
             let args0 = Cons (r1, Nil) in
             (match vl with
              | Nil -> Make_cmp_default (c1, args0, Nil)
              | Cons (v1, l0) ->
                (match l0 with
                 | Nil -> Make_cmp_case1 (n0, r1, v1)
                 | Cons (a, l1) ->
                   Make_cmp_default (c1, args0, (Cons (v1, (Cons (a, l1)))))))
           | Cons (r, l0) ->
             Make_cmp_default (c1, (Cons (r1, (Cons (r, l0)))), vl)))
     | Cne ->
       let c1 = Ccompimm (Cne, n0) in
       (match args with
        | Nil -> Make_cmp_default (c1, Nil, vl)
        | Cons (r1, l) ->
          (match l with
           | Nil ->
             let args0 = Cons (r1, Nil) in
             (match vl with
              | Nil -> Make_cmp_default (c1, args0, Nil)
              | Cons (v1, l0) ->
                (match l0 with
                 | Nil -> Make_cmp_case2 (n0, r1, v1)
                 | Cons (a, l1) ->
                   Make_cmp_default (c1, args0, (Cons (v1, (Cons (a, l1)))))))
           | Cons (r, l0) ->
             Make_cmp_default (c1, (Cons (r1, (Cons (r, l0)))), vl)))
     | x -> Make_cmp_default ((Ccompimm (x, n0)), args, vl))
  | x -> Make_cmp_default (x, args, vl)

(** val make_cmp0 :
    condition -> reg list -> aval0 list -> (operation, reg list) prod **)

let make_cmp0 c args vl =
  match make_cmp_match c args vl with
  | Make_cmp_case1 (n0, r1, v1) ->
    (match match proj_sumbool (Int.eq_dec n0 Int.one) with
           | True -> vincl v1 (Uns (Ptop, (Zpos XH)))
           | False -> False with
     | True -> Pair (Omove, (Cons (r1, Nil)))
     | False ->
       (match match proj_sumbool (Int.eq_dec n0 Int.zero) with
              | True -> vincl v1 (Uns (Ptop, (Zpos XH)))
              | False -> False with
        | True -> Pair ((Oxorimm Int.one), (Cons (r1, Nil)))
        | False -> make_cmp_base c args vl))
  | Make_cmp_case2 (n0, r1, v1) ->
    (match match proj_sumbool (Int.eq_dec n0 Int.zero) with
           | True -> vincl v1 (Uns (Ptop, (Zpos XH)))
           | False -> False with
     | True -> Pair (Omove, (Cons (r1, Nil)))
     | False ->
       (match match proj_sumbool (Int.eq_dec n0 Int.one) with
              | True -> vincl v1 (Uns (Ptop, (Zpos XH)))
              | False -> False with
        | True -> Pair ((Oxorimm Int.one), (Cons (r1, Nil)))
        | False -> make_cmp_base c args vl))
  | Make_cmp_default (c0, args0, vl0) -> make_cmp_base c0 args0 vl0

type addr_strength_reduction_cases =
| Addr_strength_reduction_case1 of Int.int * reg * ident * Int.int
| Addr_strength_reduction_case2 of Int.int * reg * Int.int
| Addr_strength_reduction_case3 of Int.int * reg * reg * ident * Int.int
   * Int.int
| Addr_strength_reduction_case4 of Int.int * reg * reg * Int.int * ident
   * Int.int
| Addr_strength_reduction_case5 of Int.int * reg * reg * Int.int * Int.int
| Addr_strength_reduction_case6 of Int.int * reg * reg * Int.int * Int.int
| Addr_strength_reduction_case7 of Int.int * reg * reg * ident * Int.int
   * aval0
| Addr_strength_reduction_case8 of Int.int * reg * reg * aval0 * ident
   * Int.int
| Addr_strength_reduction_case9 of Int.int * reg * reg * Int.int * aval0
| Addr_strength_reduction_case10 of Int.int * reg * reg * aval0 * Int.int
| Addr_strength_reduction_case11 of Int.int * Int.int * reg * reg * ident
   * Int.int * Int.int
| Addr_strength_reduction_case12 of Int.int * Int.int * reg * reg * ident
   * Int.int * aval0
| Addr_strength_reduction_case13 of Int.int * Int.int * reg * reg * aval0
   * Int.int
| Addr_strength_reduction_case14 of ident * Int.int * reg * Int.int
| Addr_strength_reduction_case15 of Int.int * ident * Int.int * reg * Int.int
| Addr_strength_reduction_default of addressing * reg list * aval0 list

(** val addr_strength_reduction_match :
    addressing -> reg list -> aval0 list -> addr_strength_reduction_cases **)

let addr_strength_reduction_match addr args vl =
  match addr with
  | Aindexed ofs ->
    let addr0 = Aindexed ofs in
    (match args with
     | Nil -> Addr_strength_reduction_default (addr0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Addr_strength_reduction_default (addr0, args0, Nil)
           | Cons (a, l0) ->
             (match a with
              | Ptr p ->
                (match p with
                 | Gl (symb, n0) ->
                   (match l0 with
                    | Nil ->
                      Addr_strength_reduction_case1 (ofs, r1, symb, n0)
                    | Cons (a0, l1) ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        ((Ptr (Gl (symb, n0))), (Cons (a0, l1))))))
                 | Stk n0 ->
                   (match l0 with
                    | Nil -> Addr_strength_reduction_case2 (ofs, r1, n0)
                    | Cons (a0, l1) ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        ((Ptr (Stk n0)), (Cons (a0, l1))))))
                 | x ->
                   Addr_strength_reduction_default (addr0, args0, (Cons ((Ptr
                     x), l0))))
              | x ->
                Addr_strength_reduction_default (addr0, args0, (Cons (x,
                  l0)))))
        | Cons (r, l0) ->
          Addr_strength_reduction_default (addr0, (Cons (r1, (Cons (r,
            l0)))), vl)))
  | Aindexed2 ofs ->
    let addr0 = Aindexed2 ofs in
    (match args with
     | Nil -> Addr_strength_reduction_default (addr0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          Addr_strength_reduction_default (addr0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Addr_strength_reduction_default (addr0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   let v2 = Vbot in
                   (match l1 with
                    | Nil ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        (Vbot, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Addr_strength_reduction_case10 (ofs, r1, r2, v2,
                              n2)
                          | Cons (a0, l3) ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (Vbot, (Cons ((I n2), (Cons (a0,
                              l3))))))))
                       | Ptr p ->
                         (match p with
                          | Gl (symb, n2) ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case8 (ofs, r1, r2,
                                 v2, symb, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons (Vbot, (Cons ((Ptr (Gl (symb, n2))),
                                 (Cons (a0, l3))))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (Vbot, (Cons ((Ptr x), l2))))))
                       | x ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        ((I n1), Nil)))
                    | Cons (v2, l2) ->
                      (match v2 with
                       | Ptr p ->
                         (match p with
                          | Gl (symb, n2) ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case4 (ofs, r1, r2,
                                 n1, symb, n2)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((I n1), (Cons ((Ptr (Gl (symb, n2))),
                                 (Cons (a, l3))))))))
                          | Stk n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case6 (ofs, r1, r2,
                                 n1, n2)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((I n1), (Cons ((Ptr (Stk n2)), (Cons
                                 (a, l3))))))))
                          | x ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case9 (ofs, r1, r2,
                                 n1, (Ptr x))
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((I n1), (Cons ((Ptr x), (Cons (a,
                                 l3)))))))))
                       | x ->
                         (match l2 with
                          | Nil ->
                            Addr_strength_reduction_case9 (ofs, r1, r2, n1,
                              x)
                          | Cons (a, l3) ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((I n1), (Cons (x, (Cons (a, l3))))))))))
                 | Ptr p ->
                   (match p with
                    | Pbot ->
                      let v2 = Ptr Pbot in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr Pbot), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Pbot), (Cons ((I n2), (Cons (a0,
                                 l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Pbot ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Pbot), (Cons ((Ptr Pbot),
                                 l2)))))
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr Pbot), (Cons ((Ptr (Gl
                                    (symb, n2))), (Cons (a0, l3))))))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Pbot), (Cons ((Ptr x), l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr Pbot), (Cons (x, l2)))))))
                    | Gl (symb, n1) ->
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr (Gl (symb, n1))), Nil)))
                       | Cons (v2, l2) ->
                         (match v2 with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case3 (ofs, r1, r2,
                                 symb, n1, n2)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Gl (symb, n1))), (Cons ((I n2),
                                 (Cons (a, l3))))))))
                          | x ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case7 (ofs, r1, r2,
                                 symb, n1, x)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Gl (symb, n1))), (Cons (x,
                                 (Cons (a, l3))))))))))
                    | Glo id ->
                      let v2 = Ptr (Glo id) in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr (Glo id)), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Glo id)), (Cons ((I n2), (Cons
                                 (a0, l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr (Glo id)), (Cons ((Ptr
                                    (Gl (symb, n2))), (Cons (a0, l3))))))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Glo id)), (Cons ((Ptr x),
                                 l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr (Glo id)), (Cons (x, l2)))))))
                    | Glob ->
                      let v2 = Ptr Glob in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr Glob), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Glob), (Cons ((I n2), (Cons (a0,
                                 l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr Glob), (Cons ((Ptr (Gl
                                    (symb, n2))), (Cons (a0, l3))))))))
                             | Glob ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Glob), (Cons ((Ptr Glob),
                                 l2)))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Glob), (Cons ((Ptr x), l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr Glob), (Cons (x, l2)))))))
                    | Stk n1 ->
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr (Stk n1)), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case5 (ofs, r1, r2,
                                 n1, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Stk n1)), (Cons ((I n2), (Cons
                                 (a0, l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    (Ptr (Stk n1)), symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr (Stk n1)), (Cons ((Ptr
                                    (Gl (symb, n2))), (Cons (a0, l3))))))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Stk n1)), (Cons ((Ptr x),
                                 l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr (Stk n1)), (Cons (x, l2)))))))
                    | Stack ->
                      let v2 = Ptr Stack in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr Stack), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Stack), (Cons ((I n2), (Cons
                                 (a0, l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr Stack), (Cons ((Ptr
                                    (Gl (symb, n2))), (Cons (a0, l3))))))))
                             | Stack ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Stack), (Cons ((Ptr Stack),
                                 l2)))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Stack), (Cons ((Ptr x), l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr Stack), (Cons (x, l2)))))))
                    | Nonstack ->
                      let v2 = Ptr Nonstack in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr Nonstack), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Nonstack), (Cons ((I n2), (Cons
                                 (a0, l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr Nonstack), (Cons ((Ptr
                                    (Gl (symb, n2))), (Cons (a0, l3))))))))
                             | Nonstack ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Nonstack), (Cons ((Ptr
                                 Nonstack), l2)))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Nonstack), (Cons ((Ptr x),
                                 l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr Nonstack), (Cons (x, l2)))))))
                    | Ptop ->
                      let v2 = Ptr Ptop in
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr Ptop), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case10 (ofs, r1, r2,
                                 v2, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Ptop), (Cons ((I n2), (Cons (a0,
                                 l3))))))))
                          | Ptr p0 ->
                            (match p0 with
                             | Gl (symb, n2) ->
                               (match l2 with
                                | Nil ->
                                  Addr_strength_reduction_case8 (ofs, r1, r2,
                                    v2, symb, n2)
                                | Cons (a0, l3) ->
                                  Addr_strength_reduction_default (addr0,
                                    args0, (Cons ((Ptr Ptop), (Cons ((Ptr (Gl
                                    (symb, n2))), (Cons (a0, l3))))))))
                             | Ptop ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Ptop), (Cons ((Ptr Ptop),
                                 l2)))))
                             | x ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr Ptop), (Cons ((Ptr x), l2))))))
                          | x ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr Ptop), (Cons (x, l2))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        (x, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Addr_strength_reduction_case10 (ofs, r1, r2, x,
                              n2)
                          | Cons (a0, l3) ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | Ptr p ->
                         (match p with
                          | Gl (symb, n2) ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case8 (ofs, r1, r2, x,
                                 symb, n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons (x, (Cons ((Ptr (Gl (symb, n2))),
                                 (Cons (a0, l3))))))))
                          | x0 ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (x, (Cons ((Ptr x0), l2))))))
                       | x0 ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (x, (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Addr_strength_reduction_default (addr0, (Cons (r1, (Cons (r2,
               (Cons (r, l1)))))), vl))))
  | Aindexed2scaled (sc, ofs) ->
    let addr0 = Aindexed2scaled (sc, ofs) in
    (match args with
     | Nil -> Addr_strength_reduction_default (addr0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          Addr_strength_reduction_default (addr0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Addr_strength_reduction_default (addr0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        (Vbot, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Addr_strength_reduction_case13 (sc, ofs, r1, r2,
                              Vbot, n2)
                          | Cons (a0, l3) ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (Vbot, (Cons ((I n2), (Cons (a0,
                              l3))))))))
                       | x ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | Ptr p ->
                   (match p with
                    | Gl (symb, n1) ->
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr (Gl (symb, n1))), Nil)))
                       | Cons (v2, l2) ->
                         (match v2 with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case11 (sc, ofs, r1,
                                 r2, symb, n1, n2)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Gl (symb, n1))), (Cons ((I n2),
                                 (Cons (a, l3))))))))
                          | x ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case12 (sc, ofs, r1,
                                 r2, symb, n1, x)
                             | Cons (a, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr (Gl (symb, n1))), (Cons (x,
                                 (Cons (a, l3))))))))))
                    | x ->
                      (match l1 with
                       | Nil ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           ((Ptr x), Nil)))
                       | Cons (a, l2) ->
                         (match a with
                          | I n2 ->
                            (match l2 with
                             | Nil ->
                               Addr_strength_reduction_case13 (sc, ofs, r1,
                                 r2, (Ptr x), n2)
                             | Cons (a0, l3) ->
                               Addr_strength_reduction_default (addr0, args0,
                                 (Cons ((Ptr x), (Cons ((I n2), (Cons (a0,
                                 l3))))))))
                          | x0 ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons ((Ptr x), (Cons (x0, l2))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Addr_strength_reduction_default (addr0, args0, (Cons
                        (x, Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Addr_strength_reduction_case13 (sc, ofs, r1, r2,
                              x, n2)
                          | Cons (a0, l3) ->
                            Addr_strength_reduction_default (addr0, args0,
                              (Cons (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Addr_strength_reduction_default (addr0, args0, (Cons
                           (x, (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Addr_strength_reduction_default (addr0, (Cons (r1, (Cons (r2,
               (Cons (r, l1)))))), vl))))
  | Abased (id, ofs) ->
    let addr0 = Abased (id, ofs) in
    (match args with
     | Nil -> Addr_strength_reduction_default (addr0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Addr_strength_reduction_default (addr0, args0, Nil)
           | Cons (a, l0) ->
             (match a with
              | I n1 ->
                (match l0 with
                 | Nil -> Addr_strength_reduction_case14 (id, ofs, r1, n1)
                 | Cons (a0, l1) ->
                   Addr_strength_reduction_default (addr0, args0, (Cons ((I
                     n1), (Cons (a0, l1))))))
              | x ->
                Addr_strength_reduction_default (addr0, args0, (Cons (x,
                  l0)))))
        | Cons (r, l0) ->
          Addr_strength_reduction_default (addr0, (Cons (r1, (Cons (r,
            l0)))), vl)))
  | Abasedscaled (sc, id, ofs) ->
    let addr0 = Abasedscaled (sc, id, ofs) in
    (match args with
     | Nil -> Addr_strength_reduction_default (addr0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Addr_strength_reduction_default (addr0, args0, Nil)
           | Cons (a, l0) ->
             (match a with
              | I n1 ->
                (match l0 with
                 | Nil ->
                   Addr_strength_reduction_case15 (sc, id, ofs, r1, n1)
                 | Cons (a0, l1) ->
                   Addr_strength_reduction_default (addr0, args0, (Cons ((I
                     n1), (Cons (a0, l1))))))
              | x ->
                Addr_strength_reduction_default (addr0, args0, (Cons (x,
                  l0)))))
        | Cons (r, l0) ->
          Addr_strength_reduction_default (addr0, (Cons (r1, (Cons (r,
            l0)))), vl)))
  | x -> Addr_strength_reduction_default (x, args, vl)

(** val addr_strength_reduction :
    addressing -> reg list -> aval0 list -> (addressing, reg list) prod **)

let addr_strength_reduction addr args vl =
  match addr_strength_reduction_match addr args vl with
  | Addr_strength_reduction_case1 (ofs, r1, symb, n0) ->
    Pair ((Aglobal (symb, (Int.add n0 ofs))), Nil)
  | Addr_strength_reduction_case2 (ofs, r1, n0) ->
    Pair ((Ainstack (Int.add n0 ofs)), Nil)
  | Addr_strength_reduction_case3 (ofs, r1, r2, symb, n1, n2) ->
    Pair ((Aglobal (symb, (Int.add (Int.add n1 n2) ofs))), Nil)
  | Addr_strength_reduction_case4 (ofs, r1, r2, n1, symb, n2) ->
    Pair ((Aglobal (symb, (Int.add (Int.add n1 n2) ofs))), Nil)
  | Addr_strength_reduction_case5 (ofs, r1, r2, n1, n2) ->
    Pair ((Ainstack (Int.add (Int.add n1 n2) ofs)), Nil)
  | Addr_strength_reduction_case6 (ofs, r1, r2, n1, n2) ->
    Pair ((Ainstack (Int.add (Int.add n1 n2) ofs)), Nil)
  | Addr_strength_reduction_case7 (ofs, r1, r2, symb, n1, v2) ->
    Pair ((Abased (symb, (Int.add n1 ofs))), (Cons (r2, Nil)))
  | Addr_strength_reduction_case8 (ofs, r1, r2, v1, symb, n2) ->
    Pair ((Abased (symb, (Int.add n2 ofs))), (Cons (r1, Nil)))
  | Addr_strength_reduction_case9 (ofs, r1, r2, n1, v2) ->
    Pair ((Aindexed (Int.add n1 ofs)), (Cons (r2, Nil)))
  | Addr_strength_reduction_case10 (ofs, r1, r2, v1, n2) ->
    Pair ((Aindexed (Int.add n2 ofs)), (Cons (r1, Nil)))
  | Addr_strength_reduction_case11 (sc, ofs, r1, r2, symb, n1, n2) ->
    Pair ((Aglobal (symb, (Int.add (Int.add n1 (Int.mul n2 sc)) ofs))), Nil)
  | Addr_strength_reduction_case12 (sc, ofs, r1, r2, symb, n1, v2) ->
    Pair ((Abasedscaled (sc, symb, (Int.add n1 ofs))), (Cons (r2, Nil)))
  | Addr_strength_reduction_case13 (sc, ofs, r1, r2, v1, n2) ->
    Pair ((Aindexed (Int.add (Int.mul n2 sc) ofs)), (Cons (r1, Nil)))
  | Addr_strength_reduction_case14 (id, ofs, r1, n1) ->
    Pair ((Aglobal (id, (Int.add ofs n1))), Nil)
  | Addr_strength_reduction_case15 (sc, id, ofs, r1, n1) ->
    Pair ((Aglobal (id, (Int.add ofs (Int.mul sc n1)))), Nil)
  | Addr_strength_reduction_default (addr0, args0, vl0) ->
    Pair (addr0, args0)

(** val make_addimm : Int.int -> reg -> (operation, reg list) prod **)

let make_addimm n0 r =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False -> Pair ((Olea (Aindexed n0)), (Cons (r, Nil)))

(** val make_shlimm : Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_shlimm n0 r1 r2 =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r1, Nil)))
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True -> Pair ((Oshlimm n0), (Cons (r1, Nil)))
     | False -> Pair (Oshl1, (Cons (r1, (Cons (r2, Nil))))))

(** val make_shrimm : Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_shrimm n0 r1 r2 =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r1, Nil)))
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True -> Pair ((Oshrimm n0), (Cons (r1, Nil)))
     | False -> Pair (Oshr1, (Cons (r1, (Cons (r2, Nil))))))

(** val make_shruimm :
    Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_shruimm n0 r1 r2 =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r1, Nil)))
  | False ->
    (match Int.ltu n0 Int.iwordsize with
     | True -> Pair ((Oshruimm n0), (Cons (r1, Nil)))
     | False -> Pair (Oshru0, (Cons (r1, (Cons (r2, Nil))))))

(** val make_mulimm : Int.int -> reg -> (operation, reg list) prod **)

let make_mulimm n0 r =
  match Int.eq n0 Int.zero with
  | True -> Pair ((Ointconst1 Int.zero), Nil)
  | False ->
    (match Int.eq n0 Int.one with
     | True -> Pair (Omove, (Cons (r, Nil)))
     | False ->
       (match Int.is_power2 n0 with
        | Some l -> Pair ((Oshlimm l), (Cons (r, Nil)))
        | None -> Pair ((Omulimm n0), (Cons (r, Nil)))))

(** val make_andimm :
    Int.int -> reg -> aval0 -> (operation, reg list) prod **)

let make_andimm n0 r a =
  match Int.eq n0 Int.zero with
  | True -> Pair ((Ointconst1 Int.zero), Nil)
  | False ->
    (match Int.eq n0 Int.mone with
     | True -> Pair (Omove, (Cons (r, Nil)))
     | False ->
       (match match a with
              | Uns (p, m0) -> Int.eq (Int.zero_ext m0 (Int.not n0)) Int.zero
              | _ -> False with
        | True -> Pair (Omove, (Cons (r, Nil)))
        | False -> Pair ((Oandimm n0), (Cons (r, Nil)))))

(** val make_orimm : Int.int -> reg -> (operation, reg list) prod **)

let make_orimm n0 r =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False ->
    (match Int.eq n0 Int.mone with
     | True -> Pair ((Ointconst1 Int.mone), Nil)
     | False -> Pair ((Oorimm n0), (Cons (r, Nil))))

(** val make_xorimm : Int.int -> reg -> (operation, reg list) prod **)

let make_xorimm n0 r =
  match Int.eq n0 Int.zero with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False ->
    (match Int.eq n0 Int.mone with
     | True -> Pair (Onot, (Cons (r, Nil)))
     | False -> Pair ((Oxorimm n0), (Cons (r, Nil))))

(** val make_divimm : Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_divimm n0 r1 r2 =
  match Int.is_power2 n0 with
  | Some l ->
    (match Int.ltu l (Int.repr (Zpos (XI (XI (XI (XI XH)))))) with
     | True -> Pair ((Oshrximm l), (Cons (r1, Nil)))
     | False -> Pair (Odiv1, (Cons (r1, (Cons (r2, Nil))))))
  | None -> Pair (Odiv1, (Cons (r1, (Cons (r2, Nil)))))

(** val make_divuimm :
    Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_divuimm n0 r1 r2 =
  match Int.is_power2 n0 with
  | Some l -> Pair ((Oshruimm l), (Cons (r1, Nil)))
  | None -> Pair (Odivu0, (Cons (r1, (Cons (r2, Nil)))))

(** val make_moduimm :
    Int.int -> reg -> reg -> (operation, reg list) prod **)

let make_moduimm n0 r1 r2 =
  match Int.is_power2 n0 with
  | Some l -> Pair ((Oandimm (Int.sub n0 Int.one)), (Cons (r1, Nil)))
  | None -> Pair (Omodu0, (Cons (r1, (Cons (r2, Nil)))))

(** val make_mulfimm :
    float -> reg -> reg -> reg -> (operation, reg list) prod **)

let make_mulfimm n0 r r1 r2 =
  match Float.eq_dec n0 (Float.of_int (Int.repr (Zpos (XO XH)))) with
  | Left -> Pair (Oaddf0, (Cons (r, (Cons (r, Nil)))))
  | Right -> Pair (Omulf0, (Cons (r1, (Cons (r2, Nil)))))

(** val make_mulfsimm :
    float32 -> reg -> reg -> reg -> (operation, reg list) prod **)

let make_mulfsimm n0 r r1 r2 =
  match Float32.eq_dec n0 (Float32.of_int (Int.repr (Zpos (XO XH)))) with
  | Left -> Pair (Oaddfs0, (Cons (r, (Cons (r, Nil)))))
  | Right -> Pair (Omulfs0, (Cons (r1, (Cons (r2, Nil)))))

(** val make_cast8signed : reg -> aval0 -> (operation, reg list) prod **)

let make_cast8signed r a =
  match vincl a (Sgn (Ptop, (Zpos (XO (XO (XO XH)))))) with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False -> Pair (Ocast8signed0, (Cons (r, Nil)))

(** val make_cast8unsigned : reg -> aval0 -> (operation, reg list) prod **)

let make_cast8unsigned r a =
  match vincl a (Uns (Ptop, (Zpos (XO (XO (XO XH)))))) with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False -> Pair (Ocast8unsigned0, (Cons (r, Nil)))

(** val make_cast16signed : reg -> aval0 -> (operation, reg list) prod **)

let make_cast16signed r a =
  match vincl a (Sgn (Ptop, (Zpos (XO (XO (XO (XO XH))))))) with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False -> Pair (Ocast16signed0, (Cons (r, Nil)))

(** val make_cast16unsigned : reg -> aval0 -> (operation, reg list) prod **)

let make_cast16unsigned r a =
  match vincl a (Uns (Ptop, (Zpos (XO (XO (XO (XO XH))))))) with
  | True -> Pair (Omove, (Cons (r, Nil)))
  | False -> Pair (Ocast16unsigned0, (Cons (r, Nil)))

type op_strength_reduction_cases =
| Op_strength_reduction_case1 of reg * aval0
| Op_strength_reduction_case2 of reg * aval0
| Op_strength_reduction_case3 of reg * aval0
| Op_strength_reduction_case4 of reg * aval0
| Op_strength_reduction_case5 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case6 of reg * reg * Int.int * aval0
| Op_strength_reduction_case7 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case8 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case9 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case10 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case11 of reg * reg * Int.int * aval0
| Op_strength_reduction_case12 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case13 of Int.int * reg * aval0
| Op_strength_reduction_case14 of reg * reg * Int.int * aval0
| Op_strength_reduction_case15 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case16 of reg * reg * Int.int * aval0
| Op_strength_reduction_case17 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case18 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case19 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case20 of reg * reg * aval0 * Int.int
| Op_strength_reduction_case21 of addressing * reg list * aval0 list
| Op_strength_reduction_case22 of condition * reg list * aval0 list
| Op_strength_reduction_case23 of reg * reg * aval0 * float
| Op_strength_reduction_case24 of reg * reg * float * aval0
| Op_strength_reduction_case25 of reg * reg * aval0 * float32
| Op_strength_reduction_case26 of reg * reg * float32 * aval0
| Op_strength_reduction_default of operation * reg list * aval0 list

(** val op_strength_reduction_match :
    operation -> reg list -> aval0 list -> op_strength_reduction_cases **)

let op_strength_reduction_match op args vl =
  match op with
  | Ocast8signed0 ->
    let op0 = Ocast8signed0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Op_strength_reduction_default (op0, args0, Nil)
           | Cons (v1, l0) ->
             (match l0 with
              | Nil -> Op_strength_reduction_case1 (r1, v1)
              | Cons (a, l1) ->
                Op_strength_reduction_default (op0, args0, (Cons (v1, (Cons
                  (a, l1)))))))
        | Cons (r, l0) ->
          Op_strength_reduction_default (op0, (Cons (r1, (Cons (r, l0)))),
            vl)))
  | Ocast8unsigned0 ->
    let op0 = Ocast8unsigned0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Op_strength_reduction_default (op0, args0, Nil)
           | Cons (v1, l0) ->
             (match l0 with
              | Nil -> Op_strength_reduction_case2 (r1, v1)
              | Cons (a, l1) ->
                Op_strength_reduction_default (op0, args0, (Cons (v1, (Cons
                  (a, l1)))))))
        | Cons (r, l0) ->
          Op_strength_reduction_default (op0, (Cons (r1, (Cons (r, l0)))),
            vl)))
  | Ocast16signed0 ->
    let op0 = Ocast16signed0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Op_strength_reduction_default (op0, args0, Nil)
           | Cons (v1, l0) ->
             (match l0 with
              | Nil -> Op_strength_reduction_case3 (r1, v1)
              | Cons (a, l1) ->
                Op_strength_reduction_default (op0, args0, (Cons (v1, (Cons
                  (a, l1)))))))
        | Cons (r, l0) ->
          Op_strength_reduction_default (op0, (Cons (r1, (Cons (r, l0)))),
            vl)))
  | Ocast16unsigned0 ->
    let op0 = Ocast16unsigned0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Op_strength_reduction_default (op0, args0, Nil)
           | Cons (v1, l0) ->
             (match l0 with
              | Nil -> Op_strength_reduction_case4 (r1, v1)
              | Cons (a, l1) ->
                Op_strength_reduction_default (op0, args0, (Cons (v1, (Cons
                  (a, l1)))))))
        | Cons (r, l0) ->
          Op_strength_reduction_default (op0, (Cons (r1, (Cons (r, l0)))),
            vl)))
  | Osub1 ->
    let op0 = Osub1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case5 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Omul1 ->
    let op0 = Omul1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case7 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((I
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case6 (r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons ((I
                           n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case7 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Odiv1 ->
    let op0 = Odiv1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case8 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Odivu0 ->
    let op0 = Odivu0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case9 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Omodu0 ->
    let op0 = Omodu0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case10 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oand1 ->
    let op0 = Oand1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case12 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((I
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case11 (r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons ((I
                           n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case12 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oandimm n0 ->
    let op0 = Oandimm n0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil ->
          let args0 = Cons (r1, Nil) in
          (match vl with
           | Nil -> Op_strength_reduction_default (op0, args0, Nil)
           | Cons (v1, l0) ->
             (match l0 with
              | Nil -> Op_strength_reduction_case13 (n0, r1, v1)
              | Cons (a, l1) ->
                Op_strength_reduction_default (op0, args0, (Cons (v1, (Cons
                  (a, l1)))))))
        | Cons (r, l0) ->
          Op_strength_reduction_default (op0, (Cons (r1, (Cons (r, l0)))),
            vl)))
  | Oor1 ->
    let op0 = Oor1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case15 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((I
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case14 (r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons ((I
                           n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case15 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oxor1 ->
    let op0 = Oxor1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case17 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | I n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((I
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case16 (r1, r2, n1, v2)
                       | Cons (a, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons ((I
                           n1), (Cons (v2, (Cons (a, l3)))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | I n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case17 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((I n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oshl1 ->
    let op0 = Oshl1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case18 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oshr1 ->
    let op0 = Oshr1 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case19 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Oshru0 ->
    let op0 = Oshru0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match l1 with
                 | Nil ->
                   Op_strength_reduction_default (op0, args0, (Cons (v1,
                     Nil)))
                 | Cons (a, l2) ->
                   (match a with
                    | I n2 ->
                      (match l2 with
                       | Nil -> Op_strength_reduction_case20 (r1, r2, v1, n2)
                       | Cons (a0, l3) ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (v1, (Cons ((I n2), (Cons (a0, l3))))))))
                    | x ->
                      Op_strength_reduction_default (op0, args0, (Cons (v1,
                        (Cons (x, l2))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Olea addr -> Op_strength_reduction_case21 (addr, args, vl)
  | Omulf0 ->
    let op0 = Omulf0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | F n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case23 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((F n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | F n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((F
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match v2 with
                       | F n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case23 (r1, r2, (F n1), n2)
                          | Cons (a, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              ((F n1), (Cons ((F n2), (Cons (a, l3))))))))
                       | x ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case24 (r1, r2, n1, x)
                          | Cons (a, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              ((F n1), (Cons (x, (Cons (a, l3))))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | F n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case23 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((F n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Omulfs0 ->
    let op0 = Omulfs0 in
    (match args with
     | Nil -> Op_strength_reduction_default (op0, Nil, vl)
     | Cons (r1, l) ->
       (match l with
        | Nil -> Op_strength_reduction_default (op0, (Cons (r1, Nil)), vl)
        | Cons (r2, l0) ->
          (match l0 with
           | Nil ->
             let args0 = Cons (r1, (Cons (r2, Nil))) in
             (match vl with
              | Nil -> Op_strength_reduction_default (op0, args0, Nil)
              | Cons (v1, l1) ->
                (match v1 with
                 | Vbot ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (Vbot,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | Vbot ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (Vbot, l2)))))
                       | FS n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case25 (r1, r2, Vbot, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (Vbot, (Cons ((FS n2), (Cons (a0, l3))))))))
                       | x ->
                         Op_strength_reduction_default (op0, args0, (Cons
                           (Vbot, (Cons (x, l2)))))))
                 | FS n1 ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons ((FS
                        n1), Nil)))
                    | Cons (v2, l2) ->
                      (match v2 with
                       | FS n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case25 (r1, r2, (FS n1),
                              n2)
                          | Cons (a, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              ((FS n1), (Cons ((FS n2), (Cons (a, l3))))))))
                       | x ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case26 (r1, r2, n1, x)
                          | Cons (a, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              ((FS n1), (Cons (x, (Cons (a, l3))))))))))
                 | x ->
                   (match l1 with
                    | Nil ->
                      Op_strength_reduction_default (op0, args0, (Cons (x,
                        Nil)))
                    | Cons (a, l2) ->
                      (match a with
                       | FS n2 ->
                         (match l2 with
                          | Nil ->
                            Op_strength_reduction_case25 (r1, r2, x, n2)
                          | Cons (a0, l3) ->
                            Op_strength_reduction_default (op0, args0, (Cons
                              (x, (Cons ((FS n2), (Cons (a0, l3))))))))
                       | x0 ->
                         Op_strength_reduction_default (op0, args0, (Cons (x,
                           (Cons (x0, l2)))))))))
           | Cons (r, l1) ->
             Op_strength_reduction_default (op0, (Cons (r1, (Cons (r2, (Cons
               (r, l1)))))), vl))))
  | Ocmp0 c -> Op_strength_reduction_case22 (c, args, vl)
  | x -> Op_strength_reduction_default (x, args, vl)

(** val op_strength_reduction :
    operation -> reg list -> aval0 list -> (operation, reg list) prod **)

let op_strength_reduction op args vl =
  match op_strength_reduction_match op args vl with
  | Op_strength_reduction_case1 (r1, v1) -> make_cast8signed r1 v1
  | Op_strength_reduction_case2 (r1, v1) -> make_cast8unsigned r1 v1
  | Op_strength_reduction_case3 (r1, v1) -> make_cast16signed r1 v1
  | Op_strength_reduction_case4 (r1, v1) -> make_cast16unsigned r1 v1
  | Op_strength_reduction_case5 (r1, r2, v1, n2) ->
    make_addimm (Int.neg n2) r1
  | Op_strength_reduction_case6 (r1, r2, n1, v2) -> make_mulimm n1 r2
  | Op_strength_reduction_case7 (r1, r2, v1, n2) -> make_mulimm n2 r1
  | Op_strength_reduction_case8 (r1, r2, v1, n2) -> make_divimm n2 r1 r2
  | Op_strength_reduction_case9 (r1, r2, v1, n2) -> make_divuimm n2 r1 r2
  | Op_strength_reduction_case10 (r1, r2, v1, n2) -> make_moduimm n2 r1 r2
  | Op_strength_reduction_case11 (r1, r2, n1, v2) -> make_andimm n1 r2 v2
  | Op_strength_reduction_case12 (r1, r2, v1, n2) -> make_andimm n2 r1 v1
  | Op_strength_reduction_case13 (n0, r1, v1) -> make_andimm n0 r1 v1
  | Op_strength_reduction_case14 (r1, r2, n1, v2) -> make_orimm n1 r2
  | Op_strength_reduction_case15 (r1, r2, v1, n2) -> make_orimm n2 r1
  | Op_strength_reduction_case16 (r1, r2, n1, v2) -> make_xorimm n1 r2
  | Op_strength_reduction_case17 (r1, r2, v1, n2) -> make_xorimm n2 r1
  | Op_strength_reduction_case18 (r1, r2, v1, n2) -> make_shlimm n2 r1 r2
  | Op_strength_reduction_case19 (r1, r2, v1, n2) -> make_shrimm n2 r1 r2
  | Op_strength_reduction_case20 (r1, r2, v1, n2) -> make_shruimm n2 r1 r2
  | Op_strength_reduction_case21 (addr, args0, vl0) ->
    let Pair (addr', args') = addr_strength_reduction addr args0 vl0 in
    Pair ((Olea addr'), args')
  | Op_strength_reduction_case22 (c, args0, vl0) -> make_cmp0 c args0 vl0
  | Op_strength_reduction_case23 (r1, r2, v1, n2) -> make_mulfimm n2 r1 r1 r2
  | Op_strength_reduction_case24 (r1, r2, n1, v2) -> make_mulfimm n1 r2 r1 r2
  | Op_strength_reduction_case25 (r1, r2, v1, n2) ->
    make_mulfsimm n2 r1 r1 r2
  | Op_strength_reduction_case26 (r1, r2, n1, v2) ->
    make_mulfsimm n1 r2 r1 r2
  | Op_strength_reduction_default (op0, args0, vl0) -> Pair (op0, args0)

(** val transf_ros : AE.t -> (reg, ident) sum -> (reg, ident) sum **)

let transf_ros ae ros = match ros with
| Inl r ->
  (match areg ae r with
   | Ptr p ->
     (match p with
      | Gl (symb, ofs) ->
        (match Int.eq ofs Int.zero with
         | True -> Inr symb
         | False -> ros)
      | _ -> ros)
   | _ -> ros)
| Inr s -> ros

(** val const_for_result : aval0 -> operation option **)

let const_for_result = function
| I n0 -> Some (Ointconst1 n0)
| F n0 ->
  (match generate_float_constants Tt with
   | True -> Some (Ofloatconst1 n0)
   | False -> None)
| FS n0 ->
  (match generate_float_constants Tt with
   | True -> Some (Osingleconst1 n0)
   | False -> None)
| Ptr p ->
  (match p with
   | Gl (symb, ofs) -> Some (oaddrsymbol symb ofs)
   | Stk ofs -> Some (oaddrstack ofs)
   | _ -> None)
| _ -> None

(** val successor_rec : nat -> function4 -> AE.t -> node -> node **)

let rec successor_rec n0 f ae pc =
  match n0 with
  | O -> pc
  | S n' ->
    (match PTree.get pc f.fn_code with
     | Some i ->
       (match i with
        | Inop s -> successor_rec n' f ae s
        | Icond (cond, args, s1, s2) ->
          (match resolve_branch (eval_static_condition cond (aregs ae args)) with
           | Some b ->
             successor_rec n' f ae
               (match b with
                | True -> s1
                | False -> s2)
           | None -> pc)
        | _ -> pc)
     | None -> pc)

(** val num_iter : nat **)

let num_iter =
  S (S (S (S (S (S (S (S (S (S O)))))))))

(** val successor : function4 -> AE.t -> node -> node **)

let successor f ae pc =
  successor_rec num_iter f ae pc

(** val builtin_arg_reduction :
    AE.t -> reg builtin_arg -> reg builtin_arg **)

let rec builtin_arg_reduction ae a = match a with
| BA r ->
  (match areg ae r with
   | I n0 -> BA_int n0
   | L n0 -> BA_long n0
   | F n0 ->
     (match generate_float_constants Tt with
      | True -> BA_float n0
      | False -> a)
   | FS n0 ->
     (match generate_float_constants Tt with
      | True -> BA_single n0
      | False -> a)
   | _ -> a)
| BA_splitlong (hi, lo) ->
  (match builtin_arg_reduction ae hi with
   | BA_int nhi ->
     let hi' = BA_int nhi in
     (match builtin_arg_reduction ae lo with
      | BA_int nlo -> BA_long (Int64.ofwords nhi nlo)
      | x -> BA_splitlong (hi', x))
   | x -> BA_splitlong (x, (builtin_arg_reduction ae lo)))
| _ -> a

(** val builtin_arg_strength_reduction :
    AE.t -> reg builtin_arg -> builtin_arg_constraint -> reg builtin_arg **)

let builtin_arg_strength_reduction ae a c =
  let a' = builtin_arg_reduction ae a in
  (match builtin_arg_ok a' c with
   | True -> a'
   | False -> a)

(** val builtin_args_strength_reduction :
    AE.t -> reg builtin_arg list -> builtin_arg_constraint list -> reg
    builtin_arg list **)

let rec builtin_args_strength_reduction ae al cl =
  match al with
  | Nil -> Nil
  | Cons (a, al0) ->
    Cons ((builtin_arg_strength_reduction ae a (hd OK_default cl)),
      (builtin_args_strength_reduction ae al0 (tl cl)))

(** val debug_strength_reduction :
    AE.t -> reg builtin_arg list -> reg builtin_arg list **)

let rec debug_strength_reduction ae = function
| Nil -> Nil
| Cons (a, al0) ->
  let a' = builtin_arg_reduction ae a in
  let al' = Cons (a, (debug_strength_reduction ae al0)) in
  (match a with
   | BA x ->
     (match a' with
      | BA_int n0 -> Cons (a', al')
      | BA_long n0 -> Cons (a', al')
      | BA_float f -> Cons (a', al')
      | BA_single f -> Cons (a', al')
      | _ -> al')
   | _ -> al')

(** val builtin_strength_reduction :
    AE.t -> external_function -> reg builtin_arg list -> reg builtin_arg list **)

let builtin_strength_reduction ae ef al =
  match ef with
  | EF_debug (kind, text, targs) -> debug_strength_reduction ae al
  | _ -> builtin_args_strength_reduction ae al (builtin_constraints ef)

(** val transf_instr0 :
    function4 -> VA.t PMap.t -> romem -> node -> instruction -> instruction **)

let transf_instr0 f an rm pc instr =
  match PMap.get pc an with
  | VA.Bot -> instr
  | VA.State (ae, am) ->
    (match instr with
     | Iop (op, args, res2, s) ->
       let aargs = aregs ae args in
       let a = eval_static_operation op aargs in
       let s' = successor f (AE.set res2 a ae) s in
       (match const_for_result a with
        | Some cop -> Iop (cop, Nil, res2, s')
        | None ->
          let Pair (op', args') = op_strength_reduction op args aargs in
          Iop (op', args', res2, s'))
     | Iload (chunk, addr, args, dst, s) ->
       let aargs = aregs ae args in
       let a = loadv0 chunk rm am (eval_static_addressing addr aargs) in
       (match const_for_result a with
        | Some cop -> Iop (cop, Nil, dst, s)
        | None ->
          let Pair (addr', args') = addr_strength_reduction addr args aargs
          in
          Iload (chunk, addr', args', dst, s))
     | Istore (chunk, addr, args, src, s) ->
       let aargs = aregs ae args in
       let Pair (addr', args') = addr_strength_reduction addr args aargs in
       Istore (chunk, addr', args', src, s)
     | Icall (sig1, ros, args, res2, s) ->
       Icall (sig1, (transf_ros ae ros), args, res2, s)
     | Itailcall (sig1, ros, args) ->
       Itailcall (sig1, (transf_ros ae ros), args)
     | Ibuiltin (ef, args, res2, s) ->
       Ibuiltin (ef, (builtin_strength_reduction ae ef args), res2, s)
     | Icond (cond, args, s1, s2) ->
       let aargs = aregs ae args in
       (match resolve_branch (eval_static_condition cond aargs) with
        | Some b ->
          (match b with
           | True -> Inop s1
           | False -> Inop s2)
        | None ->
          let Pair (cond', args') = cond_strength_reduction cond args aargs
          in
          Icond (cond', args', s1, s2))
     | Ijumptable (arg, tbl) ->
       (match areg ae arg with
        | I n0 ->
          (match list_nth_z tbl (Int.unsigned n0) with
           | Some s -> Inop s
           | None -> instr)
        | _ -> instr)
     | _ -> instr)

(** val transf_function4 : romem -> function4 -> function4 **)

let transf_function4 rm f =
  let an = analyze0 rm f in
  { fn_sig2 = f.fn_sig2; fn_params3 = f.fn_params3; fn_stacksize =
  f.fn_stacksize; fn_code = (PTree.map (transf_instr0 f an rm) f.fn_code);
  fn_entrypoint = f.fn_entrypoint }

(** val transf_fundef4 : romem -> fundef4 -> fundef4 **)

let transf_fundef4 rm fd =
  transf_fundef (transf_function4 rm) fd

(** val transf_program3 : program4 -> program4 **)

let transf_program3 p =
  let rm = romem_for_program p in transform_program (transf_fundef4 rm) p

type valnum = positive

type rhs =
| Op of operation * valnum list
| Load of memory_chunk * addressing * valnum list

type equation =
| Eq0 of valnum * bool * rhs

(** val eq_list_valnum : valnum list -> valnum list -> sumbool **)

let eq_list_valnum =
  list_eq_dec peq

(** val eq_rhs : rhs -> rhs -> sumbool **)

let eq_rhs x y =
  match x with
  | Op (x0, x1) ->
    (match y with
     | Op (o0, l0) ->
       (match eq_operation x0 o0 with
        | Left -> eq_list_valnum x1 l0
        | Right -> Right)
     | Load (m0, a, l0) -> Right)
  | Load (x0, x1, x2) ->
    (match y with
     | Op (o, l0) -> Right
     | Load (m0, a0, l0) ->
       (match chunk_eq x0 m0 with
        | Left ->
          (match eq_addressing x1 a0 with
           | Left -> eq_list_valnum x2 l0
           | Right -> Right)
        | Right -> Right))

type numbering = { num_next : valnum; num_eqs : equation list;
                   num_reg : valnum PTree.t; num_val : reg list PMap.t }

(** val num_next : numbering -> valnum **)

let num_next x = x.num_next

(** val num_eqs : numbering -> equation list **)

let num_eqs x = x.num_eqs

(** val num_reg : numbering -> valnum PTree.t **)

let num_reg x = x.num_reg

(** val num_val : numbering -> reg list PMap.t **)

let num_val x = x.num_val

(** val empty_numbering : numbering **)

let empty_numbering =
  { num_next = XH; num_eqs = Nil; num_reg = PTree.empty; num_val =
    (PMap.init Nil) }

type valnum0 = positive

(** val combine_compimm_ne_0 :
    (valnum0 -> rhs option) -> valnum0 -> (condition, valnum0 list) prod
    option **)

let combine_compimm_ne_0 get0 x =
  match get0 x with
  | Some r ->
    (match r with
     | Op (o, ys) ->
       (match o with
        | Oandimm n0 -> Some (Pair ((Cmasknotzero n0), ys))
        | Ocmp0 c -> Some (Pair (c, ys))
        | _ -> None)
     | Load (m0, a, l) -> None)
  | None -> None

(** val combine_compimm_eq_0 :
    (valnum0 -> rhs option) -> valnum0 -> (condition, valnum0 list) prod
    option **)

let combine_compimm_eq_0 get0 x =
  match get0 x with
  | Some r ->
    (match r with
     | Op (o, ys) ->
       (match o with
        | Oandimm n0 -> Some (Pair ((Cmaskzero n0), ys))
        | Ocmp0 c -> Some (Pair ((negate_condition c), ys))
        | _ -> None)
     | Load (m0, a, l) -> None)
  | None -> None

(** val combine_compimm_eq_1 :
    (valnum0 -> rhs option) -> valnum0 -> (condition, valnum0 list) prod
    option **)

let combine_compimm_eq_1 get0 x =
  match get0 x with
  | Some r ->
    (match r with
     | Op (o, ys) ->
       (match o with
        | Ocmp0 c -> Some (Pair (c, ys))
        | _ -> None)
     | Load (m0, a, l) -> None)
  | None -> None

(** val combine_compimm_ne_1 :
    (valnum0 -> rhs option) -> valnum0 -> (condition, valnum0 list) prod
    option **)

let combine_compimm_ne_1 get0 x =
  match get0 x with
  | Some r ->
    (match r with
     | Op (o, ys) ->
       (match o with
        | Ocmp0 c -> Some (Pair ((negate_condition c), ys))
        | _ -> None)
     | Load (m0, a, l) -> None)
  | None -> None

(** val combine_cond :
    (valnum0 -> rhs option) -> condition -> valnum0 list -> (condition,
    valnum0 list) prod option **)

let combine_cond get0 cond args =
  match cond with
  | Ccompimm (c, n0) ->
    (match c with
     | Ceq ->
       (match args with
        | Nil -> None
        | Cons (x, l) ->
          (match l with
           | Nil ->
             (match Int.eq_dec n0 Int.zero with
              | Left -> combine_compimm_eq_0 get0 x
              | Right ->
                (match Int.eq_dec n0 Int.one with
                 | Left -> combine_compimm_eq_1 get0 x
                 | Right -> None))
           | Cons (v, l0) -> None))
     | Cne ->
       (match args with
        | Nil -> None
        | Cons (x, l) ->
          (match l with
           | Nil ->
             (match Int.eq_dec n0 Int.zero with
              | Left -> combine_compimm_ne_0 get0 x
              | Right ->
                (match Int.eq_dec n0 Int.one with
                 | Left -> combine_compimm_ne_1 get0 x
                 | Right -> None))
           | Cons (v, l0) -> None))
     | _ -> None)
  | Ccompuimm (c, n0) ->
    (match c with
     | Ceq ->
       (match args with
        | Nil -> None
        | Cons (x, l) ->
          (match l with
           | Nil ->
             (match Int.eq_dec n0 Int.zero with
              | Left -> combine_compimm_eq_0 get0 x
              | Right ->
                (match Int.eq_dec n0 Int.one with
                 | Left -> combine_compimm_eq_1 get0 x
                 | Right -> None))
           | Cons (v, l0) -> None))
     | Cne ->
       (match args with
        | Nil -> None
        | Cons (x, l) ->
          (match l with
           | Nil ->
             (match Int.eq_dec n0 Int.zero with
              | Left -> combine_compimm_ne_0 get0 x
              | Right ->
                (match Int.eq_dec n0 Int.one with
                 | Left -> combine_compimm_ne_1 get0 x
                 | Right -> None))
           | Cons (v, l0) -> None))
     | _ -> None)
  | _ -> None

(** val combine_addr :
    (valnum0 -> rhs option) -> addressing -> valnum0 list -> (addressing,
    valnum0 list) prod option **)

let combine_addr get0 addr args =
  match addr with
  | Aindexed n0 ->
    (match args with
     | Nil -> None
     | Cons (x, l) ->
       (match l with
        | Nil ->
          (match get0 x with
           | Some r ->
             (match r with
              | Op (o, ys) ->
                (match o with
                 | Olea a -> Some (Pair ((offset_addressing_total a n0), ys))
                 | _ -> None)
              | Load (m0, a, l0) -> None)
           | None -> None)
        | Cons (v, l0) -> None))
  | _ -> None

(** val combine_op :
    (valnum0 -> rhs option) -> operation -> valnum0 list -> (operation,
    valnum0 list) prod option **)

let combine_op get0 op args =
  match op with
  | Oandimm n0 ->
    (match args with
     | Nil -> None
     | Cons (x, l) ->
       (match l with
        | Nil ->
          (match get0 x with
           | Some r ->
             (match r with
              | Op (o, ys) ->
                (match o with
                 | Oandimm m0 ->
                   Some (Pair ((Oandimm (Int.coq_and m0 n0)), ys))
                 | _ -> None)
              | Load (m0, a, l0) -> None)
           | None -> None)
        | Cons (v, l0) -> None))
  | Oorimm n0 ->
    (match args with
     | Nil -> None
     | Cons (x, l) ->
       (match l with
        | Nil ->
          (match get0 x with
           | Some r ->
             (match r with
              | Op (o, ys) ->
                (match o with
                 | Oorimm m0 -> Some (Pair ((Oorimm (Int.coq_or m0 n0)), ys))
                 | _ -> None)
              | Load (m0, a, l0) -> None)
           | None -> None)
        | Cons (v, l0) -> None))
  | Oxorimm n0 ->
    (match args with
     | Nil -> None
     | Cons (x, l) ->
       (match l with
        | Nil ->
          (match get0 x with
           | Some r ->
             (match r with
              | Op (o, ys) ->
                (match o with
                 | Oxorimm m0 -> Some (Pair ((Oxorimm (Int.xor m0 n0)), ys))
                 | _ -> None)
              | Load (m0, a, l0) -> None)
           | None -> None)
        | Cons (v, l0) -> None))
  | Olea addr ->
    (match combine_addr get0 addr args with
     | Some p ->
       let Pair (addr', args') = p in Some (Pair ((Olea addr'), args'))
     | None -> None)
  | Ocmp0 cond ->
    (match combine_cond get0 cond args with
     | Some p ->
       let Pair (cond', args') = p in Some (Pair ((Ocmp0 cond'), args'))
     | None -> None)
  | _ -> None

(** val valnum_reg : numbering -> reg -> (numbering, valnum0) prod **)

let valnum_reg n0 r =
  match PTree.get r n0.num_reg with
  | Some v -> Pair (n0, v)
  | None ->
    let v = n0.num_next in
    Pair ({ num_next = (Coq_Pos.succ v); num_eqs = n0.num_eqs; num_reg =
    (PTree.set r v n0.num_reg); num_val =
    (PMap.set v (Cons (r, Nil)) n0.num_val) }, v)

(** val valnum_regs :
    numbering -> reg list -> (numbering, valnum0 list) prod **)

let rec valnum_regs n0 = function
| Nil -> Pair (n0, Nil)
| Cons (r1, rs) ->
  let Pair (n1, v1) = valnum_reg n0 r1 in
  let Pair (ns, vs) = valnum_regs n1 rs in Pair (ns, (Cons (v1, vs)))

(** val find_valnum_rhs : rhs -> equation list -> valnum0 option **)

let rec find_valnum_rhs r = function
| Nil -> None
| Cons (e, eqs3) ->
  let Eq0 (v, str, r') = e in
  (match match str with
         | True -> proj_sumbool (eq_rhs r r')
         | False -> False with
   | True -> Some v
   | False -> find_valnum_rhs r eqs3)

(** val find_valnum_rhs' : rhs -> equation list -> valnum0 option **)

let rec find_valnum_rhs' r = function
| Nil -> None
| Cons (e, eqs3) ->
  let Eq0 (v, str, r') = e in
  (match eq_rhs r r' with
   | Left -> Some v
   | Right -> find_valnum_rhs' r eqs3)

(** val find_valnum_num : valnum0 -> equation list -> rhs option **)

let rec find_valnum_num v = function
| Nil -> None
| Cons (e, eqs3) ->
  let Eq0 (v', str, r') = e in
  (match match str with
         | True -> proj_sumbool (peq v v')
         | False -> False with
   | True -> Some r'
   | False -> find_valnum_num v eqs3)

(** val reg_valnum : numbering -> valnum0 -> reg option **)

let reg_valnum n0 vn =
  match PMap.get vn n0.num_val with
  | Nil -> None
  | Cons (r, rs) -> Some r

(** val regs_valnums : numbering -> valnum0 list -> reg list option **)

let rec regs_valnums n0 = function
| Nil -> Some Nil
| Cons (v1, vs) ->
  (match reg_valnum n0 v1 with
   | Some r1 ->
     (match regs_valnums n0 vs with
      | Some rs -> Some (Cons (r1, rs))
      | None -> None)
   | None -> None)

(** val find_rhs : numbering -> rhs -> reg option **)

let find_rhs n0 rh =
  match find_valnum_rhs' rh n0.num_eqs with
  | Some vres -> reg_valnum n0 vres
  | None -> None

(** val forget_reg : numbering -> reg -> reg list PMap.t **)

let forget_reg n0 rd =
  match PTree.get rd n0.num_reg with
  | Some v -> PMap.set v (remove peq rd (PMap.get v n0.num_val)) n0.num_val
  | None -> n0.num_val

(** val update_reg : numbering -> reg -> valnum0 -> reg list PMap.t **)

let update_reg n0 rd vn =
  let nv = forget_reg n0 rd in PMap.set vn (Cons (rd, (PMap.get vn nv))) nv

(** val add_rhs : numbering -> reg -> rhs -> numbering **)

let add_rhs n0 rd rh =
  match find_valnum_rhs rh n0.num_eqs with
  | Some vres ->
    { num_next = n0.num_next; num_eqs = n0.num_eqs; num_reg =
      (PTree.set rd vres n0.num_reg); num_val = (update_reg n0 rd vres) }
  | None ->
    { num_next = (Coq_Pos.succ n0.num_next); num_eqs = (Cons ((Eq0
      (n0.num_next, True, rh)), n0.num_eqs)); num_reg =
      (PTree.set rd n0.num_next n0.num_reg); num_val =
      (update_reg n0 rd n0.num_next) }

(** val add_op : numbering -> reg -> operation -> reg list -> numbering **)

let add_op n0 rd op rs =
  match is_move_operation op rs with
  | Some r ->
    let Pair (n1, v) = valnum_reg n0 r in
    { num_next = n1.num_next; num_eqs = n1.num_eqs; num_reg =
    (PTree.set rd v n1.num_reg); num_val = (update_reg n1 rd v) }
  | None ->
    let Pair (n1, vs) = valnum_regs n0 rs in add_rhs n1 rd (Op (op, vs))

(** val add_load :
    numbering -> reg -> memory_chunk -> addressing -> reg list -> numbering **)

let add_load n0 rd chunk addr rs =
  let Pair (n1, vs) = valnum_regs n0 rs in
  add_rhs n1 rd (Load (chunk, addr, vs))

(** val set_unknown : numbering -> reg -> numbering **)

let set_unknown n0 rd =
  { num_next = n0.num_next; num_eqs = n0.num_eqs; num_reg =
    (PTree.remove rd n0.num_reg); num_val = (forget_reg n0 rd) }

(** val set_res_unknown : numbering -> reg builtin_res -> numbering **)

let set_res_unknown n0 = function
| BR r -> set_unknown n0 r
| _ -> n0

(** val kill_eqs : (rhs -> bool) -> equation list -> equation list **)

let rec kill_eqs pred0 = function
| Nil -> Nil
| Cons (eq0, rem0) ->
  let Eq0 (l, strict, r) = eq0 in
  (match pred0 r with
   | True -> kill_eqs pred0 rem0
   | False -> Cons (eq0, (kill_eqs pred0 rem0)))

(** val kill_equations : (rhs -> bool) -> numbering -> numbering **)

let kill_equations pred0 n0 =
  { num_next = n0.num_next; num_eqs = (kill_eqs pred0 n0.num_eqs); num_reg =
    n0.num_reg; num_val = n0.num_val }

(** val filter_loads : rhs -> bool **)

let filter_loads = function
| Op (op, l) -> op_depends_on_memory op
| Load (m0, a, l) -> True

(** val kill_all_loads : numbering -> numbering **)

let kill_all_loads n0 =
  kill_equations filter_loads n0

(** val filter_after_store :
    VA.t -> numbering -> aptr -> z -> rhs -> bool **)

let filter_after_store app0 n0 p sz = function
| Op (op, vl) -> op_depends_on_memory op
| Load (chunk, addr, vl) ->
  (match regs_valnums n0 vl with
   | Some rl ->
     negb (pdisjoint (aaddressing app0 addr rl) (size_chunk chunk) p sz)
   | None -> True)

(** val kill_loads_after_store :
    VA.t -> numbering -> memory_chunk -> addressing -> reg list -> numbering **)

let kill_loads_after_store app0 n0 chunk addr args =
  let p = aaddressing app0 addr args in
  kill_equations (filter_after_store app0 n0 p (size_chunk chunk)) n0

(** val store_normalized_range : memory_chunk -> aval0 **)

let store_normalized_range = function
| Mint8signed -> Sgn (Ptop, (Zpos (XO (XO (XO XH)))))
| Mint8unsigned -> Uns (Ptop, (Zpos (XO (XO (XO XH)))))
| Mint16signed -> Sgn (Ptop, (Zpos (XO (XO (XO (XO XH))))))
| Mint16unsigned -> Uns (Ptop, (Zpos (XO (XO (XO (XO XH))))))
| _ -> vtop

(** val add_store_result :
    VA.t -> numbering -> memory_chunk -> addressing -> reg list -> reg ->
    numbering **)

let add_store_result app0 n0 chunk addr rargs rsrc =
  match vincl (avalue app0 rsrc) (store_normalized_range chunk) with
  | True ->
    let Pair (n1, vsrc) = valnum_reg n0 rsrc in
    let Pair (n2, vargs) = valnum_regs n1 rargs in
    { num_next = n2.num_next; num_eqs = (Cons ((Eq0 (vsrc, False, (Load
    (chunk, addr, vargs)))), n2.num_eqs)); num_reg = n2.num_reg; num_val =
    n2.num_val }
  | False -> n0

(** val kill_loads_after_storebytes :
    VA.t -> numbering -> aptr -> z -> numbering **)

let kill_loads_after_storebytes app0 n0 dst sz =
  kill_equations (filter_after_store app0 n0 dst sz) n0

(** val shift_memcpy_eq : z -> z -> z -> equation -> equation option **)

let shift_memcpy_eq src sz delta = function
| Eq0 (l, strict, r) ->
  (match r with
   | Op (o, l0) -> None
   | Load (chunk, a, l0) ->
     (match a with
      | Ainstack i ->
        let i0 = Int.unsigned i in
        let j = Z.add i0 delta in
        (match match match match match proj_sumbool (zle src i0) with
                                 | True ->
                                   proj_sumbool
                                     (zle (Z.add i0 (size_chunk chunk))
                                       (Z.add src sz))
                                 | False -> False with
                           | True ->
                             proj_sumbool
                               (zeq (Z.modulo delta (align_chunk chunk)) Z0)
                           | False -> False with
                     | True -> proj_sumbool (zle Z0 j)
                     | False -> False with
               | True -> proj_sumbool (zle j Int.max_unsigned)
               | False -> False with
         | True ->
           Some (Eq0 (l, strict, (Load (chunk, (Ainstack (Int.repr j)),
             Nil))))
         | False -> None)
      | _ -> None))

(** val add_memcpy_eqs :
    z -> z -> z -> equation list -> equation list -> equation list **)

let rec add_memcpy_eqs src sz delta eqs3 eqs4 =
  match eqs3 with
  | Nil -> eqs4
  | Cons (e, eqs0) ->
    (match shift_memcpy_eq src sz delta e with
     | Some e' -> Cons (e', (add_memcpy_eqs src sz delta eqs0 eqs4))
     | None -> add_memcpy_eqs src sz delta eqs0 eqs4)

(** val add_memcpy :
    numbering -> numbering -> aptr -> aptr -> z -> numbering **)

let add_memcpy n1 n2 asrc adst sz =
  match asrc with
  | Stk src ->
    (match adst with
     | Stk dst ->
       { num_next = n2.num_next; num_eqs =
         (add_memcpy_eqs (Int.unsigned src) sz
           (Z.sub (Int.unsigned dst) (Int.unsigned src)) n1.num_eqs
           n2.num_eqs); num_reg = n2.num_reg; num_val = n2.num_val }
     | _ -> n2)
  | _ -> n2

(** val reduce_rec :
    ((valnum0 -> rhs option) -> 'a1 -> valnum0 list -> ('a1, valnum0 list)
    prod option) -> numbering -> nat -> 'a1 -> valnum0 list -> ('a1, reg
    list) prod option **)

let rec reduce_rec f n0 niter0 op args =
  match niter0 with
  | O -> None
  | S niter' ->
    (match f (fun v -> find_valnum_num v n0.num_eqs) op args with
     | Some p ->
       let Pair (op', args') = p in
       (match reduce_rec f n0 niter' op' args' with
        | Some p0 -> Some p0
        | None ->
          (match regs_valnums n0 args' with
           | Some rl -> Some (Pair (op', rl))
           | None -> None))
     | None -> None)

(** val reduce :
    ((valnum0 -> rhs option) -> 'a1 -> valnum0 list -> ('a1, valnum0 list)
    prod option) -> numbering -> 'a1 -> reg list -> valnum0 list -> ('a1, reg
    list) prod **)

let reduce f n0 op rl vl =
  match reduce_rec f n0 (S (S (S (S O)))) op vl with
  | Some res2 -> res2
  | None -> Pair (op, rl)

module Numbering = 
 struct 
  type t = numbering
  
  (** val top : numbering **)
  
  let top =
    empty_numbering
 end

module Solver = BBlock_solver(Numbering)

(** val transfer1 :
    function4 -> VA.t PMap.t -> node -> numbering -> numbering **)

let transfer1 f approx pc before =
  match PTree.get pc f.fn_code with
  | Some i ->
    (match i with
     | Iop (op, args, res2, s) -> add_op before res2 op args
     | Iload (chunk, addr, args, dst, s) ->
       add_load before dst chunk addr args
     | Istore (chunk, addr, args, src, s) ->
       let app0 = PMap.get pc approx in
       let n0 = kill_loads_after_store app0 before chunk addr args in
       add_store_result app0 n0 chunk addr args src
     | Icall (sig1, ros, args, res2, s) -> empty_numbering
     | Itailcall (sig1, ros, args) -> empty_numbering
     | Ibuiltin (ef, args, res2, s) ->
       (match ef with
        | EF_external (name, sg) -> empty_numbering
        | EF_builtin (name, sg) ->
          set_res_unknown (kill_all_loads before) res2
        | EF_vstore chunk -> set_res_unknown (kill_all_loads before) res2
        | EF_malloc -> empty_numbering
        | EF_free -> empty_numbering
        | EF_memcpy (sz, al) ->
          (match args with
           | Nil -> empty_numbering
           | Cons (dst, l) ->
             (match l with
              | Nil -> empty_numbering
              | Cons (src, l0) ->
                (match l0 with
                 | Nil ->
                   let app0 = PMap.get pc approx in
                   let adst = aaddr_arg app0 dst in
                   let asrc = aaddr_arg app0 src in
                   let n0 = kill_loads_after_storebytes app0 before adst sz
                   in
                   set_res_unknown (add_memcpy before n0 asrc adst sz) res2
                 | Cons (b, l1) -> empty_numbering)))
        | EF_inline_asm (text, sg, clobbers) -> empty_numbering
        | _ -> set_res_unknown before res2)
     | _ -> before)
  | None -> before

(** val analyze1 : function4 -> VA.t PMap.t -> numbering PMap.t option **)

let analyze1 f approx =
  Solver.fixpoint f.fn_code successors_instr (transfer1 f approx)
    f.fn_entrypoint

(** val transf_instr1 : numbering -> instruction -> instruction **)

let transf_instr1 n0 instr = match instr with
| Iop (op, args, res2, s) ->
  (match is_trivial_op op with
   | True -> instr
   | False ->
     let Pair (n1, vl) = valnum_regs n0 args in
     (match find_rhs n1 (Op (op, vl)) with
      | Some r -> Iop (Omove, (Cons (r, Nil)), res2, s)
      | None ->
        let Pair (op', args') = reduce combine_op n1 op args vl in
        Iop (op', args', res2, s)))
| Iload (chunk, addr, args, dst, s) ->
  let Pair (n1, vl) = valnum_regs n0 args in
  (match find_rhs n1 (Load (chunk, addr, vl)) with
   | Some r -> Iop (Omove, (Cons (r, Nil)), dst, s)
   | None ->
     let Pair (addr', args') = reduce combine_addr n1 addr args vl in
     Iload (chunk, addr', args', dst, s))
| Istore (chunk, addr, args, src, s) ->
  let Pair (n1, vl) = valnum_regs n0 args in
  let Pair (addr', args') = reduce combine_addr n1 addr args vl in
  Istore (chunk, addr', args', src, s)
| Icond (cond, args, s1, s2) ->
  let Pair (n1, vl) = valnum_regs n0 args in
  let Pair (cond', args') = reduce combine_cond n1 cond args vl in
  Icond (cond', args', s1, s2)
| _ -> instr

(** val transf_code : numbering PMap.t -> code -> code **)

let transf_code approxs instrs =
  PTree.map (fun pc instr -> transf_instr1 (PMap.get pc approxs) instr)
    instrs

(** val vanalyze : romem -> function4 -> VA.t PMap.t **)

let vanalyze =
  analyze0

(** val transf_function5 : romem -> function4 -> function4 res **)

let transf_function5 rm f =
  let approx = vanalyze rm f in
  (match analyze1 f approx with
   | Some approxs ->
     OK { fn_sig2 = f.fn_sig2; fn_params3 = f.fn_params3; fn_stacksize =
       f.fn_stacksize; fn_code = (transf_code approxs f.fn_code);
       fn_entrypoint = f.fn_entrypoint }
   | None ->
     Error
       (msg (String ((Ascii (True, True, False, False, False, False, True,
         False)), (String ((Ascii (True, True, False, False, True, False,
         True, False)), (String ((Ascii (True, False, True, False, False,
         False, True, False)), (String ((Ascii (False, False, False, False,
         False, True, False, False)), (String ((Ascii (False, True, True,
         False, False, True, True, False)), (String ((Ascii (True, False,
         False, False, False, True, True, False)), (String ((Ascii (True,
         False, False, True, False, True, True, False)), (String ((Ascii
         (False, False, True, True, False, True, True, False)), (String
         ((Ascii (True, False, True, False, True, True, True, False)),
         (String ((Ascii (False, True, False, False, True, True, True,
         False)), (String ((Ascii (True, False, True, False, False, True,
         True, False)), EmptyString))))))))))))))))))))))))

(** val transf_fundef5 : romem -> fundef4 -> fundef4 res **)

let transf_fundef5 rm f =
  transf_partial_fundef (transf_function5 rm) f

(** val transf_program4 : program4 -> program4 res **)

let transf_program4 p =
  transform_partial_program (transf_fundef5 (romem_for_program p)) p

module ISet = 
 struct 
  module R = 
   struct 
    type t =
    | Nil
    | Cons of z * z * t
    
    (** val t_rect : 'a1 -> (z -> z -> t -> 'a1 -> 'a1) -> t -> 'a1 **)
    
    let rec t_rect f f0 = function
    | Nil -> f
    | Cons (lo, hi, tl0) -> f0 lo hi tl0 (t_rect f f0 tl0)
    
    (** val t_rec : 'a1 -> (z -> z -> t -> 'a1 -> 'a1) -> t -> 'a1 **)
    
    let rec t_rec f f0 = function
    | Nil -> f
    | Cons (lo, hi, tl0) -> f0 lo hi tl0 (t_rec f f0 tl0)
    
    (** val mem : z -> t -> bool **)
    
    let rec mem x = function
    | Nil -> False
    | Cons (l, h, s') ->
      (match zlt x h with
       | Left -> proj_sumbool (zle l x)
       | Right -> mem x s')
    
    (** val contains : z -> z -> t -> bool **)
    
    let rec contains l h = function
    | Nil -> False
    | Cons (l0, h0, s') ->
      (match match proj_sumbool (zle h h0) with
             | True -> proj_sumbool (zle l0 l)
             | False -> False with
       | True -> True
       | False -> contains l h s')
    
    (** val add : z -> z -> t -> t **)
    
    let rec add l h s = match s with
    | Nil -> Cons (l, h, Nil)
    | Cons (l0, h0, s') ->
      (match zlt h0 l with
       | Left -> Cons (l0, h0, (add l h s'))
       | Right ->
         (match zlt h l0 with
          | Left -> Cons (l, h, s)
          | Right -> add (Z.min l0 l) (Z.max h0 h) s'))
    
    (** val remove : z -> z -> t -> t **)
    
    let rec remove l h s = match s with
    | Nil -> Nil
    | Cons (l0, h0, s') ->
      (match zlt h0 l with
       | Left -> Cons (l0, h0, (remove l h s'))
       | Right ->
         (match zlt h l0 with
          | Left -> s
          | Right ->
            (match zlt l0 l with
             | Left ->
               (match zlt h h0 with
                | Left -> Cons (l0, l, (Cons (h, h0, s')))
                | Right -> Cons (l0, l, (remove l h s')))
             | Right ->
               (match zlt h h0 with
                | Left -> Cons (h, h0, s')
                | Right -> remove l h s'))))
    
    (** val inter : t -> t -> t **)
    
    let rec inter s1 s2 =
      let rec intr s3 =
        match s1 with
        | Nil -> Nil
        | Cons (l1, h1, s1') ->
          (match s3 with
           | Nil -> Nil
           | Cons (l2, h2, s2') ->
             (match zle h1 l2 with
              | Left -> inter s1' s3
              | Right ->
                (match zle h2 l1 with
                 | Left -> intr s2'
                 | Right ->
                   (match zle l1 l2 with
                    | Left ->
                      (match zle h2 h1 with
                       | Left -> Cons (l2, h2, (intr s2'))
                       | Right -> Cons (l2, h1, (inter s1' s3)))
                    | Right ->
                      (match zle h1 h2 with
                       | Left -> Cons (l1, h1, (inter s1' s3))
                       | Right -> Cons (l1, h2, (intr s2')))))))
      in intr s2
    
    (** val union : t -> t -> t **)
    
    let rec union s1 s2 =
      match s1 with
      | Nil -> s2
      | Cons (l1, h1, s1') ->
        (match s2 with
         | Nil -> s1
         | Cons (l2, h2, s2') -> add l1 h1 (add l2 h2 (union s1' s2')))
    
    (** val beq : t -> t -> bool **)
    
    let rec beq s1 s2 =
      match s1 with
      | Nil ->
        (match s2 with
         | Nil -> True
         | Cons (lo, hi, tl0) -> False)
      | Cons (l1, h1, t1) ->
        (match s2 with
         | Nil -> False
         | Cons (l2, h2, t2) ->
           (match match proj_sumbool (zeq l1 l2) with
                  | True -> proj_sumbool (zeq h1 h2)
                  | False -> False with
            | True -> beq t1 t2
            | False -> False))
   end
  
  type t = R.t
  
  (** val empty : t **)
  
  let empty =
    R.Nil
  
  (** val interval : z -> z -> t **)
  
  let interval l h =
    match zlt l h with
    | Left -> R.Cons (l, h, R.Nil)
    | Right -> R.Nil
  
  (** val add : z -> z -> t -> t **)
  
  let add l h s =
    match zlt l h with
    | Left -> R.add l h s
    | Right -> s
  
  (** val remove : z -> z -> t -> t **)
  
  let remove l h s =
    match zlt l h with
    | Left -> R.remove l h s
    | Right -> s
  
  (** val inter : t -> t -> t **)
  
  let inter s1 s2 =
    R.inter s1 s2
  
  (** val union : t -> t -> t **)
  
  let union s1 s2 =
    R.union s1 s2
  
  (** val mem : z -> t -> bool **)
  
  let mem x s =
    R.mem x s
  
  (** val contains : z -> z -> t -> bool **)
  
  let contains l h s =
    match zlt l h with
    | Left -> R.contains l h s
    | Right -> True
  
  (** val beq : t -> t -> bool **)
  
  let beq s1 s2 =
    R.beq s1 s2
 end

type nval =
| Nothing
| I0 of Int.int
| All

(** val eq_nval : nval -> nval -> sumbool **)

let eq_nval x y =
  match x with
  | Nothing ->
    (match y with
     | Nothing -> Left
     | _ -> Right)
  | I0 x0 ->
    (match y with
     | I0 m0 -> Int.eq_dec x0 m0
     | _ -> Right)
  | All ->
    (match y with
     | All -> Left
     | _ -> Right)

(** val nlub : nval -> nval -> nval **)

let nlub x y =
  match x with
  | Nothing -> y
  | I0 m1 ->
    (match y with
     | Nothing -> x
     | I0 m2 -> I0 (Int.coq_or m1 m2)
     | All -> All)
  | All ->
    (match y with
     | Nothing -> x
     | _ -> All)

(** val complete_mask : Int.int -> Int.int **)

let complete_mask m0 =
  Int.zero_ext (Int.size m0) Int.mone

(** val andimm0 : nval -> Int.int -> nval **)

let andimm0 x n0 =
  match x with
  | Nothing -> Nothing
  | I0 m0 -> I0 (Int.coq_and m0 n0)
  | All -> I0 n0

(** val orimm0 : nval -> Int.int -> nval **)

let orimm0 x n0 =
  match x with
  | Nothing -> Nothing
  | I0 m0 -> I0 (Int.coq_and m0 (Int.not n0))
  | All -> I0 (Int.not n0)

(** val bitwise : nval -> nval **)

let bitwise x =
  x

(** val shlimm0 : nval -> Int.int -> nval **)

let shlimm0 x n0 =
  match x with
  | Nothing -> Nothing
  | I0 m0 -> I0 (Int.shru m0 n0)
  | All -> I0 (Int.shru Int.mone n0)

(** val shruimm0 : nval -> Int.int -> nval **)

let shruimm0 x n0 =
  match x with
  | Nothing -> Nothing
  | I0 m0 -> I0 (Int.shl m0 n0)
  | All -> I0 (Int.shl Int.mone n0)

(** val shrimm0 : nval -> Int.int -> nval **)

let shrimm0 x n0 =
  match x with
  | Nothing -> Nothing
  | I0 m0 ->
    I0
      (let m' = Int.shl m0 n0 in
       match Int.eq_dec (Int.shru m' n0) m0 with
       | Left -> m'
       | Right -> Int.coq_or m' (Int.repr Int.min_signed))
  | All -> I0 (Int.coq_or (Int.shl Int.mone n0) (Int.repr Int.min_signed))

(** val ror1 : nval -> Int.int -> nval **)

let ror1 x amount =
  match x with
  | I0 m0 -> I0 (Int.rol m0 amount)
  | x0 -> x0

(** val modarith : nval -> nval **)

let modarith = function
| I0 m0 -> I0 (complete_mask m0)
| x0 -> x0

(** val zero_ext1 : z -> nval -> nval **)

let zero_ext1 n0 = function
| Nothing -> Nothing
| I0 m0 -> I0 (Int.zero_ext n0 m0)
| All -> I0 (Int.zero_ext n0 Int.mone)

(** val sign_ext1 : z -> nval -> nval **)

let sign_ext1 n0 = function
| Nothing -> Nothing
| I0 m0 ->
  I0
    (Int.coq_or (Int.zero_ext n0 m0)
      (Int.shl Int.one (Int.repr (Z.sub n0 (Zpos XH)))))
| All -> I0 (Int.zero_ext n0 Int.mone)

(** val store_argument : memory_chunk -> nval **)

let store_argument = function
| Mint8signed -> I0 (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI XH)))))))))
| Mint8unsigned -> I0 (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI XH)))))))))
| Mint16signed ->
  I0
    (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI
      (XI XH)))))))))))))))))
| Mint16unsigned ->
  I0
    (Int.repr (Zpos (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI (XI
      (XI XH)))))))))))))))))
| _ -> All

(** val maskzero0 : Int.int -> nval **)

let maskzero0 n0 =
  I0 n0

(** val default : nval -> nval **)

let default = function
| Nothing -> Nothing
| _ -> All

(** val andimm_redundant : nval -> Int.int -> bool **)

let andimm_redundant x n0 =
  match x with
  | Nothing -> True
  | I0 m0 -> proj_sumbool (Int.eq_dec (Int.coq_and m0 (Int.not n0)) Int.zero)
  | All -> False

(** val orimm_redundant : nval -> Int.int -> bool **)

let orimm_redundant x n0 =
  match x with
  | Nothing -> True
  | I0 m0 -> proj_sumbool (Int.eq_dec (Int.coq_and m0 n0) Int.zero)
  | All -> False

(** val zero_ext_redundant : z -> nval -> bool **)

let zero_ext_redundant n0 = function
| Nothing -> True
| I0 m0 -> proj_sumbool (Int.eq_dec (Int.zero_ext n0 m0) m0)
| All -> False

(** val sign_ext_redundant : z -> nval -> bool **)

let sign_ext_redundant n0 = function
| Nothing -> True
| I0 m0 -> proj_sumbool (Int.eq_dec (Int.zero_ext n0 m0) m0)
| All -> False

module NVal = 
 struct 
  type t = nval
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    proj_sumbool (eq_nval x y)
  
  (** val bot : t **)
  
  let bot =
    Nothing
  
  (** val lub : nval -> nval -> nval **)
  
  let lub =
    nlub
 end

module NE = LPMap1(NVal)

type nenv = NE.t

(** val nreg : nenv -> reg -> NVal.t **)

let nreg ne r =
  NE.get r ne

type nmem =
| NMemDead
| NMem of ISet.t * ISet.t PTree.t

(** val nmem_all : nmem **)

let nmem_all =
  NMem (ISet.empty, PTree.empty)

(** val nmem_add : nmem -> aptr -> z -> nmem **)

let nmem_add nm p sz =
  match nm with
  | NMemDead -> nmem_all
  | NMem (stk, gl) ->
    (match p with
     | Gl (id, ofs) ->
       (match PTree.get id gl with
        | Some iv ->
          NMem (stk,
            (PTree.set id
              (ISet.remove (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz)
                iv) gl))
        | None -> nm)
     | Glo id -> NMem (stk, (PTree.remove id gl))
     | Stk ofs ->
       NMem
         ((ISet.remove (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz) stk),
         gl)
     | Stack -> NMem (ISet.empty, gl)
     | _ -> nmem_all)

(** val nmem_remove : nmem -> aptr -> z -> nmem **)

let nmem_remove nm p sz =
  match nm with
  | NMemDead -> NMemDead
  | NMem (stk, gl) ->
    (match p with
     | Gl (id, ofs) ->
       let iv' =
         match PTree.get id gl with
         | Some iv ->
           ISet.add (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz) iv
         | None ->
           ISet.interval (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz)
       in
       NMem (stk, (PTree.set id iv' gl))
     | Stk ofs ->
       NMem ((ISet.add (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz) stk),
         gl)
     | _ -> nm)

(** val nmem_contains : nmem -> aptr -> z -> bool **)

let nmem_contains nm p sz =
  match nm with
  | NMemDead -> False
  | NMem (stk, gl) ->
    (match p with
     | Gl (id, ofs) ->
       (match PTree.get id gl with
        | Some iv ->
          negb
            (ISet.contains (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz)
              iv)
        | None -> True)
     | Stk ofs ->
       negb
         (ISet.contains (Int.unsigned ofs) (Z.add (Int.unsigned ofs) sz) stk)
     | _ -> True)

(** val nmem_dead_stack : z -> nmem **)

let nmem_dead_stack sz =
  NMem ((ISet.interval Z0 sz), PTree.empty)

(** val nmem_lub : nmem -> nmem -> nmem **)

let nmem_lub nm1 nm2 =
  match nm1 with
  | NMemDead -> nm2
  | NMem (stk1, gl1) ->
    (match nm2 with
     | NMemDead -> nm1
     | NMem (stk2, gl2) ->
       NMem ((ISet.inter stk1 stk2),
         (PTree.combine (fun o1 o2 ->
           match o1 with
           | Some iv1 ->
             (match o2 with
              | Some iv2 -> Some (ISet.inter iv1 iv2)
              | None -> None)
           | None -> None) gl1 gl2)))

(** val nmem_beq : nmem -> nmem -> bool **)

let nmem_beq nm1 nm2 =
  match nm1 with
  | NMemDead ->
    (match nm2 with
     | NMemDead -> True
     | NMem (stk, gl) -> False)
  | NMem (stk1, gl1) ->
    (match nm2 with
     | NMemDead -> False
     | NMem (stk2, gl2) ->
       (match ISet.beq stk1 stk2 with
        | True -> PTree.beq ISet.beq gl1 gl2
        | False -> False))

module NA = 
 struct 
  type t = (nenv, nmem) prod
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    match NE.beq (fst x) (fst y) with
    | True -> nmem_beq (snd x) (snd y)
    | False -> False
  
  (** val bot : t **)
  
  let bot =
    Pair (NE.bot, NMemDead)
  
  (** val lub : t -> t -> t **)
  
  let lub x y =
    Pair ((NE.lub (fst x) (fst y)), (nmem_lub (snd x) (snd y)))
 end

(** val op1 : nval -> nval list **)

let op1 nv =
  Cons (nv, Nil)

(** val op2 : nval -> nval list **)

let op2 nv =
  Cons (nv, (Cons (nv, Nil)))

(** val needs_of_condition : condition -> nval list **)

let needs_of_condition = function
| Cmaskzero n0 -> op1 (maskzero0 n0)
| Cmasknotzero n0 -> op1 (maskzero0 n0)
| _ -> Nil

(** val needs_of_addressing : addressing -> nval -> nval list **)

let needs_of_addressing addr nv =
  match addr with
  | Aindexed n0 -> op1 (modarith nv)
  | Aindexed2 n0 -> op2 (modarith nv)
  | Aindexed2scaled (sc, ofs) -> op2 (modarith nv)
  | Aglobal (s, ofs) -> Nil
  | Abased (s, ofs) -> op1 (modarith nv)
  | Ainstack ofs -> Nil
  | _ -> op1 (modarith (modarith nv))

(** val needs_of_operation : operation -> nval -> nval list **)

let needs_of_operation op nv =
  match op with
  | Omove -> op1 nv
  | Ointconst1 n0 -> Nil
  | Ofloatconst1 n0 -> Nil
  | Osingleconst1 n0 -> Nil
  | Oindirectsymbol id -> Nil
  | Ocast8signed0 -> op1 (sign_ext1 (Zpos (XO (XO (XO XH)))) nv)
  | Ocast8unsigned0 -> op1 (zero_ext1 (Zpos (XO (XO (XO XH)))) nv)
  | Ocast16signed0 -> op1 (sign_ext1 (Zpos (XO (XO (XO (XO XH))))) nv)
  | Ocast16unsigned0 -> op1 (zero_ext1 (Zpos (XO (XO (XO (XO XH))))) nv)
  | Oneg0 -> op1 (modarith nv)
  | Omul1 -> op2 (modarith nv)
  | Omulimm n0 -> op1 (modarith nv)
  | Oand1 -> op2 (bitwise nv)
  | Oandimm n0 -> op1 (andimm0 nv n0)
  | Oor1 -> op2 (bitwise nv)
  | Oorimm n0 -> op1 (orimm0 nv n0)
  | Oxor1 -> op2 (bitwise nv)
  | Oxorimm n0 -> op1 (bitwise nv)
  | Onot -> op1 (bitwise nv)
  | Oshlimm n0 -> op1 (shlimm0 nv n0)
  | Oshrimm n0 -> op1 (shrimm0 nv n0)
  | Oshrximm n0 -> op1 (default nv)
  | Oshruimm n0 -> op1 (shruimm0 nv n0)
  | Ororimm n0 -> op1 (ror1 nv n0)
  | Oshldimm n0 -> op1 (default nv)
  | Olea addr -> needs_of_addressing addr nv
  | Onegf0 -> op1 (default nv)
  | Oabsf0 -> op1 (default nv)
  | Onegfs0 -> op1 (default nv)
  | Oabsfs0 -> op1 (default nv)
  | Osingleoffloat0 -> op1 (default nv)
  | Ofloatofsingle0 -> op1 (default nv)
  | Ointoffloat0 -> op1 (default nv)
  | Ofloatofint0 -> op1 (default nv)
  | Ointofsingle0 -> op1 (default nv)
  | Osingleofint0 -> op1 (default nv)
  | Olowlong -> op1 (default nv)
  | Ohighlong -> op1 (default nv)
  | Ocmp0 c -> needs_of_condition c
  | _ -> op2 (default nv)

(** val operation_is_redundant : operation -> nval -> bool **)

let operation_is_redundant op nv =
  match op with
  | Ocast8signed0 -> sign_ext_redundant (Zpos (XO (XO (XO XH)))) nv
  | Ocast8unsigned0 -> zero_ext_redundant (Zpos (XO (XO (XO XH)))) nv
  | Ocast16signed0 -> sign_ext_redundant (Zpos (XO (XO (XO (XO XH))))) nv
  | Ocast16unsigned0 -> zero_ext_redundant (Zpos (XO (XO (XO (XO XH))))) nv
  | Oandimm n0 -> andimm_redundant nv n0
  | Oorimm n0 -> orimm_redundant nv n0
  | _ -> False

(** val add_need_all : reg -> nenv -> nenv **)

let add_need_all r ne =
  NE.set r All ne

(** val add_need : reg -> nval -> nenv -> nenv **)

let add_need r nv ne =
  NE.set r (nlub nv (NE.get r ne)) ne

(** val add_needs_all : reg list -> nenv -> nenv **)

let rec add_needs_all rl ne =
  match rl with
  | Nil -> ne
  | Cons (r1, rs) -> add_need_all r1 (add_needs_all rs ne)

(** val add_needs : reg list -> nval list -> nenv -> nenv **)

let rec add_needs rl nvl ne =
  match rl with
  | Nil -> ne
  | Cons (r1, rs) ->
    (match nvl with
     | Nil -> add_needs_all rl ne
     | Cons (nv1, nvs) -> add_need r1 nv1 (add_needs rs nvs ne))

(** val add_ros_need_all : (reg, ident) sum -> nenv -> nenv **)

let add_ros_need_all ros ne =
  match ros with
  | Inl r -> add_need_all r ne
  | Inr s -> ne

(** val add_opt_need_all : reg option -> nenv -> nenv **)

let add_opt_need_all or2 ne =
  match or2 with
  | Some r -> add_need_all r ne
  | None -> ne

(** val kill : reg -> nenv -> nenv **)

let kill r ne =
  NE.set r Nothing ne

(** val is_dead : nval -> bool **)

let is_dead = function
| Nothing -> True
| _ -> False

(** val is_int_zero : nval -> bool **)

let is_int_zero = function
| I0 n0 -> Int.eq n0 Int.zero
| _ -> False

(** val transfer_builtin_arg : nval -> NA.t -> reg builtin_arg -> NA.t **)

let rec transfer_builtin_arg nv na a =
  let Pair (ne, nm) = na in
  (match a with
   | BA r -> Pair ((add_need r nv ne), nm)
   | BA_loadstack (chunk, ofs) ->
     Pair (ne, (nmem_add nm (Stk ofs) (size_chunk chunk)))
   | BA_loadglobal (chunk, id, ofs) ->
     Pair (ne, (nmem_add nm (Gl (id, ofs)) (size_chunk chunk)))
   | BA_splitlong (hi, lo) ->
     transfer_builtin_arg All (transfer_builtin_arg All na hi) lo
   | _ -> Pair (ne, nm))

(** val transfer_builtin_args : NA.t -> reg builtin_arg list -> NA.t **)

let transfer_builtin_args na al =
  fold_left (transfer_builtin_arg All) al na

(** val kill_builtin_res : reg builtin_res -> NE.t -> NE.t **)

let kill_builtin_res res2 ne =
  match res2 with
  | BR r -> kill r ne
  | _ -> ne

(** val transfer_builtin0 :
    VA.t -> external_function -> reg builtin_arg list -> reg builtin_res ->
    NE.t -> nmem -> NA.t **)

let transfer_builtin0 app0 ef args res2 ne nm =
  match ef with
  | EF_vload chunk ->
    (match args with
     | Nil ->
       transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
         args
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          transfer_builtin_arg All (Pair ((kill_builtin_res res2 ne),
            (nmem_add nm (aaddr_arg app0 a1) (size_chunk chunk)))) a1
        | Cons (b, l0) ->
          transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
            args))
  | EF_vstore chunk ->
    (match args with
     | Nil ->
       transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
         args
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
            args
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             transfer_builtin_arg All
               (transfer_builtin_arg (store_argument chunk) (Pair
                 ((kill_builtin_res res2 ne), nm)) a2) a1
           | Cons (b, l1) ->
             transfer_builtin_args (Pair ((kill_builtin_res res2 ne),
               nmem_all)) args)))
  | EF_memcpy (sz, al) ->
    (match args with
     | Nil ->
       transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
         args
     | Cons (dst, l) ->
       (match l with
        | Nil ->
          transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all))
            args
        | Cons (src, l0) ->
          (match l0 with
           | Nil ->
             (match nmem_contains nm (aaddr_arg app0 dst) sz with
              | True ->
                transfer_builtin_args (Pair ((kill_builtin_res res2 ne),
                  (nmem_add (nmem_remove nm (aaddr_arg app0 dst) sz)
                    (aaddr_arg app0 src) sz))) args
              | False -> Pair (ne, nm))
           | Cons (b, l1) ->
             transfer_builtin_args (Pair ((kill_builtin_res res2 ne),
               nmem_all)) args)))
  | EF_annot (text, targs) ->
    transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nm)) args
  | EF_annot_val (text, targ) ->
    transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nm)) args
  | EF_debug (kind, text, targs) -> Pair ((kill_builtin_res res2 ne), nm)
  | _ ->
    transfer_builtin_args (Pair ((kill_builtin_res res2 ne), nmem_all)) args

(** val transfer2 : function4 -> VA.t PMap.t -> node -> NA.t -> NA.t **)

let transfer2 f approx pc after = match after with
| Pair (ne, nm) ->
  (match PTree.get pc f.fn_code with
   | Some i ->
     (match i with
      | Inop s -> after
      | Iop (op, args, res2, s) ->
        let nres = nreg ne res2 in
        (match is_dead nres with
         | True -> after
         | False ->
           (match is_int_zero nres with
            | True -> Pair ((kill res2 ne), nm)
            | False ->
              Pair
                ((add_needs args (needs_of_operation op nres) (kill res2 ne)),
                nm)))
      | Iload (chunk, addr, args, dst, s) ->
        let ndst = nreg ne dst in
        (match is_dead ndst with
         | True -> after
         | False ->
           (match is_int_zero ndst with
            | True -> Pair ((kill dst ne), nm)
            | False ->
              Pair ((add_needs_all args (kill dst ne)),
                (nmem_add nm (aaddressing (PMap.get pc approx) addr args)
                  (size_chunk chunk)))))
      | Istore (chunk, addr, args, src, s) ->
        let p = aaddressing (PMap.get pc approx) addr args in
        (match nmem_contains nm p (size_chunk chunk) with
         | True ->
           Pair
             ((add_needs_all args (add_need src (store_argument chunk) ne)),
             (nmem_remove nm p (size_chunk chunk)))
         | False -> after)
      | Icall (sig1, ros, args, res2, s) ->
        Pair ((add_needs_all args (add_ros_need_all ros (kill res2 ne))),
          nmem_all)
      | Itailcall (sig1, ros, args) ->
        Pair ((add_needs_all args (add_ros_need_all ros NE.bot)),
          (nmem_dead_stack f.fn_stacksize))
      | Ibuiltin (ef, args, res2, s) ->
        transfer_builtin0 (PMap.get pc approx) ef args res2 ne nm
      | Icond (cond, args, s1, s2) ->
        Pair ((add_needs args (needs_of_condition cond) ne), nm)
      | Ijumptable (arg, tbl) -> Pair ((add_need_all arg ne), nm)
      | Ireturn optarg ->
        Pair ((add_opt_need_all optarg ne), (nmem_dead_stack f.fn_stacksize)))
   | None -> NA.bot)

module Coq0_DS = Backward_Dataflow_Solver(NA)(NodeSetBackward)

(** val analyze2 : VA.t PMap.t -> function4 -> NA.t PMap.t option **)

let analyze2 approx f =
  Coq0_DS.fixpoint f.fn_code successors_instr (transfer2 f approx)

(** val transf_instr2 :
    VA.t PMap.t -> NA.t PMap.t -> node -> instruction -> instruction **)

let transf_instr2 approx an pc instr = match instr with
| Iop (op, args, res2, s) ->
  let nres = nreg (fst (PMap.get pc an)) res2 in
  (match is_dead nres with
   | True -> Inop s
   | False ->
     (match is_int_zero nres with
      | True -> Iop ((Ointconst1 Int.zero), Nil, res2, s)
      | False ->
        (match operation_is_redundant op nres with
         | True ->
           (match args with
            | Nil -> instr
            | Cons (arg, l) -> Iop (Omove, (Cons (arg, Nil)), res2, s))
         | False -> instr)))
| Iload (chunk, addr, args, dst, s) ->
  let ndst = nreg (fst (PMap.get pc an)) dst in
  (match is_dead ndst with
   | True -> Inop s
   | False ->
     (match is_int_zero ndst with
      | True -> Iop ((Ointconst1 Int.zero), Nil, dst, s)
      | False -> instr))
| Istore (chunk, addr, args, src, s) ->
  let p = aaddressing (PMap.get pc approx) addr args in
  (match nmem_contains (snd (PMap.get pc an)) p (size_chunk chunk) with
   | True -> instr
   | False -> Inop s)
| Ibuiltin (e, l, res2, s) ->
  (match e with
   | EF_memcpy (sz, al) ->
     (match l with
      | Nil -> instr
      | Cons (dst, l0) ->
        (match l0 with
         | Nil -> instr
         | Cons (src, l1) ->
           (match l1 with
            | Nil ->
              (match nmem_contains (snd (PMap.get pc an))
                       (aaddr_arg (PMap.get pc approx) dst) sz with
               | True -> instr
               | False -> Inop s)
            | Cons (b, l2) -> instr)))
   | _ -> instr)
| _ -> instr

(** val vanalyze0 : romem -> function4 -> VA.t PMap.t **)

let vanalyze0 =
  analyze0

(** val transf_function6 : romem -> function4 -> function4 res **)

let transf_function6 rm f =
  let approx = vanalyze0 rm f in
  (match analyze2 approx f with
   | Some an ->
     OK { fn_sig2 = f.fn_sig2; fn_params3 = f.fn_params3; fn_stacksize =
       f.fn_stacksize; fn_code =
       (PTree.map (transf_instr2 approx an) f.fn_code); fn_entrypoint =
       f.fn_entrypoint }
   | None ->
     Error
       (msg (String ((Ascii (False, True, True, True, False, False, True,
         False)), (String ((Ascii (True, False, True, False, False, True,
         True, False)), (String ((Ascii (True, False, True, False, False,
         True, True, False)), (String ((Ascii (False, False, True, False,
         False, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (False, False,
         True, False, False, True, True, False)), (String ((Ascii (False,
         True, True, True, False, True, True, False)), (String ((Ascii (True,
         False, True, False, False, True, True, False)), (String ((Ascii
         (True, True, False, False, True, True, True, False)), (String
         ((Ascii (True, True, False, False, True, True, True, False)),
         (String ((Ascii (False, False, False, False, False, True, False,
         False)), (String ((Ascii (True, False, False, False, False, True,
         True, False)), (String ((Ascii (False, True, True, True, False,
         True, True, False)), (String ((Ascii (True, False, False, False,
         False, True, True, False)), (String ((Ascii (False, False, True,
         True, False, True, True, False)), (String ((Ascii (True, False,
         False, True, True, True, True, False)), (String ((Ascii (True, True,
         False, False, True, True, True, False)), (String ((Ascii (True,
         False, False, True, False, True, True, False)), (String ((Ascii
         (True, True, False, False, True, True, True, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (False, True, True, False, False, True, True,
         False)), (String ((Ascii (True, False, False, False, False, True,
         True, False)), (String ((Ascii (True, False, False, True, False,
         True, True, False)), (String ((Ascii (False, False, True, True,
         False, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (False, False,
         True, False, False, True, True, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val transf_fundef6 : romem -> fundef4 -> fundef4 res **)

let transf_fundef6 rm fd =
  transf_partial_fundef (transf_function6 rm) fd

(** val transf_program5 : program4 -> program4 res **)

let transf_program5 p =
  transform_partial_program (transf_fundef6 (romem_for_program p)) p

module IS = Coq_Make(OrderedPositive)

type workset = { w_seen : IS.t; w_todo : ident list }

(** val w_seen : workset -> IS.t **)

let w_seen x = x.w_seen

(** val w_todo : workset -> ident list **)

let w_todo x = x.w_todo

(** val add_workset : ident -> workset -> workset **)

let add_workset id w =
  match IS.mem id w.w_seen with
  | True -> w
  | False ->
    { w_seen = (IS.add id w.w_seen); w_todo = (Cons (id, w.w_todo)) }

(** val addlist_workset : ident list -> workset -> workset **)

let rec addlist_workset l w =
  match l with
  | Nil -> w
  | Cons (id, l') -> addlist_workset l' (add_workset id w)

(** val ref_instruction : instruction -> ident list **)

let ref_instruction = function
| Iop (op, l, r, n0) -> globals_operation op
| Iload (m0, addr, l, r, n0) -> globals_addressing addr
| Istore (m0, addr, l, r, n0) -> globals_addressing addr
| Icall (s, s0, l, r0, n0) ->
  (match s0 with
   | Inl r -> Nil
   | Inr id -> Cons (id, Nil))
| Itailcall (s, s0, l) ->
  (match s0 with
   | Inl r -> Nil
   | Inr id -> Cons (id, Nil))
| Ibuiltin (e, args, b, n0) -> globals_of_builtin_args args
| _ -> Nil

(** val add_ref_instruction : workset -> node -> instruction -> workset **)

let add_ref_instruction w pc i =
  addlist_workset (ref_instruction i) w

(** val add_ref_function : function4 -> workset -> workset **)

let add_ref_function f w =
  PTree.fold add_ref_instruction f.fn_code w

(** val add_ref_init_data : workset -> init_data -> workset **)

let add_ref_init_data w = function
| Init_addrof (id, i0) -> add_workset id w
| _ -> w

(** val add_ref_globvar : unit0 globvar -> workset -> workset **)

let add_ref_globvar gv w =
  fold_left add_ref_init_data gv.gvar_init w

type prog_map = (fundef4, unit0) globdef PTree.t

(** val add_ref_definition : prog_map -> ident -> workset -> workset **)

let add_ref_definition pm id w =
  match PTree.get id pm with
  | Some g ->
    (match g with
     | Gfun f0 ->
       (match f0 with
        | Internal f -> add_ref_function f w
        | External ef -> w)
     | Gvar gv -> add_ref_globvar gv w)
  | None -> w

(** val iter_step0 : prog_map -> workset -> (IS.t, workset) sum **)

let iter_step0 pm w =
  match w.w_todo with
  | Nil -> Inl w.w_seen
  | Cons (id, rem0) ->
    Inr (add_ref_definition pm id { w_seen = w.w_seen; w_todo = rem0 })

(** val initial_workset : program4 -> workset **)

let initial_workset p =
  add_workset p.prog_main
    (fold_left (fun w id -> add_workset id w) p.prog_public { w_seen =
      IS.empty; w_todo = Nil })

(** val add_def_prog_map :
    prog_map -> (ident, (fundef4, unit0) globdef) prod -> prog_map **)

let add_def_prog_map pm id_df =
  PTree.set (fst id_df) (snd id_df) pm

(** val program_map : program4 -> prog_map **)

let program_map p =
  fold_left add_def_prog_map p.prog_defs PTree.empty

(** val used_globals : program4 -> IS.t option **)

let used_globals p =
  let pm = program_map p in
  PrimIter.iterate (iter_step0 pm) (initial_workset p)

(** val filter_globdefs :
    IS.t -> (ident, (fundef4, unit0) globdef) prod list -> (ident, (fundef4,
    unit0) globdef) prod list -> (ident, (fundef4, unit0) globdef) prod list **)

let rec filter_globdefs used accu = function
| Nil -> accu
| Cons (p, defs') ->
  let Pair (id, gd) = p in
  (match IS.mem id used with
   | True ->
     filter_globdefs (IS.remove id used) (Cons ((Pair (id, gd)), accu)) defs'
   | False -> filter_globdefs used accu defs')

(** val transform_program0 : program4 -> program4 res **)

let transform_program0 p =
  match used_globals p with
  | Some used ->
    OK { prog_defs = (filter_globdefs used Nil (rev p.prog_defs));
      prog_public = p.prog_public; prog_main = p.prog_main }
  | None ->
    Error
      (msg (String ((Ascii (True, False, True, False, True, False, True,
        False)), (String ((Ascii (False, True, True, True, False, True, True,
        False)), (String ((Ascii (True, False, True, False, True, True, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, False, True, False, False,
        True, True, False)), (String ((Ascii (True, True, True, False, False,
        True, True, False)), (String ((Ascii (False, False, True, True,
        False, True, True, False)), (String ((Ascii (True, True, True, True,
        False, True, True, False)), (String ((Ascii (False, True, False,
        False, False, True, True, False)), (String ((Ascii (False, True,
        False, True, True, True, False, False)), (String ((Ascii (False,
        False, False, False, False, True, False, False)), (String ((Ascii
        (True, False, False, False, False, True, True, False)), (String
        ((Ascii (False, True, True, True, False, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, True, False, True, True,
        False)), (String ((Ascii (True, False, False, True, True, True, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, False, True, False, True,
        True, False)), (String ((Ascii (True, True, False, False, True, True,
        True, False)), (String ((Ascii (False, False, False, False, False,
        True, False, False)), (String ((Ascii (False, True, True, False,
        False, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (True, False,
        False, True, False, True, True, False)), (String ((Ascii (False,
        False, True, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, False, True, False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))

module Coq0_Make = 
 functor (X:Coq_OrderedType) ->
 struct 
  module X' = 
   struct 
    type t = X.t
    
    (** val eq_dec : t -> t -> sumbool **)
    
    let eq_dec =
      X.eq_dec
    
    (** val compare : X.t -> X.t -> comparison **)
    
    let compare x y =
      match X.compare x y with
      | LT -> Lt
      | EQ -> Eq
      | GT -> Gt
   end
  
  module MSet = IntMake(Z_as_Int)(X')
  
  type elt = X.t
  
  type t = MSet.t
  
  (** val empty : t **)
  
  let empty =
    MSet.empty
  
  (** val is_empty : t -> bool **)
  
  let is_empty =
    MSet.is_empty
  
  (** val mem : elt -> t -> bool **)
  
  let mem =
    MSet.mem
  
  (** val add : elt -> t -> t **)
  
  let add =
    MSet.add
  
  (** val singleton : elt -> t **)
  
  let singleton =
    MSet.singleton
  
  (** val remove : elt -> t -> t **)
  
  let remove =
    MSet.remove
  
  (** val union : t -> t -> t **)
  
  let union =
    MSet.union
  
  (** val inter : t -> t -> t **)
  
  let inter =
    MSet.inter
  
  (** val diff : t -> t -> t **)
  
  let diff =
    MSet.diff
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    MSet.eq_dec
  
  (** val equal : t -> t -> bool **)
  
  let equal =
    MSet.equal
  
  (** val subset : t -> t -> bool **)
  
  let subset =
    MSet.subset
  
  (** val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1 **)
  
  let fold x x0 x1 =
    MSet.fold x x0 x1
  
  (** val for_all : (elt -> bool) -> t -> bool **)
  
  let for_all =
    MSet.for_all
  
  (** val exists_ : (elt -> bool) -> t -> bool **)
  
  let exists_ =
    MSet.exists_
  
  (** val filter : (elt -> bool) -> t -> t **)
  
  let filter =
    MSet.filter
  
  (** val partition : (elt -> bool) -> t -> (t, t) prod **)
  
  let partition =
    MSet.partition
  
  (** val cardinal : t -> nat **)
  
  let cardinal =
    MSet.cardinal
  
  (** val elements : t -> elt list **)
  
  let elements =
    MSet.elements
  
  (** val choose : t -> elt option **)
  
  let choose =
    MSet.choose
  
  module MF = 
   struct 
    (** val eqb : X.t -> X.t -> bool **)
    
    let eqb x y =
      match MSet.E.eq_dec x y with
      | Left -> True
      | Right -> False
   end
  
  (** val min_elt : t -> elt option **)
  
  let min_elt =
    MSet.min_elt
  
  (** val max_elt : t -> elt option **)
  
  let max_elt =
    MSet.max_elt
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare s s' =
    let c = compSpec2Type s s' (MSet.compare s s') in
    (match c with
     | CompEqT -> EQ
     | CompLtT -> LT
     | CompGtT -> GT)
  
  module E = 
   struct 
    type t = X.t
    
    (** val compare : t -> t -> t compare0 **)
    
    let compare =
      X.compare
    
    (** val eq_dec : t -> t -> sumbool **)
    
    let eq_dec =
      X.eq_dec
   end
  
  module Raw = MSet.Raw
  
  (** val raw_mem_between :
      (elt -> bool) -> (elt -> bool) -> Raw.tree -> bool **)
  
  let rec raw_mem_between above_low_bound below_high_bound = function
  | Raw.Leaf -> False
  | Raw.Node (t1, l, x, r) ->
    (match above_low_bound x with
     | True ->
       (match below_high_bound x with
        | True -> True
        | False -> raw_mem_between above_low_bound below_high_bound l)
     | False -> raw_mem_between above_low_bound below_high_bound r)
  
  (** val mem_between : (elt -> bool) -> (elt -> bool) -> t -> bool **)
  
  let mem_between above_low_bound below_high_bound m0 =
    raw_mem_between above_low_bound below_high_bound
      (Obj.magic (MSet.this m0))
  
  (** val raw_elements_between :
      (elt -> bool) -> (elt -> bool) -> Raw.tree -> Raw.tree **)
  
  let rec raw_elements_between above_low_bound below_high_bound = function
  | Raw.Leaf -> Raw.Leaf
  | Raw.Node (t1, l, x, r) ->
    (match above_low_bound x with
     | True ->
       (match below_high_bound x with
        | True ->
          Raw.join (raw_elements_between above_low_bound below_high_bound l)
            x (raw_elements_between above_low_bound below_high_bound r)
        | False -> raw_elements_between above_low_bound below_high_bound l)
     | False -> raw_elements_between above_low_bound below_high_bound r)
  
  (** val elements_between : (elt -> bool) -> (elt -> bool) -> t -> t **)
  
  let elements_between above_low_bound below_high_bound s =
    Obj.magic
      (raw_elements_between above_low_bound below_high_bound
        (Obj.magic (MSet.this s)))
  
  (** val raw_for_all_between :
      (elt -> bool) -> (elt -> bool) -> (elt -> bool) -> Raw.tree -> bool **)
  
  let rec raw_for_all_between pred0 above_low_bound below_high_bound = function
  | Raw.Leaf -> True
  | Raw.Node (t1, l, x, r) ->
    (match above_low_bound x with
     | True ->
       (match below_high_bound x with
        | True ->
          (match match raw_for_all_between pred0 above_low_bound
                         below_high_bound l with
                 | True -> pred0 x
                 | False -> False with
           | True ->
             raw_for_all_between pred0 above_low_bound below_high_bound r
           | False -> False)
        | False ->
          raw_for_all_between pred0 above_low_bound below_high_bound l)
     | False -> raw_for_all_between pred0 above_low_bound below_high_bound r)
  
  (** val for_all_between :
      (elt -> bool) -> (elt -> bool) -> (elt -> bool) -> t -> bool **)
  
  let for_all_between pred0 above_low_bound below_high_bound m0 =
    raw_for_all_between pred0 above_low_bound below_high_bound
      (Obj.magic (MSet.this m0))
  
  (** val raw_partition_between :
      (elt -> bool) -> (elt -> bool) -> Raw.tree -> (Raw.tree, Raw.tree) prod **)
  
  let rec raw_partition_between above_low_bound below_high_bound = function
  | Raw.Leaf -> Pair (Raw.Leaf, Raw.Leaf)
  | Raw.Node (t1, l, x, r) ->
    (match above_low_bound x with
     | True ->
       (match below_high_bound x with
        | True ->
          let Pair (l1, l2) =
            raw_partition_between above_low_bound below_high_bound l
          in
          let Pair (r1, r2) =
            raw_partition_between above_low_bound below_high_bound r
          in
          Pair ((Raw.join l1 x r1), (Raw.concat l2 r2))
        | False ->
          let Pair (l1, l2) =
            raw_partition_between above_low_bound below_high_bound l
          in
          Pair (l1, (Raw.join l2 x r)))
     | False ->
       let Pair (r1, r2) =
         raw_partition_between above_low_bound below_high_bound r
       in
       Pair (r1, (Raw.join l x r2)))
  
  (** val partition_between :
      (elt -> bool) -> (elt -> bool) -> t -> (t, t) prod **)
  
  let partition_between above_low_bound below_high_bound s =
    let p =
      raw_partition_between above_low_bound below_high_bound
        (Obj.magic (MSet.this s))
    in
    Pair ((fst (Obj.magic p)), (snd (Obj.magic p)))
 end

module type TYPE_ALGEBRA = 
 sig 
  type t 
  
  val eq : t -> t -> sumbool
  
  val default : t
 end

module UniSolver = 
 functor (T:TYPE_ALGEBRA) ->
 struct 
  type coq_constraint = (positive, positive) prod
  
  type typenv = { te_typ : T.t PTree.t; te_equ : coq_constraint list }
  
  (** val typenv_rect :
      (T.t PTree.t -> coq_constraint list -> 'a1) -> typenv -> 'a1 **)
  
  let typenv_rect f t1 =
    let { te_typ = x; te_equ = x0 } = t1 in f x x0
  
  (** val typenv_rec :
      (T.t PTree.t -> coq_constraint list -> 'a1) -> typenv -> 'a1 **)
  
  let typenv_rec f t1 =
    let { te_typ = x; te_equ = x0 } = t1 in f x x0
  
  (** val te_typ : typenv -> T.t PTree.t **)
  
  let te_typ t1 =
    t1.te_typ
  
  (** val te_equ : typenv -> coq_constraint list **)
  
  let te_equ t1 =
    t1.te_equ
  
  (** val initial : typenv **)
  
  let initial =
    { te_typ = PTree.empty; te_equ = Nil }
  
  (** val set : typenv -> positive -> T.t -> typenv res **)
  
  let set e x ty =
    match PTree.get x (te_typ e) with
    | Some ty' ->
      (match T.eq ty ty' with
       | Left -> OK e
       | Right ->
         Error (Cons ((MSG (String ((Ascii (False, True, False, False, False,
           True, True, False)), (String ((Ascii (True, False, False, False,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)), (String ((Ascii (False, False,
           False, False, False, True, False, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (True, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, True, False, False, True, True, False)),
           (String ((Ascii (True, False, False, True, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, False, True, False,
           True, True, True, False)), (String ((Ascii (True, False, False,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, True, False)), (String ((Ascii
           (True, True, True, True, False, True, False, False)), (String
           ((Ascii (True, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, False, False, True, True, True,
           False)), (String ((Ascii (True, False, True, False, False, True,
           True, False)), (String ((Ascii (False, False, False, False, False,
           True, False, False)), (String ((Ascii (True, True, True, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           False, False, True, True, False)), (String ((Ascii (False, False,
           False, False, False, True, False, False)), (String ((Ascii (False,
           True, True, False, True, True, True, False)), (String ((Ascii
           (True, False, False, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, True, False, True, True,
           False)), (String ((Ascii (True, False, False, False, False, True,
           True, False)), (String ((Ascii (False, True, False, False, False,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, False,
           False, False, False, True, False, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))),
           (Cons ((POS x), Nil)))))
    | None ->
      OK { te_typ = (PTree.set x ty (te_typ e)); te_equ = (te_equ e) }
  
  (** val set_list : typenv -> positive list -> T.t list -> typenv res **)
  
  let rec set_list e rl tyl =
    match rl with
    | Nil ->
      (match tyl with
       | Nil -> OK e
       | Cons (t1, l) ->
         Error
           (msg (String ((Ascii (True, False, False, False, False, True,
             True, False)), (String ((Ascii (False, True, False, False, True,
             True, True, False)), (String ((Ascii (True, False, False, True,
             False, True, True, False)), (String ((Ascii (False, False, True,
             False, True, True, True, False)), (String ((Ascii (True, False,
             False, True, True, True, True, False)), (String ((Ascii (False,
             False, False, False, False, True, False, False)), (String
             ((Ascii (True, False, True, True, False, True, True, False)),
             (String ((Ascii (True, False, False, True, False, True, True,
             False)), (String ((Ascii (True, True, False, False, True, True,
             True, False)), (String ((Ascii (True, False, True, True, False,
             True, True, False)), (String ((Ascii (True, False, False, False,
             False, True, True, False)), (String ((Ascii (False, False, True,
             False, True, True, True, False)), (String ((Ascii (True, True,
             False, False, False, True, True, False)), (String ((Ascii
             (False, False, False, True, False, True, True, False)),
             EmptyString))))))))))))))))))))))))))))))
    | Cons (r1, rs) ->
      (match tyl with
       | Nil ->
         Error
           (msg (String ((Ascii (True, False, False, False, False, True,
             True, False)), (String ((Ascii (False, True, False, False, True,
             True, True, False)), (String ((Ascii (True, False, False, True,
             False, True, True, False)), (String ((Ascii (False, False, True,
             False, True, True, True, False)), (String ((Ascii (True, False,
             False, True, True, True, True, False)), (String ((Ascii (False,
             False, False, False, False, True, False, False)), (String
             ((Ascii (True, False, True, True, False, True, True, False)),
             (String ((Ascii (True, False, False, True, False, True, True,
             False)), (String ((Ascii (True, True, False, False, True, True,
             True, False)), (String ((Ascii (True, False, True, True, False,
             True, True, False)), (String ((Ascii (True, False, False, False,
             False, True, True, False)), (String ((Ascii (False, False, True,
             False, True, True, True, False)), (String ((Ascii (True, True,
             False, False, False, True, True, False)), (String ((Ascii
             (False, False, False, True, False, True, True, False)),
             EmptyString)))))))))))))))))))))))))))))
       | Cons (ty1, tys) ->
         bind (set e r1 ty1) (fun e1 -> set_list e1 rs tys))
  
  (** val move :
      typenv -> positive -> positive -> (bool, typenv) prod res **)
  
  let move e r1 r2 =
    match peq r1 r2 with
    | Left -> OK (Pair (False, e))
    | Right ->
      (match PTree.get r1 (te_typ e) with
       | Some ty1 ->
         (match PTree.get r2 (te_typ e) with
          | Some ty2 ->
            (match T.eq ty1 ty2 with
             | Left -> OK (Pair (False, e))
             | Right ->
               Error (Cons ((MSG (String ((Ascii (True, False, False, True,
                 False, True, True, False)), (String ((Ascii (False, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, True, True, False, True, True, False)),
                 (String ((Ascii (True, False, True, True, False, True,
                 False, False)), (String ((Ascii (False, False, True, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 False, True, True, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, False, True, False,
                 False, True, True, False)), (String ((Ascii (False, False,
                 False, False, False, True, False, False)), (String ((Ascii
                 (True, False, True, True, False, True, True, False)),
                 (String ((Ascii (True, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, True, True, False, True,
                 True, True, False)), (String ((Ascii (True, False, True,
                 False, False, True, True, False)), (String ((Ascii (False,
                 False, False, False, False, True, False, False)), (String
                 ((Ascii (False, True, True, False, False, True, True,
                 False)), (String ((Ascii (False, True, False, False, True,
                 True, True, False)), (String ((Ascii (True, True, True,
                 True, False, True, True, False)), (String ((Ascii (True,
                 False, True, True, False, True, True, False)), (String
                 ((Ascii (False, False, False, False, False, True, False,
                 False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))), (Cons
                 ((POS r1), (Cons ((MSG (String ((Ascii (False, False, False,
                 False, False, True, False, False)), (String ((Ascii (False,
                 False, True, False, True, True, True, False)), (String
                 ((Ascii (True, True, True, True, False, True, True, False)),
                 (String ((Ascii (False, False, False, False, False, True,
                 False, False)), EmptyString))))))))), (Cons ((POS r2),
                 Nil)))))))))
          | None ->
            OK (Pair (True, { te_typ = (PTree.set r2 ty1 (te_typ e));
              te_equ = (te_equ e) })))
       | None ->
         (match PTree.get r2 (te_typ e) with
          | Some ty2 ->
            OK (Pair (True, { te_typ = (PTree.set r1 ty2 (te_typ e));
              te_equ = (te_equ e) }))
          | None ->
            OK (Pair (False, { te_typ = (te_typ e); te_equ = (Cons ((Pair
              (r1, r2)), (te_equ e))) }))))
  
  (** val solve_rec :
      typenv -> bool -> coq_constraint list -> (typenv, bool) prod res **)
  
  let rec solve_rec e changed0 = function
  | Nil -> OK (Pair (e, changed0))
  | Cons (c, q') ->
    let Pair (r1, r2) = c in
    bind2 (move e r1 r2) (fun changed1 e1 ->
      solve_rec e1
        (match changed0 with
         | True -> True
         | False -> changed1) q')
  
  (** val weight_typenv : typenv -> nat **)
  
  let weight_typenv e =
    length (te_equ e)
  
  (** val solve_constraints_F :
      (typenv -> typenv res) -> typenv -> typenv res **)
  
  let solve_constraints_F solve_constraints0 e =
    match solve_rec { te_typ = (te_typ e); te_equ = Nil } False (te_equ e) with
    | OK p ->
      let Pair (e', b) = p in
      (match b with
       | True -> solve_constraints0 e'
       | False -> OK e)
    | Error msg0 -> Error msg0
  
  (** val solve_constraints_terminate : typenv -> typenv res **)
  
  let rec solve_constraints_terminate e =
    match solve_rec { te_typ = (te_typ e); te_equ = Nil } False (te_equ e) with
    | OK p ->
      let Pair (e', b) = p in
      (match b with
       | True -> solve_constraints_terminate e'
       | False -> OK e)
    | Error msg0 -> Error msg0
  
  (** val solve_constraints : typenv -> typenv res **)
  
  let solve_constraints x =
    solve_constraints_terminate x
  
  type coq_R_solve_constraints =
  | R_solve_constraints_0 of typenv * typenv
  | R_solve_constraints_1 of typenv * typenv * typenv res
     * coq_R_solve_constraints
  | R_solve_constraints_2 of typenv * errmsg
  
  (** val coq_R_solve_constraints_rect :
      (typenv -> typenv -> __ -> 'a1) -> (typenv -> typenv -> __ -> typenv
      res -> coq_R_solve_constraints -> 'a1 -> 'a1) -> (typenv -> errmsg ->
      __ -> 'a1) -> typenv -> typenv res -> coq_R_solve_constraints -> 'a1 **)
  
  let rec coq_R_solve_constraints_rect f f0 f1 e r = function
  | R_solve_constraints_0 (e0, e') -> f e0 e' __
  | R_solve_constraints_1 (e0, e', res2, r1) ->
    f0 e0 e' __ res2 r1 (coq_R_solve_constraints_rect f f0 f1 e' res2 r1)
  | R_solve_constraints_2 (e0, msg0) -> f1 e0 msg0 __
  
  (** val coq_R_solve_constraints_rec :
      (typenv -> typenv -> __ -> 'a1) -> (typenv -> typenv -> __ -> typenv
      res -> coq_R_solve_constraints -> 'a1 -> 'a1) -> (typenv -> errmsg ->
      __ -> 'a1) -> typenv -> typenv res -> coq_R_solve_constraints -> 'a1 **)
  
  let rec coq_R_solve_constraints_rec f f0 f1 e r = function
  | R_solve_constraints_0 (e0, e') -> f e0 e' __
  | R_solve_constraints_1 (e0, e', res2, r1) ->
    f0 e0 e' __ res2 r1 (coq_R_solve_constraints_rec f f0 f1 e' res2 r1)
  | R_solve_constraints_2 (e0, msg0) -> f1 e0 msg0 __
  
  (** val solve_constraints_rect :
      (typenv -> typenv -> __ -> 'a1) -> (typenv -> typenv -> __ -> 'a1 ->
      'a1) -> (typenv -> errmsg -> __ -> 'a1) -> typenv -> 'a1 **)
  
  let rec solve_constraints_rect f f0 f1 e =
    let f2 = f1 e in
    let f3 = f0 e in
    let f4 = f e in
    (match solve_rec { te_typ = (te_typ e); te_equ = Nil } False (te_equ e) with
     | OK p ->
       let Pair (t1, b) = p in
       (match b with
        | True ->
          let f5 = f3 t1 __ in
          let hrec = solve_constraints_rect f f0 f1 t1 in f5 hrec
        | False -> f4 t1 __)
     | Error e0 -> f2 e0 __)
  
  (** val solve_constraints_rec :
      (typenv -> typenv -> __ -> 'a1) -> (typenv -> typenv -> __ -> 'a1 ->
      'a1) -> (typenv -> errmsg -> __ -> 'a1) -> typenv -> 'a1 **)
  
  let solve_constraints_rec =
    solve_constraints_rect
  
  (** val coq_R_solve_constraints_correct :
      typenv -> typenv res -> coq_R_solve_constraints **)
  
  let coq_R_solve_constraints_correct x res2 =
    solve_constraints_rect (fun y y0 _ z0 _ -> R_solve_constraints_0 (y, y0))
      (fun y y0 _ y2 z0 _ -> R_solve_constraints_1 (y, y0,
      (solve_constraints y0), (y2 (solve_constraints y0) __)))
      (fun y y0 _ z0 _ -> R_solve_constraints_2 (y, y0)) x res2 __
  
  type typassign = positive -> T.t
  
  (** val makeassign : typenv -> typassign **)
  
  let makeassign e x =
    match PTree.get x (te_typ e) with
    | Some ty -> ty
    | None -> T.default
  
  (** val solve : typenv -> typassign res **)
  
  let solve e =
    bind (solve_constraints e) (fun e' -> OK (makeassign e'))
 end

type regenv = reg -> typ

module RTLtypes = 
 struct 
  type t = typ
  
  (** val eq : typ -> typ -> sumbool **)
  
  let eq =
    typ_eq
  
  (** val default : typ **)
  
  let default =
    Tint
 end

module S = UniSolver(RTLtypes)

(** val check_successor : function4 -> node -> unit0 res **)

let check_successor f s =
  match PTree.get s f.fn_code with
  | Some i -> OK Tt
  | None ->
    Error (Cons ((MSG (String ((Ascii (False, True, False, False, False,
      True, True, False)), (String ((Ascii (True, False, False, False, False,
      True, True, False)), (String ((Ascii (False, False, True, False, False,
      True, True, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), (String ((Ascii (True, True, False, False,
      True, True, True, False)), (String ((Ascii (True, False, True, False,
      True, True, True, False)), (String ((Ascii (True, True, False, False,
      False, True, True, False)), (String ((Ascii (True, True, False, False,
      False, True, True, False)), (String ((Ascii (True, False, True, False,
      False, True, True, False)), (String ((Ascii (True, True, False, False,
      True, True, True, False)), (String ((Ascii (True, True, False, False,
      True, True, True, False)), (String ((Ascii (True, True, True, True,
      False, True, True, False)), (String ((Ascii (False, True, False, False,
      True, True, True, False)), (String ((Ascii (False, False, False, False,
      False, True, False, False)), EmptyString))))))))))))))))))))))))))))),
      (Cons ((POS s), Nil))))

(** val check_successors : function4 -> node list -> unit0 res **)

let rec check_successors f = function
| Nil -> OK Tt
| Cons (s1, sl') ->
  bind (check_successor f s1) (fun x -> check_successors f sl')

(** val type_ros : S.typenv -> (reg, ident) sum -> S.typenv res **)

let type_ros e = function
| Inl r -> S.set e r Tint
| Inr s -> OK e

(** val is_move : operation -> bool **)

let is_move = function
| Omove -> True
| _ -> False

(** val type_expect : S.typenv -> typ -> typ -> S.typenv res **)

let type_expect e t1 t2 =
  match typ_eq t1 t2 with
  | Left -> OK e
  | Right ->
    Error
      (msg (String ((Ascii (True, False, True, False, True, True, True,
        False)), (String ((Ascii (False, True, True, True, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, False, False, True, True,
        True, True, False)), (String ((Ascii (False, False, False, False,
        True, True, True, False)), (String ((Ascii (True, False, True, False,
        False, True, True, False)), (String ((Ascii (True, True, False,
        False, False, True, True, False)), (String ((Ascii (False, False,
        True, False, True, True, True, False)), (String ((Ascii (True, False,
        True, False, False, True, True, False)), (String ((Ascii (False,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, False, False, False, False, True, False, False)), (String
        ((Ascii (False, False, True, False, True, True, True, False)),
        (String ((Ascii (True, False, False, True, True, True, True, False)),
        (String ((Ascii (False, False, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), EmptyString)))))))))))))))))))))))))))))))

(** val type_builtin_arg :
    S.typenv -> reg builtin_arg -> typ -> S.typenv res **)

let type_builtin_arg e a ty =
  match a with
  | BA r -> S.set e r ty
  | BA_long n0 -> type_expect e ty Tlong
  | BA_float f0 -> type_expect e ty Tfloat
  | BA_single f0 -> type_expect e ty Tsingle
  | BA_loadstack (chunk, ofs) -> type_expect e ty (type_of_chunk chunk)
  | BA_loadglobal (chunk, id, ofs) -> type_expect e ty (type_of_chunk chunk)
  | BA_splitlong (hi, lo) -> type_expect e ty Tlong
  | _ -> type_expect e ty Tint

(** val type_builtin_args :
    S.typenv -> reg builtin_arg list -> typ list -> S.typenv res **)

let rec type_builtin_args e al tyl =
  match al with
  | Nil ->
    (match tyl with
     | Nil -> OK e
     | Cons (t1, l) ->
       Error
         (msg (String ((Ascii (False, True, False, False, False, True, True,
           False)), (String ((Ascii (True, False, True, False, True, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, True, True, True, False)), (String ((Ascii (True, False,
           False, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, False, False, False, False, True, False, False)), (String
           ((Ascii (True, False, False, False, False, True, True, False)),
           (String ((Ascii (False, True, False, False, True, True, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (False, False, True, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           True, True, True, False)), (String ((Ascii (False, False, False,
           False, False, True, False, False)), (String ((Ascii (True, False,
           True, True, False, True, True, False)), (String ((Ascii (True,
           False, False, True, False, True, True, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (True, False, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, False,
           True, True, False)), (String ((Ascii (False, False, False, True,
           False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))
  | Cons (a1, al0) ->
    (match tyl with
     | Nil ->
       Error
         (msg (String ((Ascii (False, True, False, False, False, True, True,
           False)), (String ((Ascii (True, False, True, False, True, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, True, True, True, False)), (String ((Ascii (True, False,
           False, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, False, False, False, False, True, False, False)), (String
           ((Ascii (True, False, False, False, False, True, True, False)),
           (String ((Ascii (False, True, False, False, True, True, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (False, False, True, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           True, True, True, False)), (String ((Ascii (False, False, False,
           False, False, True, False, False)), (String ((Ascii (True, False,
           True, True, False, True, True, False)), (String ((Ascii (True,
           False, False, True, False, True, True, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (True, False, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, False,
           True, True, False)), (String ((Ascii (False, False, False, True,
           False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))
     | Cons (ty1, tyl0) ->
       bind (type_builtin_arg e a1 ty1) (fun e1 ->
         type_builtin_args e1 al0 tyl0))

(** val type_builtin_res :
    S.typenv -> reg builtin_res -> typ -> S.typenv res **)

let type_builtin_res e a ty =
  match a with
  | BR r -> S.set e r ty
  | _ -> type_expect e ty Tint

(** val type_instr : function4 -> S.typenv -> instruction -> S.typenv res **)

let type_instr f e = function
| Inop s -> bind (check_successor f s) (fun x -> OK e)
| Iop (op, args, res2, s) ->
  bind (check_successor f s) (fun x ->
    match is_move op with
    | True ->
      (match args with
       | Nil ->
         Error
           (msg (String ((Ascii (True, False, False, True, False, True, True,
             False)), (String ((Ascii (False, False, True, True, False, True,
             True, False)), (String ((Ascii (False, False, True, True, False,
             True, True, False)), (String ((Ascii (True, False, True, True,
             False, True, False, False)), (String ((Ascii (False, True, True,
             False, False, True, True, False)), (String ((Ascii (True, True,
             True, True, False, True, True, False)), (String ((Ascii (False,
             True, False, False, True, True, True, False)), (String ((Ascii
             (True, False, True, True, False, True, True, False)), (String
             ((Ascii (True, False, True, False, False, True, True, False)),
             (String ((Ascii (False, False, True, False, False, True, True,
             False)), (String ((Ascii (False, False, False, False, False,
             True, False, False)), (String ((Ascii (True, False, True, True,
             False, True, True, False)), (String ((Ascii (True, True, True,
             True, False, True, True, False)), (String ((Ascii (False, True,
             True, False, True, True, True, False)), (String ((Ascii (True,
             False, True, False, False, True, True, False)),
             EmptyString)))))))))))))))))))))))))))))))
       | Cons (arg, l) ->
         (match l with
          | Nil -> bind2 (S.move e res2 arg) (fun changed0 e' -> OK e')
          | Cons (r, l0) ->
            Error
              (msg (String ((Ascii (True, False, False, True, False, True,
                True, False)), (String ((Ascii (False, False, True, True,
                False, True, True, False)), (String ((Ascii (False, False,
                True, True, False, True, True, False)), (String ((Ascii
                (True, False, True, True, False, True, False, False)),
                (String ((Ascii (False, True, True, False, False, True, True,
                False)), (String ((Ascii (True, True, True, True, False,
                True, True, False)), (String ((Ascii (False, True, False,
                False, True, True, True, False)), (String ((Ascii (True,
                False, True, True, False, True, True, False)), (String
                ((Ascii (True, False, True, False, False, True, True,
                False)), (String ((Ascii (False, False, True, False, False,
                True, True, False)), (String ((Ascii (False, False, False,
                False, False, True, False, False)), (String ((Ascii (True,
                False, True, True, False, True, True, False)), (String
                ((Ascii (True, True, True, True, False, True, True, False)),
                (String ((Ascii (False, True, True, False, True, True, True,
                False)), (String ((Ascii (True, False, True, False, False,
                True, True, False)),
                EmptyString)))))))))))))))))))))))))))))))))
    | False ->
      let Pair (targs, tres) = type_of_operation op in
      bind (S.set_list e args targs) (fun e1 -> S.set e1 res2 tres))
| Iload (chunk, addr, args, dst, s) ->
  bind (check_successor f s) (fun x ->
    bind (S.set_list e args (type_of_addressing addr)) (fun e1 ->
      S.set e1 dst (type_of_chunk chunk)))
| Istore (chunk, addr, args, src, s) ->
  bind (check_successor f s) (fun x ->
    bind (S.set_list e args (type_of_addressing addr)) (fun e1 ->
      S.set e1 src (type_of_chunk chunk)))
| Icall (sig1, ros, args, res2, s) ->
  bind (check_successor f s) (fun x ->
    bind (type_ros e ros) (fun e1 ->
      bind (S.set_list e1 args sig1.sig_args) (fun e2 ->
        S.set e2 res2 (proj_sig_res sig1))))
| Itailcall (sig1, ros, args) ->
  bind (type_ros e ros) (fun e1 ->
    bind (S.set_list e1 args sig1.sig_args) (fun e2 ->
      match opt_typ_eq sig1.sig_res f.fn_sig2.sig_res with
      | Left ->
        (match tailcall_is_possible sig1 with
         | True -> OK e2
         | False ->
           Error
             (msg (String ((Ascii (False, False, True, False, True, True,
               True, False)), (String ((Ascii (True, False, False, False,
               False, True, True, False)), (String ((Ascii (True, False,
               False, True, False, True, True, False)), (String ((Ascii
               (False, False, True, True, False, True, True, False)), (String
               ((Ascii (True, True, False, False, False, True, True, False)),
               (String ((Ascii (True, False, False, False, False, True, True,
               False)), (String ((Ascii (False, False, True, True, False,
               True, True, False)), (String ((Ascii (False, False, True,
               True, False, True, True, False)), (String ((Ascii (False,
               False, False, False, False, True, False, False)), (String
               ((Ascii (False, True, True, True, False, True, True, False)),
               (String ((Ascii (True, True, True, True, False, True, True,
               False)), (String ((Ascii (False, False, True, False, True,
               True, True, False)), (String ((Ascii (False, False, False,
               False, False, True, False, False)), (String ((Ascii (False,
               False, False, False, True, True, True, False)), (String
               ((Ascii (True, True, True, True, False, True, True, False)),
               (String ((Ascii (True, True, False, False, True, True, True,
               False)), (String ((Ascii (True, True, False, False, True,
               True, True, False)), (String ((Ascii (True, False, False,
               True, False, True, True, False)), (String ((Ascii (False,
               True, False, False, False, True, True, False)), (String
               ((Ascii (False, False, True, True, False, True, True, False)),
               (String ((Ascii (True, False, True, False, False, True, True,
               False)),
               EmptyString))))))))))))))))))))))))))))))))))))))))))))
      | Right ->
        Error
          (msg (String ((Ascii (False, True, False, False, False, True, True,
            False)), (String ((Ascii (True, False, False, False, False, True,
            True, False)), (String ((Ascii (False, False, True, False, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            False, True, False, False)), (String ((Ascii (False, True, False,
            False, True, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, True, False, True, True, True, False)), (String ((Ascii
            (True, False, True, False, True, True, True, False)), (String
            ((Ascii (False, True, False, False, True, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), (String ((Ascii (False, False, False, False, False,
            True, False, False)), (String ((Ascii (False, False, True, False,
            True, True, True, False)), (String ((Ascii (True, False, False,
            True, True, True, True, False)), (String ((Ascii (False, False,
            False, False, True, True, True, False)), (String ((Ascii (True,
            False, True, False, False, True, True, False)), (String ((Ascii
            (False, False, False, False, False, True, False, False)), (String
            ((Ascii (True, False, False, True, False, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), (String ((Ascii (False, False, False, False, False,
            True, False, False)), (String ((Ascii (False, False, True, False,
            True, True, True, False)), (String ((Ascii (True, False, False,
            False, False, True, True, False)), (String ((Ascii (True, False,
            False, True, False, True, True, False)), (String ((Ascii (False,
            False, True, True, False, True, True, False)), (String ((Ascii
            (True, True, False, False, False, True, True, False)), (String
            ((Ascii (True, False, False, False, False, True, True, False)),
            (String ((Ascii (False, False, True, True, False, True, True,
            False)), (String ((Ascii (False, False, True, True, False, True,
            True, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
| Ibuiltin (ef, args, res2, s) ->
  let sig1 = ef_sig ef in
  bind (check_successor f s) (fun x ->
    bind
      (match ef with
       | EF_annot (text, targs) -> OK e
       | EF_debug (kind, text, targs) -> OK e
       | _ -> type_builtin_args e args sig1.sig_args) (fun e1 ->
      type_builtin_res e1 res2 (proj_sig_res sig1)))
| Icond (cond, args, s1, s2) ->
  bind (check_successor f s1) (fun x1 ->
    bind (check_successor f s2) (fun x2 ->
      S.set_list e args (type_of_condition cond)))
| Ijumptable (arg, tbl) ->
  bind (check_successors f tbl) (fun x ->
    bind (S.set e arg Tint) (fun e1 ->
      match zle (Z.mul (list_length_z tbl) (Zpos (XO (XO XH))))
              Int.max_unsigned with
      | Left -> OK e1
      | Right ->
        Error
          (msg (String ((Ascii (False, True, False, True, False, True, True,
            False)), (String ((Ascii (True, False, True, False, True, True,
            True, False)), (String ((Ascii (True, False, True, True, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            True, True, True, False)), (String ((Ascii (False, False, True,
            False, True, True, True, False)), (String ((Ascii (True, False,
            False, False, False, True, True, False)), (String ((Ascii (False,
            True, False, False, False, True, True, False)), (String ((Ascii
            (False, False, True, True, False, True, True, False)), (String
            ((Ascii (True, False, True, False, False, True, True, False)),
            (String ((Ascii (False, False, False, False, False, True, False,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (True, True, True, True, False,
            True, True, False)), (String ((Ascii (True, True, True, True,
            False, True, True, False)), (String ((Ascii (False, False, False,
            False, False, True, False, False)), (String ((Ascii (False, True,
            False, False, False, True, True, False)), (String ((Ascii (True,
            False, False, True, False, True, True, False)), (String ((Ascii
            (True, True, True, False, False, True, True, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))
| Ireturn optres ->
  (match optres with
   | Some r ->
     (match f.fn_sig2.sig_res with
      | Some t1 -> S.set e r t1
      | None ->
        Error
          (msg (String ((Ascii (False, True, False, False, False, True, True,
            False)), (String ((Ascii (True, False, False, False, False, True,
            True, False)), (String ((Ascii (False, False, True, False, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            False, True, False, False)), (String ((Ascii (False, True, False,
            False, True, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, True, False, True, True, True, False)), (String ((Ascii
            (True, False, True, False, True, True, True, False)), (String
            ((Ascii (False, True, False, False, True, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), EmptyString))))))))))))))))))))))
   | None ->
     (match f.fn_sig2.sig_res with
      | Some t1 ->
        Error
          (msg (String ((Ascii (False, True, False, False, False, True, True,
            False)), (String ((Ascii (True, False, False, False, False, True,
            True, False)), (String ((Ascii (False, False, True, False, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            False, True, False, False)), (String ((Ascii (False, True, False,
            False, True, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, True, False, True, True, True, False)), (String ((Ascii
            (True, False, True, False, True, True, True, False)), (String
            ((Ascii (False, True, False, False, True, True, True, False)),
            (String ((Ascii (False, True, True, True, False, True, True,
            False)), EmptyString)))))))))))))))))))))
      | None -> OK e))

(** val type_code : function4 -> S.typenv -> S.typenv res **)

let type_code f e =
  PTree.fold (fun re pc i ->
    match re with
    | OK e0 ->
      (match type_instr f e0 i with
       | OK e' -> OK e'
       | Error msg0 ->
         Error (Cons ((MSG (String ((Ascii (True, False, False, False, False,
           False, True, False)), (String ((Ascii (False, False, True, False,
           True, True, True, False)), (String ((Ascii (False, False, False,
           False, False, True, False, False)), (String ((Ascii (False, False,
           False, False, True, False, True, False)), (String ((Ascii (True,
           True, False, False, False, False, True, False)), (String ((Ascii
           (False, False, False, False, False, True, False, False)),
           EmptyString))))))))))))), (Cons ((POS pc), (Cons ((MSG (String
           ((Ascii (False, True, False, True, True, True, False, False)),
           (String ((Ascii (False, False, False, False, False, True, False,
           False)), EmptyString))))), msg0)))))))
    | Error e0 -> re) f.fn_code (OK e)

(** val check_params_norepet : reg list -> unit0 res **)

let check_params_norepet params =
  match list_norepet_dec Reg.eq params with
  | Left -> OK Tt
  | Right ->
    Error
      (msg (String ((Ascii (False, False, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, True, True, True,
        False)), (String ((Ascii (False, False, False, False, True, True,
        True, False)), (String ((Ascii (False, False, True, True, False,
        True, True, False)), (String ((Ascii (True, False, False, True,
        False, True, True, False)), (String ((Ascii (True, True, False,
        False, False, True, True, False)), (String ((Ascii (True, False,
        False, False, False, True, True, False)), (String ((Ascii (False,
        False, True, False, True, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, False, False, False, False, True, False, False)), (String
        ((Ascii (False, False, False, False, True, True, True, False)),
        (String ((Ascii (True, False, False, False, False, True, True,
        False)), (String ((Ascii (False, True, False, False, True, True,
        True, False)), (String ((Ascii (True, False, False, False, False,
        True, True, False)), (String ((Ascii (True, False, True, True, False,
        True, True, False)), (String ((Ascii (True, False, True, False,
        False, True, True, False)), (String ((Ascii (False, False, True,
        False, True, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (False, True,
        False, False, True, True, True, False)), (String ((Ascii (True, True,
        False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))

(** val type_function : function4 -> regenv res **)

let type_function f =
  bind (type_code f S.initial) (fun e1 ->
    bind (S.set_list e1 f.fn_params3 f.fn_sig2.sig_args) (fun e2 ->
      bind (S.solve e2) (fun te ->
        bind (check_params_norepet f.fn_params3) (fun x1 ->
          bind (check_successor f f.fn_entrypoint) (fun x2 -> OK te)))))

type moves = (loc, loc) prod list

type block_shape =
| BSnop of moves * node0
| BSmove of reg * reg * moves * node0
| BSmakelong of reg * reg * reg * moves * node0
| BSlowlong of reg * reg * moves * node0
| BShighlong of reg * reg * moves * node0
| BSop of operation * reg list * reg * moves * mreg list * mreg * moves
   * node0
| BSopdead of operation * reg list * reg * moves * node0
| BSload of memory_chunk * addressing * reg list * reg * moves * mreg list
   * mreg * moves * node0
| BSloaddead of memory_chunk * addressing * reg list * reg * moves * node0
| BSload2 of addressing * addressing * reg list * reg * moves * mreg list
   * mreg * moves * mreg list * mreg * moves * node0
| BSload2_1 of addressing * reg list * reg * moves * mreg list * mreg * 
   moves * node0
| BSload2_2 of addressing * addressing * reg list * reg * moves * mreg list
   * mreg * moves * node0
| BSstore of memory_chunk * addressing * reg list * reg * moves * mreg list
   * mreg * node0
| BSstore2 of addressing * addressing * reg list * reg * moves * mreg list
   * mreg * moves * mreg list * mreg * node0
| BScall of signature * (reg, ident) sum * reg list * reg * moves
   * (mreg, ident) sum * moves * node0
| BStailcall of signature * (reg, ident) sum * reg list * moves
   * (mreg, ident) sum
| BSbuiltin of external_function * reg builtin_arg list * reg builtin_res
   * moves * loc builtin_arg list * mreg builtin_res * moves * node0
| BScond of condition * reg list * moves * mreg list * node0 * node0
| BSjumptable of reg * moves * mreg * node0 list
| BSreturn of reg option * moves

(** val extract_moves : moves -> bblock -> (moves, bblock) prod **)

let rec extract_moves accu b = match b with
| Nil -> Pair ((rev accu), b)
| Cons (i, b') ->
  (match i with
   | Lop (op, args, res2) ->
     (match is_move_operation op args with
      | Some arg ->
        extract_moves (Cons ((Pair ((R arg), (R res2))), accu)) b'
      | None -> Pair ((rev accu), b))
   | Lgetstack (sl, ofs, ty, dst) ->
     extract_moves (Cons ((Pair ((S0 (sl, ofs, ty)), (R dst))), accu)) b'
   | Lsetstack (src, sl, ofs, ty) ->
     extract_moves (Cons ((Pair ((R src), (S0 (sl, ofs, ty)))), accu)) b'
   | _ -> Pair ((rev accu), b))

(** val check_succ : node0 -> bblock -> bool **)

let check_succ s = function
| Nil -> False
| Cons (i, l) ->
  (match i with
   | Lbranch s' -> proj_sumbool (peq s s')
   | _ -> False)

type operation_kind =
| Operation_Omove of reg
| Operation_Omakelong of reg * reg
| Operation_Olowlong of reg
| Operation_Ohighlong of reg
| Operation_other of operation * reg list

(** val classify_operation : operation -> reg list -> operation_kind **)

let classify_operation op args =
  match op with
  | Omove ->
    let op0 = Omove in
    (match args with
     | Nil -> Operation_other (op0, Nil)
     | Cons (arg, l) ->
       (match l with
        | Nil -> Operation_Omove arg
        | Cons (r, l0) -> Operation_other (op0, (Cons (arg, (Cons (r, l0)))))))
  | Omakelong ->
    let op0 = Omakelong in
    (match args with
     | Nil -> Operation_other (op0, Nil)
     | Cons (arg1, l) ->
       (match l with
        | Nil -> Operation_other (op0, (Cons (arg1, Nil)))
        | Cons (arg2, l0) ->
          (match l0 with
           | Nil -> Operation_Omakelong (arg1, arg2)
           | Cons (r, l1) ->
             Operation_other (op0, (Cons (arg1, (Cons (arg2, (Cons (r,
               l1))))))))))
  | Olowlong ->
    let op0 = Olowlong in
    (match args with
     | Nil -> Operation_other (op0, Nil)
     | Cons (arg, l) ->
       (match l with
        | Nil -> Operation_Olowlong arg
        | Cons (r, l0) -> Operation_other (op0, (Cons (arg, (Cons (r, l0)))))))
  | Ohighlong ->
    let op0 = Ohighlong in
    (match args with
     | Nil -> Operation_other (op0, Nil)
     | Cons (arg, l) ->
       (match l with
        | Nil -> Operation_Ohighlong arg
        | Cons (r, l0) -> Operation_other (op0, (Cons (arg, (Cons (r, l0)))))))
  | x -> Operation_other (x, args)

(** val pair_instr_block : instruction -> bblock -> block_shape option **)

let pair_instr_block i b =
  match i with
  | Inop s ->
    let Pair (mv, b1) = extract_moves Nil b in
    (match check_succ s b1 with
     | True -> Some (BSnop (mv, s))
     | False -> None)
  | Iop (op, args, res2, s) ->
    (match classify_operation op args with
     | Operation_Omove arg ->
       let Pair (mv, b1) = extract_moves Nil b in
       (match check_succ s b1 with
        | True -> Some (BSmove (arg, res2, mv, s))
        | False -> None)
     | Operation_Omakelong (arg1, arg2) ->
       let Pair (mv, b1) = extract_moves Nil b in
       (match check_succ s b1 with
        | True -> Some (BSmakelong (arg1, arg2, res2, mv, s))
        | False -> None)
     | Operation_Olowlong arg ->
       let Pair (mv, b1) = extract_moves Nil b in
       (match check_succ s b1 with
        | True -> Some (BSlowlong (arg, res2, mv, s))
        | False -> None)
     | Operation_Ohighlong arg ->
       let Pair (mv, b1) = extract_moves Nil b in
       (match check_succ s b1 with
        | True -> Some (BShighlong (arg, res2, mv, s))
        | False -> None)
     | Operation_other (op0, args0) ->
       let Pair (mv1, b1) = extract_moves Nil b in
       (match b1 with
        | Nil ->
          (match check_succ s b1 with
           | True -> Some (BSopdead (op, args, res2, mv1, s))
           | False -> None)
        | Cons (i0, b2) ->
          (match i0 with
           | Lop (op', args', res') ->
             let Pair (mv2, b3) = extract_moves Nil b2 in
             (match eq_operation op op' with
              | Left ->
                (match check_succ s b3 with
                 | True ->
                   Some (BSop (op, args, res2, mv1, args', res', mv2, s))
                 | False -> None)
              | Right -> None)
           | _ ->
             (match check_succ s b1 with
              | True -> Some (BSopdead (op, args, res2, mv1, s))
              | False -> None))))
  | Iload (chunk, addr, args, dst, s) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil ->
       (match check_succ s b1 with
        | True -> Some (BSloaddead (chunk, addr, args, dst, mv1, s))
        | False -> None)
     | Cons (i0, b2) ->
       (match i0 with
        | Lload (chunk', addr', args', dst') ->
          (match chunk_eq chunk Mint64 with
           | Left ->
             (match chunk_eq chunk' Mint32 with
              | Left ->
                let Pair (mv2, b3) = extract_moves Nil b2 in
                (match b3 with
                 | Nil ->
                   (match check_succ s b3 with
                    | True ->
                      (match eq_addressing addr addr' with
                       | Left ->
                         Some (BSload2_1 (addr, args, dst, mv1, args', dst',
                           mv2, s))
                       | Right ->
                         (match option_eq eq_addressing
                                  (offset_addressing addr
                                    (Int.repr (Zpos (XO (XO XH))))) (Some
                                  addr') with
                          | Left ->
                            Some (BSload2_2 (addr, addr', args, dst, mv1,
                              args', dst', mv2, s))
                          | Right -> None))
                    | False -> None)
                 | Cons (i1, b4) ->
                   (match i1 with
                    | Lload (chunk'', addr'', args'', dst'') ->
                      let Pair (mv3, b5) = extract_moves Nil b4 in
                      (match chunk_eq chunk'' Mint32 with
                       | Left ->
                         (match eq_addressing addr addr' with
                          | Left ->
                            (match option_eq eq_addressing
                                     (offset_addressing addr
                                       (Int.repr (Zpos (XO (XO XH))))) (Some
                                     addr'') with
                             | Left ->
                               (match check_succ s b5 with
                                | True ->
                                  Some (BSload2 (addr, addr'', args, dst,
                                    mv1, args', dst', mv2, args'', dst'',
                                    mv3, s))
                                | False -> None)
                             | Right -> None)
                          | Right -> None)
                       | Right -> None)
                    | _ ->
                      (match check_succ s b3 with
                       | True ->
                         (match eq_addressing addr addr' with
                          | Left ->
                            Some (BSload2_1 (addr, args, dst, mv1, args',
                              dst', mv2, s))
                          | Right ->
                            (match option_eq eq_addressing
                                     (offset_addressing addr
                                       (Int.repr (Zpos (XO (XO XH))))) (Some
                                     addr') with
                             | Left ->
                               Some (BSload2_2 (addr, addr', args, dst, mv1,
                                 args', dst', mv2, s))
                             | Right -> None))
                       | False -> None)))
              | Right -> None)
           | Right ->
             let Pair (mv2, b3) = extract_moves Nil b2 in
             (match chunk_eq chunk chunk' with
              | Left ->
                (match eq_addressing addr addr' with
                 | Left ->
                   (match check_succ s b3 with
                    | True ->
                      Some (BSload (chunk, addr, args, dst, mv1, args', dst',
                        mv2, s))
                    | False -> None)
                 | Right -> None)
              | Right -> None))
        | _ ->
          (match check_succ s b1 with
           | True -> Some (BSloaddead (chunk, addr, args, dst, mv1, s))
           | False -> None)))
  | Istore (chunk, addr, args, src, s) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Lstore (chunk', addr', args', src') ->
          (match chunk_eq chunk Mint64 with
           | Left ->
             let Pair (mv2, b3) = extract_moves Nil b2 in
             (match b3 with
              | Nil -> None
              | Cons (i1, b4) ->
                (match i1 with
                 | Lstore (chunk'', addr'', args'', src'') ->
                   (match chunk_eq chunk' Mint32 with
                    | Left ->
                      (match chunk_eq chunk'' Mint32 with
                       | Left ->
                         (match eq_addressing addr addr' with
                          | Left ->
                            (match option_eq eq_addressing
                                     (offset_addressing addr
                                       (Int.repr (Zpos (XO (XO XH))))) (Some
                                     addr'') with
                             | Left ->
                               (match check_succ s b4 with
                                | True ->
                                  Some (BSstore2 (addr, addr'', args, src,
                                    mv1, args', src', mv2, args'', src'', s))
                                | False -> None)
                             | Right -> None)
                          | Right -> None)
                       | Right -> None)
                    | Right -> None)
                 | _ -> None))
           | Right ->
             (match chunk_eq chunk chunk' with
              | Left ->
                (match eq_addressing addr addr' with
                 | Left ->
                   (match check_succ s b2 with
                    | True ->
                      Some (BSstore (chunk, addr, args, src, mv1, args',
                        src', s))
                    | False -> None)
                 | Right -> None)
              | Right -> None))
        | _ -> None))
  | Icall (sg, ros, args, res2, s) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Lcall (sg', ros') ->
          let Pair (mv2, b3) = extract_moves Nil b2 in
          (match signature_eq sg sg' with
           | Left ->
             (match check_succ s b3 with
              | True ->
                Some (BScall (sg, ros, args, res2, mv1, ros', mv2, s))
              | False -> None)
           | Right -> None)
        | _ -> None))
  | Itailcall (sg, ros, args) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Ltailcall (sg', ros') ->
          (match signature_eq sg sg' with
           | Left -> Some (BStailcall (sg, ros, args, mv1, ros'))
           | Right -> None)
        | _ -> None))
  | Ibuiltin (ef, args, res2, s) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Lbuiltin (ef', args', res') ->
          let Pair (mv2, b3) = extract_moves Nil b2 in
          (match external_function_eq ef ef' with
           | Left ->
             (match check_succ s b3 with
              | True ->
                Some (BSbuiltin (ef, args, res2, mv1, args', res', mv2, s))
              | False -> None)
           | Right -> None)
        | _ -> None))
  | Icond (cond, args, s1, s2) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Lcond (cond', args', s1', s2') ->
          (match eq_condition cond cond' with
           | Left ->
             (match peq s1 s1' with
              | Left ->
                (match peq s2 s2' with
                 | Left -> Some (BScond (cond, args, mv1, args', s1, s2))
                 | Right -> None)
              | Right -> None)
           | Right -> None)
        | _ -> None))
  | Ijumptable (arg, tbl) ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Ljumptable (arg', tbl') ->
          (match list_eq_dec peq tbl tbl' with
           | Left -> Some (BSjumptable (arg, mv1, arg', tbl))
           | Right -> None)
        | _ -> None))
  | Ireturn arg ->
    let Pair (mv1, b1) = extract_moves Nil b in
    (match b1 with
     | Nil -> None
     | Cons (i0, b2) ->
       (match i0 with
        | Lreturn -> Some (BSreturn (arg, mv1))
        | _ -> None))

(** val pair_codes : function4 -> function5 -> block_shape PTree.t **)

let pair_codes f1 f2 =
  PTree.combine (fun opti optb ->
    match opti with
    | Some i ->
      (match optb with
       | Some b -> pair_instr_block i b
       | None -> None)
    | None -> None) f1.fn_code f2.fn_code0

(** val pair_entrypoints : function4 -> function5 -> moves option **)

let pair_entrypoints f1 f2 =
  match PTree.get f2.fn_entrypoint0 f2.fn_code0 with
  | Some b ->
    let Pair (mv, b1) = extract_moves Nil b in
    (match check_succ f1.fn_entrypoint b1 with
     | True -> Some mv
     | False -> None)
  | None -> None

type equation_kind =
| Full
| Low
| High

type equation0 = { ekind : equation_kind; ereg : reg; eloc : loc }

(** val ekind : equation0 -> equation_kind **)

let ekind x = x.ekind

(** val ereg : equation0 -> reg **)

let ereg x = x.ereg

(** val eloc : equation0 -> loc **)

let eloc x = x.eloc

module IndexedEqKind = 
 struct 
  type t = equation_kind
  
  (** val index : t -> positive **)
  
  let index = function
  | Full -> XH
  | Low -> XO XH
  | High -> XI XH
  
  (** val eq : t -> t -> sumbool **)
  
  let eq x y =
    match x with
    | Full ->
      (match y with
       | Full -> Left
       | _ -> Right)
    | Low ->
      (match y with
       | Low -> Left
       | _ -> Right)
    | High ->
      (match y with
       | High -> Left
       | _ -> Right)
 end

module OrderedEqKind = OrderedIndexed(IndexedEqKind)

module OrderedEquation = 
 struct 
  type t = equation0
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare x y =
    let c = OrderedPositive.compare x.ereg y.ereg in
    (match c with
     | LT -> LT
     | EQ ->
       let c0 = OrderedLoc.compare x.eloc y.eloc in
       (match c0 with
        | LT -> LT
        | EQ ->
          let c1 = OrderedEqKind.compare x.ekind y.ekind in
          (match c1 with
           | LT -> LT
           | EQ -> EQ
           | GT -> GT)
        | GT -> GT)
     | GT -> GT)
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec x y =
    let { ekind = x0; ereg = x1; eloc = x2 } = x in
    let { ekind = ekind1; ereg = ereg1; eloc = eloc1 } = y in
    (match IndexedEqKind.eq x0 ekind1 with
     | Left ->
       (match peq x1 ereg1 with
        | Left -> Loc.eq x2 eloc1
        | Right -> Right)
     | Right -> Right)
 end

module OrderedEquation' = 
 struct 
  type t = equation0
  
  (** val compare : t -> t -> t compare0 **)
  
  let compare x y =
    let c = OrderedLoc.compare x.eloc y.eloc in
    (match c with
     | LT -> LT
     | EQ ->
       let c0 = OrderedPositive.compare x.ereg y.ereg in
       (match c0 with
        | LT -> LT
        | EQ ->
          let c1 = OrderedEqKind.compare x.ekind y.ekind in
          (match c1 with
           | LT -> LT
           | EQ -> EQ
           | GT -> GT)
        | GT -> GT)
     | GT -> GT)
  
  (** val eq_dec : t -> t -> sumbool **)
  
  let eq_dec =
    OrderedEquation.eq_dec
 end

module EqSet = Coq0_Make(OrderedEquation)

module EqSet2 = Coq0_Make(OrderedEquation')

type eqs = { eqs1 : EqSet.t; eqs2 : EqSet2.t }

(** val eqs1 : eqs -> EqSet.t **)

let eqs1 x = x.eqs1

(** val eqs2 : eqs -> EqSet2.t **)

let eqs2 x = x.eqs2

(** val empty_eqs : eqs **)

let empty_eqs =
  { eqs1 = EqSet.empty; eqs2 = EqSet2.empty }

(** val add_equation : equation0 -> eqs -> eqs **)

let add_equation q e =
  { eqs1 = (EqSet.add q e.eqs1); eqs2 = (EqSet2.add q e.eqs2) }

(** val remove_equation : equation0 -> eqs -> eqs **)

let remove_equation q e =
  { eqs1 = (EqSet.remove q e.eqs1); eqs2 = (EqSet2.remove q e.eqs2) }

(** val select_reg_l : reg -> equation0 -> bool **)

let select_reg_l r q =
  Coq_Pos.leb r q.ereg

(** val select_reg_h : reg -> equation0 -> bool **)

let select_reg_h r q =
  Coq_Pos.leb q.ereg r

(** val reg_unconstrained : reg -> eqs -> bool **)

let reg_unconstrained r e =
  negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e.eqs1)

(** val select_loc_l : loc -> equation0 -> bool **)

let select_loc_l l =
  let lb = OrderedLoc.diff_low_bound l in
  (fun q ->
  match OrderedLoc.compare q.eloc lb with
  | LT -> False
  | _ -> True)

(** val select_loc_h : loc -> equation0 -> bool **)

let select_loc_h l =
  let lh = OrderedLoc.diff_high_bound l in
  (fun q ->
  match OrderedLoc.compare q.eloc lh with
  | GT -> False
  | _ -> True)

(** val loc_unconstrained : loc -> eqs -> bool **)

let loc_unconstrained l e =
  negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) e.eqs2)

(** val reg_loc_unconstrained : reg -> loc -> eqs -> bool **)

let reg_loc_unconstrained r l e =
  match reg_unconstrained r e with
  | True -> loc_unconstrained l e
  | False -> False

(** val subst_reg : reg -> reg -> eqs -> eqs **)

let subst_reg r1 r2 e =
  EqSet.fold (fun q e0 ->
    add_equation { ekind = q.ekind; ereg = r2; eloc = q.eloc }
      (remove_equation q e0))
    (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e.eqs1) e

(** val subst_reg_kind :
    reg -> equation_kind -> reg -> equation_kind -> eqs -> eqs **)

let subst_reg_kind r1 k1 r2 k2 e =
  EqSet.fold (fun q e0 ->
    match IndexedEqKind.eq q.ekind k1 with
    | Left ->
      add_equation { ekind = k2; ereg = r2; eloc = q.eloc }
        (remove_equation q e0)
    | Right -> e0)
    (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e.eqs1) e

(** val subst_loc : loc -> loc -> eqs -> eqs option **)

let subst_loc l1 l2 e =
  EqSet2.fold (fun q opte ->
    match opte with
    | Some e0 ->
      (match Loc.eq l1 q.eloc with
       | Left ->
         Some
           (add_equation { ekind = q.ekind; ereg = q.ereg; eloc = l2 }
             (remove_equation q e0))
       | Right -> None)
    | None -> None)
    (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) e.eqs2)
    (Some e)

(** val sel_type : equation_kind -> typ -> typ **)

let sel_type k ty =
  match k with
  | Full -> ty
  | _ -> Tint

(** val loc_type_compat : regenv -> loc -> eqs -> bool **)

let loc_type_compat env l e =
  EqSet2.for_all_between (fun q ->
    subtype (sel_type q.ekind (env q.ereg)) (Loc.coq_type l))
    (select_loc_l l) (select_loc_h l) e.eqs2

(** val add_equations : reg list -> mreg list -> eqs -> eqs option **)

let rec add_equations rl ml e =
  match rl with
  | Nil ->
    (match ml with
     | Nil -> Some e
     | Cons (m0, l) -> None)
  | Cons (r1, rl0) ->
    (match ml with
     | Nil -> None
     | Cons (m1, ml0) ->
       add_equations rl0 ml0
         (add_equation { ekind = Full; ereg = r1; eloc = (R m1) } e))

(** val add_equations_args :
    reg list -> typ list -> loc list -> eqs -> eqs option **)

let rec add_equations_args rl tyl ll e =
  match rl with
  | Nil ->
    (match tyl with
     | Nil ->
       (match ll with
        | Nil -> Some e
        | Cons (l, l0) -> None)
     | Cons (t1, l) -> None)
  | Cons (r1, rl0) ->
    (match tyl with
     | Nil -> None
     | Cons (t1, tyl0) ->
       (match t1 with
        | Tlong ->
          (match ll with
           | Nil -> None
           | Cons (l1, l) ->
             (match l with
              | Nil -> None
              | Cons (l2, ll0) ->
                add_equations_args rl0 tyl0 ll0
                  (add_equation { ekind = Low; ereg = r1; eloc = l2 }
                    (add_equation { ekind = High; ereg = r1; eloc = l1 } e))))
        | Tany32 -> None
        | Tany64 -> None
        | _ ->
          (match ll with
           | Nil -> None
           | Cons (l1, ll0) ->
             add_equations_args rl0 tyl0 ll0
               (add_equation { ekind = Full; ereg = r1; eloc = l1 } e))))

(** val add_equations_res :
    reg -> typ option -> loc list -> eqs -> eqs option **)

let add_equations_res r oty ll e =
  match oty with
  | Some t1 ->
    (match t1 with
     | Tlong ->
       (match ll with
        | Nil -> None
        | Cons (l1, l) ->
          (match l with
           | Nil -> None
           | Cons (l2, l0) ->
             (match l0 with
              | Nil ->
                Some
                  (add_equation { ekind = Low; ereg = r; eloc = l2 }
                    (add_equation { ekind = High; ereg = r; eloc = l1 } e))
              | Cons (l3, l4) -> None)))
     | _ ->
       (match ll with
        | Nil -> None
        | Cons (l1, l) ->
          (match l with
           | Nil ->
             Some (add_equation { ekind = Full; ereg = r; eloc = l1 } e)
           | Cons (l0, l2) -> None)))
  | None ->
    (match ll with
     | Nil -> None
     | Cons (l1, l) ->
       (match l with
        | Nil -> Some (add_equation { ekind = Full; ereg = r; eloc = l1 } e)
        | Cons (l0, l2) -> None))

(** val remove_equations_res :
    reg -> typ option -> loc list -> eqs -> eqs option **)

let remove_equations_res r oty ll e =
  match oty with
  | Some t1 ->
    (match t1 with
     | Tlong ->
       (match ll with
        | Nil -> None
        | Cons (l1, l) ->
          (match l with
           | Nil -> None
           | Cons (l2, l0) ->
             (match l0 with
              | Nil ->
                (match Loc.diff_dec l2 l1 with
                 | Left ->
                   Some
                     (remove_equation { ekind = Low; ereg = r; eloc = l2 }
                       (remove_equation { ekind = High; ereg = r; eloc = l1 }
                         e))
                 | Right -> None)
              | Cons (l3, l4) -> None)))
     | _ ->
       (match ll with
        | Nil -> None
        | Cons (l1, l) ->
          (match l with
           | Nil ->
             Some (remove_equation { ekind = Full; ereg = r; eloc = l1 } e)
           | Cons (l0, l2) -> None)))
  | None ->
    (match ll with
     | Nil -> None
     | Cons (l1, l) ->
       (match l with
        | Nil ->
          Some (remove_equation { ekind = Full; ereg = r; eloc = l1 } e)
        | Cons (l0, l2) -> None))

(** val add_equation_ros :
    (reg, ident) sum -> (mreg, ident) sum -> eqs -> eqs option **)

let add_equation_ros ros ros' e =
  match ros with
  | Inl r ->
    (match ros' with
     | Inl mr ->
       Some (add_equation { ekind = Full; ereg = r; eloc = (R mr) } e)
     | Inr i -> None)
  | Inr id ->
    (match ros' with
     | Inl m0 -> None
     | Inr id' ->
       (match ident_eq id id' with
        | Left -> Some e
        | Right -> None))

(** val add_equations_builtin_arg :
    regenv -> reg builtin_arg -> loc builtin_arg -> eqs -> eqs option **)

let rec add_equations_builtin_arg env arg arg' e =
  match arg with
  | BA r ->
    (match arg' with
     | BA l -> Some (add_equation { ekind = Full; ereg = r; eloc = l } e)
     | BA_splitlong (hi, lo) ->
       (match hi with
        | BA lhi ->
          (match lo with
           | BA llo ->
             (match typ_eq (env r) Tlong with
              | Left ->
                Some
                  (add_equation { ekind = Low; ereg = r; eloc = llo }
                    (add_equation { ekind = High; ereg = r; eloc = lhi } e))
              | Right -> None)
           | _ -> None)
        | _ -> None)
     | _ -> None)
  | BA_int n0 ->
    (match arg' with
     | BA_int n' ->
       (match Int.eq_dec n0 n' with
        | Left -> Some e
        | Right -> None)
     | _ -> None)
  | BA_long n0 ->
    (match arg' with
     | BA_long n' ->
       (match Int64.eq_dec n0 n' with
        | Left -> Some e
        | Right -> None)
     | _ -> None)
  | BA_float f ->
    (match arg' with
     | BA_float f' ->
       (match Float.eq_dec f f' with
        | Left -> Some e
        | Right -> None)
     | _ -> None)
  | BA_single f ->
    (match arg' with
     | BA_single f' ->
       (match Float32.eq_dec f f' with
        | Left -> Some e
        | Right -> None)
     | _ -> None)
  | BA_loadstack (chunk, ofs) ->
    (match arg' with
     | BA_loadstack (chunk', ofs') ->
       (match chunk_eq chunk chunk' with
        | Left ->
          (match Int.eq_dec ofs ofs' with
           | Left -> Some e
           | Right -> None)
        | Right -> None)
     | _ -> None)
  | BA_addrstack ofs ->
    (match arg' with
     | BA_addrstack ofs' ->
       (match Int.eq_dec ofs ofs' with
        | Left -> Some e
        | Right -> None)
     | _ -> None)
  | BA_loadglobal (chunk, id, ofs) ->
    (match arg' with
     | BA_loadglobal (chunk', id', ofs') ->
       (match chunk_eq chunk chunk' with
        | Left ->
          (match ident_eq id id' with
           | Left ->
             (match Int.eq_dec ofs ofs' with
              | Left -> Some e
              | Right -> None)
           | Right -> None)
        | Right -> None)
     | _ -> None)
  | BA_addrglobal (id, ofs) ->
    (match arg' with
     | BA_addrglobal (id', ofs') ->
       (match ident_eq id id' with
        | Left ->
          (match Int.eq_dec ofs ofs' with
           | Left -> Some e
           | Right -> None)
        | Right -> None)
     | _ -> None)
  | BA_splitlong (hi, lo) ->
    (match arg' with
     | BA_splitlong (hi', lo') ->
       (match add_equations_builtin_arg env hi hi' e with
        | Some e1 -> add_equations_builtin_arg env lo lo' e1
        | None -> None)
     | _ -> None)

(** val add_equations_builtin_args :
    regenv -> reg builtin_arg list -> loc builtin_arg list -> eqs -> eqs
    option **)

let rec add_equations_builtin_args env args args' e =
  match args with
  | Nil ->
    (match args' with
     | Nil -> Some e
     | Cons (b, l) -> None)
  | Cons (a1, al) ->
    (match args' with
     | Nil -> None
     | Cons (a1', al') ->
       (match add_equations_builtin_arg env a1 a1' e with
        | Some e1 -> add_equations_builtin_args env al al' e1
        | None -> None))

(** val add_equations_debug_args :
    regenv -> reg builtin_arg list -> loc builtin_arg list -> eqs -> eqs
    option **)

let rec add_equations_debug_args env args args' e =
  match args with
  | Nil ->
    (match args' with
     | Nil -> Some e
     | Cons (b, l) -> None)
  | Cons (a1, al) ->
    (match args' with
     | Nil -> Some e
     | Cons (a1', al') ->
       (match add_equations_builtin_arg env a1 a1' e with
        | Some e1 -> add_equations_debug_args env al al' e1
        | None -> add_equations_debug_args env al args' e))

(** val remove_equations_builtin_res :
    regenv -> reg builtin_res -> mreg builtin_res -> eqs -> eqs option **)

let remove_equations_builtin_res env res2 res' e =
  match res2 with
  | BR r ->
    (match res' with
     | BR r' ->
       Some (remove_equation { ekind = Full; ereg = r; eloc = (R r') } e)
     | BR_none -> None
     | BR_splitlong (hi, lo) ->
       (match hi with
        | BR rhi ->
          (match lo with
           | BR rlo ->
             (match typ_eq (env r) Tlong with
              | Left ->
                (match mreg_eq rhi rlo with
                 | Left -> None
                 | Right ->
                   Some
                     (remove_equation { ekind = Low; ereg = r; eloc = (R
                       rlo) }
                       (remove_equation { ekind = High; ereg = r; eloc = (R
                         rhi) } e)))
              | Right -> None)
           | _ -> None)
        | _ -> None))
  | BR_none ->
    (match res' with
     | BR_none -> Some e
     | _ -> None)
  | BR_splitlong (hi, lo) -> None

(** val can_undef : mreg list -> eqs -> bool **)

let rec can_undef ml e =
  match ml with
  | Nil -> True
  | Cons (m1, ml0) ->
    (match loc_unconstrained (R m1) e with
     | True -> can_undef ml0 e
     | False -> False)

(** val can_undef_except : loc -> mreg list -> eqs -> bool **)

let rec can_undef_except l ml e =
  match ml with
  | Nil -> True
  | Cons (m1, ml0) ->
    (match match proj_sumbool (Loc.eq l (R m1)) with
           | True -> True
           | False -> loc_unconstrained (R m1) e with
     | True -> can_undef_except l ml0 e
     | False -> False)

(** val no_caller_saves : eqs -> bool **)

let no_caller_saves e =
  EqSet.for_all (fun eq0 ->
    match eq0.eloc with
    | R r ->
      (match proj_sumbool (zle Z0 (index_int_callee_save r)) with
       | True -> True
       | False -> proj_sumbool (zle Z0 (index_float_callee_save r)))
    | S0 (sl, pos, ty) ->
      (match sl with
       | Outgoing -> False
       | _ -> True)) e.eqs1

(** val compat_left : reg -> loc -> eqs -> bool **)

let compat_left r l e =
  EqSet.for_all_between (fun q ->
    match q.ekind with
    | Full -> proj_sumbool (Loc.eq l q.eloc)
    | _ -> False) (select_reg_l r) (select_reg_h r) e.eqs1

(** val compat_left2 : reg -> loc -> loc -> eqs -> bool **)

let compat_left2 r l1 l2 e =
  EqSet.for_all_between (fun q ->
    match q.ekind with
    | Full -> False
    | Low -> proj_sumbool (Loc.eq l2 q.eloc)
    | High -> proj_sumbool (Loc.eq l1 q.eloc)) (select_reg_l r)
    (select_reg_h r) e.eqs1

(** val ros_compatible_tailcall : (mreg, ident) sum -> bool **)

let ros_compatible_tailcall = function
| Inl r -> proj_sumbool (in_dec mreg_eq r destroyed_at_call)
| Inr id -> True

(** val destroyed_by_move : loc -> loc -> mreg list **)

let destroyed_by_move src dst =
  match src with
  | R r ->
    (match dst with
     | R r0 -> destroyed_by_op Omove
     | S0 (sl, ofs, ty) -> destroyed_by_setstack ty)
  | S0 (sl, ofs, ty) -> destroyed_by_getstack sl

(** val well_typed_move : regenv -> loc -> eqs -> bool **)

let well_typed_move env dst e =
  match dst with
  | R r -> True
  | S0 (sl, ofs, ty) -> loc_type_compat env dst e

(** val track_moves : regenv -> moves -> eqs -> eqs option **)

let rec track_moves env mv e =
  match mv with
  | Nil -> Some e
  | Cons (p, mv0) ->
    let Pair (src, dst) = p in
    (match track_moves env mv0 e with
     | Some e1 ->
       (match can_undef_except dst (destroyed_by_move src dst) e1 with
        | True ->
          (match well_typed_move env dst e1 with
           | True -> subst_loc dst src e1
           | False -> None)
        | False -> None)
     | None -> None)

(** val transfer_use_def :
    reg list -> reg -> mreg list -> mreg -> mreg list -> eqs -> eqs option **)

let transfer_use_def args res2 args' res' undefs e =
  let e1 = remove_equation { ekind = Full; ereg = res2; eloc = (R res') } e
  in
  (match reg_loc_unconstrained res2 (R res') e1 with
   | True ->
     (match can_undef undefs e1 with
      | True -> add_equations args args' e1
      | False -> None)
   | False -> None)

(** val kind_first_word : equation_kind **)

let kind_first_word =
  match big_endian with
  | True -> High
  | False -> Low

(** val kind_second_word : equation_kind **)

let kind_second_word =
  match big_endian with
  | True -> Low
  | False -> High

(** val transfer_aux :
    function4 -> regenv -> block_shape -> eqs -> eqs option **)

let transfer_aux f env shape e =
  match shape with
  | BSnop (mv, s) -> track_moves env mv e
  | BSmove (src, dst, mv, s) -> track_moves env mv (subst_reg dst src e)
  | BSmakelong (src1, src2, dst, mv, s) ->
    let e1 = subst_reg_kind dst High src1 Full e in
    let e2 = subst_reg_kind dst Low src2 Full e1 in
    (match reg_unconstrained dst e2 with
     | True -> track_moves env mv e2
     | False -> None)
  | BSlowlong (src, dst, mv, s) ->
    let e1 = subst_reg_kind dst Full src Low e in
    (match reg_unconstrained dst e1 with
     | True -> track_moves env mv e1
     | False -> None)
  | BShighlong (src, dst, mv, s) ->
    let e1 = subst_reg_kind dst Full src High e in
    (match reg_unconstrained dst e1 with
     | True -> track_moves env mv e1
     | False -> None)
  | BSop (op, args, res2, mv1, args', res', mv2, s) ->
    (match track_moves env mv2 e with
     | Some e1 ->
       (match transfer_use_def args res2 args' res' (destroyed_by_op op) e1 with
        | Some e2 -> track_moves env mv1 e2
        | None -> None)
     | None -> None)
  | BSopdead (op, args, res2, mv, s) ->
    (match reg_unconstrained res2 e with
     | True -> track_moves env mv e
     | False -> None)
  | BSload (chunk, addr, args, dst, mv1, args', dst', mv2, s) ->
    (match track_moves env mv2 e with
     | Some e1 ->
       (match transfer_use_def args dst args' dst'
                (destroyed_by_load chunk addr) e1 with
        | Some e2 -> track_moves env mv1 e2
        | None -> None)
     | None -> None)
  | BSloaddead (chunk, addr, args, dst, mv, s) ->
    (match reg_unconstrained dst e with
     | True -> track_moves env mv e
     | False -> None)
  | BSload2 (addr, addr', args, dst, mv1, args1', dst1', mv2, args2', dst2',
             mv3, s) ->
    (match track_moves env mv3 e with
     | Some e1 ->
       let e2 =
         remove_equation { ekind = kind_second_word; ereg = dst; eloc = (R
           dst2') } e1
       in
       (match loc_unconstrained (R dst2') e2 with
        | True ->
          (match can_undef (destroyed_by_load Mint32 addr') e2 with
           | True ->
             (match add_equations args args2' e2 with
              | Some e3 ->
                (match track_moves env mv2 e3 with
                 | Some e4 ->
                   let e5 =
                     remove_equation { ekind = kind_first_word; ereg = dst;
                       eloc = (R dst1') } e4
                   in
                   (match loc_unconstrained (R dst1') e5 with
                    | True ->
                      (match can_undef (destroyed_by_load Mint32 addr) e5 with
                       | True ->
                         (match reg_unconstrained dst e5 with
                          | True ->
                            (match add_equations args args1' e5 with
                             | Some e6 -> track_moves env mv1 e6
                             | None -> None)
                          | False -> None)
                       | False -> None)
                    | False -> None)
                 | None -> None)
              | None -> None)
           | False -> None)
        | False -> None)
     | None -> None)
  | BSload2_1 (addr, args, dst, mv1, args', dst', mv2, s) ->
    (match track_moves env mv2 e with
     | Some e1 ->
       let e2 =
         remove_equation { ekind = kind_first_word; ereg = dst; eloc = (R
           dst') } e1
       in
       (match reg_loc_unconstrained dst (R dst') e2 with
        | True ->
          (match can_undef (destroyed_by_load Mint32 addr) e2 with
           | True ->
             (match add_equations args args' e2 with
              | Some e3 -> track_moves env mv1 e3
              | None -> None)
           | False -> None)
        | False -> None)
     | None -> None)
  | BSload2_2 (addr, addr', args, dst, mv1, args', dst', mv2, s) ->
    (match track_moves env mv2 e with
     | Some e1 ->
       let e2 =
         remove_equation { ekind = kind_second_word; ereg = dst; eloc = (R
           dst') } e1
       in
       (match reg_loc_unconstrained dst (R dst') e2 with
        | True ->
          (match can_undef (destroyed_by_load Mint32 addr') e2 with
           | True ->
             (match add_equations args args' e2 with
              | Some e3 -> track_moves env mv1 e3
              | None -> None)
           | False -> None)
        | False -> None)
     | None -> None)
  | BSstore (chunk, addr, args, src, mv, args', src', s) ->
    (match can_undef (destroyed_by_store chunk addr) e with
     | True ->
       (match add_equations (Cons (src, args)) (Cons (src', args')) e with
        | Some e1 -> track_moves env mv e1
        | None -> None)
     | False -> None)
  | BSstore2 (addr, addr', args, src, mv1, args1', src1', mv2, args2', src2',
              s) ->
    (match can_undef (destroyed_by_store Mint32 addr') e with
     | True ->
       (match add_equations args args2'
                (add_equation { ekind = kind_second_word; ereg = src; eloc =
                  (R src2') } e) with
        | Some e1 ->
          (match track_moves env mv2 e1 with
           | Some e2 ->
             (match can_undef (destroyed_by_store Mint32 addr) e2 with
              | True ->
                (match add_equations args args1'
                         (add_equation { ekind = kind_first_word; ereg = src;
                           eloc = (R src1') } e2) with
                 | Some e3 -> track_moves env mv1 e3
                 | None -> None)
              | False -> None)
           | None -> None)
        | None -> None)
     | False -> None)
  | BScall (sg, ros, args, res2, mv1, ros', mv2, s) ->
    let args' = loc_arguments sg in
    let res' = map (fun x -> R x) (loc_result sg) in
    (match track_moves env mv2 e with
     | Some e1 ->
       (match remove_equations_res res2 sg.sig_res res' e1 with
        | Some e2 ->
          (match forallb (fun l -> reg_loc_unconstrained res2 l e2) res' with
           | True ->
             (match no_caller_saves e2 with
              | True ->
                (match add_equation_ros ros ros' e2 with
                 | Some e3 ->
                   (match add_equations_args args sg.sig_args args' e3 with
                    | Some e4 -> track_moves env mv1 e4
                    | None -> None)
                 | None -> None)
              | False -> None)
           | False -> None)
        | None -> None)
     | None -> None)
  | BStailcall (sg, ros, args, mv1, ros') ->
    let args' = loc_arguments sg in
    (match tailcall_is_possible sg with
     | True ->
       (match opt_typ_eq sg.sig_res f.fn_sig2.sig_res with
        | Left ->
          (match ros_compatible_tailcall ros' with
           | True ->
             (match add_equation_ros ros ros' empty_eqs with
              | Some e1 ->
                (match add_equations_args args sg.sig_args args' e1 with
                 | Some e2 -> track_moves env mv1 e2
                 | None -> None)
              | None -> None)
           | False -> None)
        | Right -> None)
     | False -> None)
  | BSbuiltin (ef, args, res2, mv1, args', res', mv2, s) ->
    (match track_moves env mv2 e with
     | Some e1 ->
       (match remove_equations_builtin_res env res2 res' e1 with
        | Some e2 ->
          (match forallb (fun r -> reg_unconstrained r e2)
                   (params_of_builtin_res res2) with
           | True ->
             (match forallb (fun mr -> loc_unconstrained (R mr) e2)
                      (params_of_builtin_res res') with
              | True ->
                (match can_undef (destroyed_by_builtin ef) e2 with
                 | True ->
                   (match match ef with
                          | EF_debug (kind, text, targs) ->
                            add_equations_debug_args env args args' e2
                          | _ -> add_equations_builtin_args env args args' e2 with
                    | Some e3 -> track_moves env mv1 e3
                    | None -> None)
                 | False -> None)
              | False -> None)
           | False -> None)
        | None -> None)
     | None -> None)
  | BScond (cond, args, mv, args', s1, s2) ->
    (match can_undef (destroyed_by_cond cond) e with
     | True ->
       (match add_equations args args' e with
        | Some e1 -> track_moves env mv e1
        | None -> None)
     | False -> None)
  | BSjumptable (arg, mv, arg', tbl) ->
    (match can_undef destroyed_by_jumptable e with
     | True ->
       track_moves env mv
         (add_equation { ekind = Full; ereg = arg; eloc = (R arg') } e)
     | False -> None)
  | BSreturn (arg0, mv) ->
    (match arg0 with
     | Some arg ->
       let arg' = map (fun x -> R x) (loc_result f.fn_sig2) in
       (match add_equations_res arg f.fn_sig2.sig_res arg' empty_eqs with
        | Some e1 -> track_moves env mv e1
        | None -> None)
     | None -> track_moves env mv empty_eqs)

(** val transfer3 :
    function4 -> regenv -> block_shape PTree.t -> node0 -> eqs res -> eqs res **)

let transfer3 f env shapes pc after = match after with
| OK e ->
  (match PTree.get pc shapes with
   | Some shape ->
     (match transfer_aux f env shape e with
      | Some e' -> OK e'
      | None ->
        Error (Cons ((MSG (String ((Ascii (True, False, False, False, False,
          False, True, False)), (String ((Ascii (False, False, True, False,
          True, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)), (String ((Ascii (False, False,
          False, False, True, False, True, False)), (String ((Ascii (True,
          True, False, False, False, False, True, False)), (String ((Ascii
          (False, False, False, False, False, True, False, False)),
          EmptyString))))))))))))), (Cons ((POS pc), (Cons ((MSG (String
          ((Ascii (False, True, False, True, True, True, False, False)),
          (String ((Ascii (False, False, False, False, False, True, False,
          False)), (String ((Ascii (True, False, False, True, False, True,
          True, False)), (String ((Ascii (False, True, True, True, False,
          True, True, False)), (String ((Ascii (False, True, True, False,
          True, True, True, False)), (String ((Ascii (True, False, False,
          False, False, True, True, False)), (String ((Ascii (False, False,
          True, True, False, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (False, False, True, False, False, True, True, False)), (String
          ((Ascii (False, False, False, False, False, True, False, False)),
          (String ((Ascii (False, True, False, False, True, True, True,
          False)), (String ((Ascii (True, False, True, False, False, True,
          True, False)), (String ((Ascii (True, True, True, False, False,
          True, True, False)), (String ((Ascii (True, False, False, True,
          False, True, True, False)), (String ((Ascii (True, True, False,
          False, True, True, True, False)), (String ((Ascii (False, False,
          True, False, True, True, True, False)), (String ((Ascii (True,
          False, True, False, False, True, True, False)), (String ((Ascii
          (False, True, False, False, True, True, True, False)), (String
          ((Ascii (False, False, False, False, False, True, False, False)),
          (String ((Ascii (True, False, False, False, False, True, True,
          False)), (String ((Ascii (False, False, True, True, False, True,
          True, False)), (String ((Ascii (False, False, True, True, False,
          True, True, False)), (String ((Ascii (True, True, True, True,
          False, True, True, False)), (String ((Ascii (True, True, False,
          False, False, True, True, False)), (String ((Ascii (True, False,
          False, False, False, True, True, False)), (String ((Ascii (False,
          False, True, False, True, True, True, False)), (String ((Ascii
          (True, False, False, True, False, True, True, False)), (String
          ((Ascii (True, True, True, True, False, True, True, False)),
          (String ((Ascii (False, True, True, True, False, True, True,
          False)),
          EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))),
          Nil)))))))
   | None ->
     Error (Cons ((MSG (String ((Ascii (True, False, False, False, False,
       False, True, False)), (String ((Ascii (False, False, True, False,
       True, True, True, False)), (String ((Ascii (False, False, False,
       False, False, True, False, False)), (String ((Ascii (False, False,
       False, False, True, False, True, False)), (String ((Ascii (True, True,
       False, False, False, False, True, False)), (String ((Ascii (False,
       False, False, False, False, True, False, False)),
       EmptyString))))))))))))), (Cons ((POS pc), (Cons ((MSG (String ((Ascii
       (False, True, False, True, True, True, False, False)), (String ((Ascii
       (False, False, False, False, False, True, False, False)), (String
       ((Ascii (True, False, True, False, True, True, True, False)), (String
       ((Ascii (False, True, True, True, False, True, True, False)), (String
       ((Ascii (True, False, True, True, False, True, True, False)), (String
       ((Ascii (True, False, False, False, False, True, True, False)),
       (String ((Ascii (False, False, True, False, True, True, True, False)),
       (String ((Ascii (True, True, False, False, False, True, True, False)),
       (String ((Ascii (False, False, False, True, False, True, True,
       False)), (String ((Ascii (True, False, True, False, False, True, True,
       False)), (String ((Ascii (False, False, True, False, False, True,
       True, False)), (String ((Ascii (False, False, False, False, False,
       True, False, False)), (String ((Ascii (False, True, False, False,
       False, True, True, False)), (String ((Ascii (False, False, True, True,
       False, True, True, False)), (String ((Ascii (True, True, True, True,
       False, True, True, False)), (String ((Ascii (True, True, False, False,
       False, True, True, False)), (String ((Ascii (True, True, False, True,
       False, True, True, False)),
       EmptyString))))))))))))))))))))))))))))))))))), Nil)))))))
| Error e -> after

module LEq = 
 struct 
  type t = eqs res
  
  (** val beq : t -> t -> bool **)
  
  let beq x y =
    match x with
    | OK a ->
      (match y with
       | OK b -> EqSet.equal a.eqs1 b.eqs1
       | Error e -> False)
    | Error e ->
      (match y with
       | OK e0 -> False
       | Error e0 -> True)
  
  (** val bot : t **)
  
  let bot =
    OK empty_eqs
  
  (** val lub : t -> t -> t **)
  
  let lub x y =
    match x with
    | OK a ->
      (match y with
       | OK b ->
         OK { eqs1 = (EqSet.union a.eqs1 b.eqs1); eqs2 =
           (EqSet2.union a.eqs2 b.eqs2) }
       | Error e -> y)
    | Error e -> x
 end

module Coq1_DS = Backward_Dataflow_Solver(LEq)(NodeSetBackward)

(** val successors_block_shape : block_shape -> node0 list **)

let successors_block_shape = function
| BSnop (mv, s) -> Cons (s, Nil)
| BSmove (src, dst, mv, s) -> Cons (s, Nil)
| BSmakelong (src1, src2, dst, mv, s) -> Cons (s, Nil)
| BSlowlong (src, dst, mv, s) -> Cons (s, Nil)
| BShighlong (src, dst, mv, s) -> Cons (s, Nil)
| BSop (op, args, res2, mv1, args', res', mv2, s) -> Cons (s, Nil)
| BSopdead (op, args, res2, mv, s) -> Cons (s, Nil)
| BSload (chunk, addr, args, dst, mv1, args', dst', mv2, s) -> Cons (s, Nil)
| BSloaddead (chunk, addr, args, dst, mv, s) -> Cons (s, Nil)
| BSload2 (addr, addr', args, dst, mv1, args1', dst1', mv2, args2', dst2',
           mv3, s) ->
  Cons (s, Nil)
| BSload2_1 (addr, args, dst, mv1, args', dst', mv2, s) -> Cons (s, Nil)
| BSload2_2 (addr, addr', args, dst, mv1, args', dst', mv2, s) ->
  Cons (s, Nil)
| BSstore (chunk, addr, args, src, mv1, args', src', s) -> Cons (s, Nil)
| BSstore2 (addr, addr', args, src, mv1, args1', src1', mv2, args2', src2', s) ->
  Cons (s, Nil)
| BScall (sg, ros, args, res2, mv1, ros', mv2, s) -> Cons (s, Nil)
| BSbuiltin (ef, args, res2, mv1, args', res', mv2, s) -> Cons (s, Nil)
| BScond (cond, args, mv, args', s1, s2) -> Cons (s1, (Cons (s2, Nil)))
| BSjumptable (arg, mv, arg', tbl) -> tbl
| _ -> Nil

(** val analyze3 :
    function4 -> regenv -> block_shape PTree.t -> Coq1_DS.L.t PMap.t option **)

let analyze3 f env bsh =
  Coq1_DS.fixpoint_allnodes bsh successors_block_shape (transfer3 f env bsh)

(** val compat_entry : reg list -> typ list -> loc list -> eqs -> bool **)

let rec compat_entry rparams tys lparams e =
  match rparams with
  | Nil ->
    (match tys with
     | Nil ->
       (match lparams with
        | Nil -> True
        | Cons (l, l0) -> False)
     | Cons (t1, l) -> False)
  | Cons (r1, rl) ->
    (match tys with
     | Nil -> False
     | Cons (t1, tyl) ->
       (match t1 with
        | Tlong ->
          (match lparams with
           | Nil -> False
           | Cons (l1, l) ->
             (match l with
              | Nil -> False
              | Cons (l2, ll) ->
                (match compat_left2 r1 l1 l2 e with
                 | True -> compat_entry rl tyl ll e
                 | False -> False)))
        | Tany32 -> False
        | Tany64 -> False
        | _ ->
          (match lparams with
           | Nil -> False
           | Cons (l1, ll) ->
             (match compat_left r1 l1 e with
              | True -> compat_entry rl tyl ll e
              | False -> False))))

(** val check_entrypoints_aux :
    function4 -> function5 -> regenv -> eqs -> unit0 option **)

let check_entrypoints_aux rtl ltl env e1 =
  match pair_entrypoints rtl ltl with
  | Some mv ->
    (match track_moves env mv e1 with
     | Some e2 ->
       (match compat_entry rtl.fn_params3 rtl.fn_sig2.sig_args
                (loc_parameters rtl.fn_sig2) e2 with
        | True ->
          (match can_undef destroyed_at_function_entry e2 with
           | True ->
             (match zeq rtl.fn_stacksize ltl.fn_stacksize0 with
              | Left ->
                (match signature_eq rtl.fn_sig2 ltl.fn_sig3 with
                 | Left -> Some Tt
                 | Right -> None)
              | Right -> None)
           | False -> None)
        | False -> None)
     | None -> None)
  | None -> None

(** val check_entrypoints :
    function4 -> function5 -> regenv -> block_shape PTree.t -> LEq.t PMap.t
    -> unit0 res **)

let check_entrypoints rtl ltl env bsh a =
  bind
    (transfer3 rtl env bsh rtl.fn_entrypoint (PMap.get rtl.fn_entrypoint a))
    (fun e1 ->
    match check_entrypoints_aux rtl ltl env e1 with
    | Some u -> OK Tt
    | None ->
      Error
        (msg (String ((Ascii (True, False, False, True, False, True, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (False, True, True, False, True,
          True, True, False)), (String ((Ascii (True, False, False, False,
          False, True, True, False)), (String ((Ascii (False, False, True,
          True, False, True, True, False)), (String ((Ascii (True, False,
          False, True, False, True, True, False)), (String ((Ascii (False,
          False, True, False, False, True, True, False)), (String ((Ascii
          (False, False, False, False, False, True, False, False)), (String
          ((Ascii (False, True, False, False, True, True, True, False)),
          (String ((Ascii (True, False, True, False, False, True, True,
          False)), (String ((Ascii (True, True, True, False, False, True,
          True, False)), (String ((Ascii (True, False, False, True, False,
          True, True, False)), (String ((Ascii (True, True, False, False,
          True, True, True, False)), (String ((Ascii (False, False, True,
          False, True, True, True, False)), (String ((Ascii (True, False,
          True, False, False, True, True, False)), (String ((Ascii (False,
          True, False, False, True, True, True, False)), (String ((Ascii
          (False, False, False, False, False, True, False, False)), (String
          ((Ascii (True, False, False, False, False, True, True, False)),
          (String ((Ascii (False, False, True, True, False, True, True,
          False)), (String ((Ascii (False, False, True, True, False, True,
          True, False)), (String ((Ascii (True, True, True, True, False,
          True, True, False)), (String ((Ascii (True, True, False, False,
          False, True, True, False)), (String ((Ascii (True, False, False,
          False, False, True, True, False)), (String ((Ascii (False, False,
          True, False, True, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (True, True, True, True, False, True, True, False)), (String
          ((Ascii (False, True, True, True, False, True, True, False)),
          (String ((Ascii (False, False, False, False, False, True, False,
          False)), (String ((Ascii (True, False, False, False, False, True,
          True, False)), (String ((Ascii (False, False, True, False, True,
          True, True, False)), (String ((Ascii (False, False, False, False,
          False, True, False, False)), (String ((Ascii (True, False, True,
          False, False, True, True, False)), (String ((Ascii (False, True,
          True, True, False, True, True, False)), (String ((Ascii (False,
          False, True, False, True, True, True, False)), (String ((Ascii
          (False, True, False, False, True, True, True, False)), (String
          ((Ascii (True, False, False, True, True, True, True, False)),
          (String ((Ascii (False, False, False, False, False, True, False,
          False)), (String ((Ascii (False, False, False, False, True, True,
          True, False)), (String ((Ascii (True, True, True, True, False,
          True, True, False)), (String ((Ascii (True, False, False, True,
          False, True, True, False)), (String ((Ascii (False, True, True,
          True, False, True, True, False)), (String ((Ascii (False, False,
          True, False, True, True, True, False)),
          EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val check_function : function4 -> function5 -> regenv -> unit0 res **)

let check_function rtl ltl env =
  let bsh = pair_codes rtl ltl in
  (match analyze3 rtl env bsh with
   | Some a -> check_entrypoints rtl ltl env bsh a
   | None ->
     Error
       (msg (String ((Ascii (True, False, False, False, False, True, True,
         False)), (String ((Ascii (False, False, True, True, False, True,
         True, False)), (String ((Ascii (False, False, True, True, False,
         True, True, False)), (String ((Ascii (True, True, True, True, False,
         True, True, False)), (String ((Ascii (True, True, False, False,
         False, True, True, False)), (String ((Ascii (True, False, False,
         False, False, True, True, False)), (String ((Ascii (False, False,
         True, False, True, True, True, False)), (String ((Ascii (True,
         False, False, True, False, True, True, False)), (String ((Ascii
         (True, True, True, True, False, True, True, False)), (String ((Ascii
         (False, True, True, True, False, True, True, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (True, False, False, False, False, True, True,
         False)), (String ((Ascii (False, True, True, True, False, True,
         True, False)), (String ((Ascii (True, False, False, False, False,
         True, True, False)), (String ((Ascii (False, False, True, True,
         False, True, True, False)), (String ((Ascii (True, False, False,
         True, True, True, True, False)), (String ((Ascii (True, True, False,
         False, True, True, True, False)), (String ((Ascii (True, False,
         False, True, False, True, True, False)), (String ((Ascii (True,
         True, False, False, True, True, True, False)), (String ((Ascii
         (False, False, False, False, False, True, False, False)), (String
         ((Ascii (False, False, True, False, False, True, True, False)),
         (String ((Ascii (True, False, False, True, False, True, True,
         False)), (String ((Ascii (False, True, True, False, True, True,
         True, False)), (String ((Ascii (True, False, True, False, False,
         True, True, False)), (String ((Ascii (False, True, False, False,
         True, True, True, False)), (String ((Ascii (True, True, True, False,
         False, True, True, False)), (String ((Ascii (True, False, True,
         False, False, True, True, False)), (String ((Ascii (True, True,
         False, False, True, True, True, False)),
         EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val regalloc : function4 -> function5 res **)

let regalloc =
  failwith "AXIOM TO BE REALIZED"

(** val transf_function7 : function4 -> function5 res **)

let transf_function7 f =
  match type_function f with
  | OK env ->
    (match regalloc f with
     | OK tf -> bind (check_function f tf env) (fun x -> OK tf)
     | Error m0 -> Error m0)
  | Error m0 -> Error m0

(** val transf_fundef7 : fundef4 -> fundef5 res **)

let transf_fundef7 fd =
  transf_partial_fundef transf_function7 fd

(** val transf_program6 : program4 -> program5 res **)

let transf_program6 p =
  transform_partial_program transf_fundef7 p

module type MAP = 
 sig 
  type elt 
  
  val elt_eq : elt -> elt -> sumbool
  
  type 'x t 
  
  val empty : 'a1 t
  
  val get : elt -> 'a1 t -> 'a1 option
  
  val set : elt -> 'a1 -> 'a1 t -> 'a1 t
 end

module type UNIONFIND = 
 sig 
  type elt 
  
  val elt_eq : elt -> elt -> sumbool
  
  type t 
  
  val repr : t -> elt -> elt
  
  val empty : t
  
  val find : t -> elt -> (elt, t) prod
  
  val union : t -> elt -> elt -> t
  
  val merge : t -> elt -> elt -> t
  
  val pathlen : t -> elt -> nat
 end

module UF = 
 functor (M:MAP) ->
 struct 
  type elt = M.elt
  
  (** val elt_eq : M.elt -> M.elt -> sumbool **)
  
  let elt_eq =
    M.elt_eq
  
  type unionfind =
    elt M.t
    (* singleton inductive, whose constructor was mk *)
  
  (** val m : unionfind -> elt M.t **)
  
  let m u =
    u
  
  type t = unionfind
  
  (** val getlink : elt M.t -> elt -> elt sumor **)
  
  let getlink m0 a =
    let o = M.get a m0 in
    (match o with
     | Some e -> Inleft e
     | None -> Inright)
  
  (** val coq_F_repr : t -> elt -> (elt -> __ -> elt) -> elt **)
  
  let coq_F_repr uf a rec0 =
    match getlink (m uf) a with
    | Inleft s -> rec0 s __
    | Inright -> a
  
  (** val repr : t -> elt -> elt **)
  
  let rec repr uf a =
    coq_F_repr uf a (fun y _ -> repr uf y)
  
  (** val empty : t **)
  
  let empty =
    M.empty
  
  (** val identify : t -> elt -> elt -> unionfind **)
  
  let identify uf a b =
    M.set a b (m uf)
  
  (** val union : t -> elt -> elt -> t **)
  
  let union uf a b =
    let a' = repr uf a in
    let b' = repr uf b in
    (match M.elt_eq a' b' with
     | Left -> uf
     | Right -> identify uf a' b')
  
  (** val merge : t -> elt -> elt -> t **)
  
  let merge uf a b =
    let a' = repr uf a in
    let b' = repr uf b in
    (match M.elt_eq a' b' with
     | Left -> uf
     | Right -> identify uf a' b)
  
  (** val coq_F_pathlen : t -> elt -> (elt -> __ -> nat) -> nat **)
  
  let coq_F_pathlen uf a rec0 =
    match getlink (m uf) a with
    | Inleft s -> S (rec0 s __)
    | Inright -> O
  
  (** val pathlen : t -> elt -> nat **)
  
  let rec pathlen uf a =
    coq_F_pathlen uf a (fun y _ -> pathlen uf y)
  
  (** val compress : t -> elt -> elt -> unionfind **)
  
  let compress uf a b =
    M.set a b (m uf)
  
  (** val find_x : t -> elt -> (elt, t) prod **)
  
  let rec find_x uf x =
    let find_x0 = fun a -> find_x uf a in
    let filtered_var = M.get x (m uf) in
    (match filtered_var with
     | Some a' ->
       let filtered_var0 = find_x0 a' in
       let Pair (b, uf') = filtered_var0 in Pair (b, (compress uf' x b))
     | None -> Pair (x, uf))
  
  (** val find : t -> elt -> (elt, t) prod **)
  
  let find uf a =
    find_x uf a
 end

module U = UF(PTree)

(** val record_goto : U.t -> node0 -> bblock -> U.t **)

let record_goto uf pc = function
| Nil -> uf
| Cons (i, l) ->
  (match i with
   | Lbranch s -> U.union uf pc s
   | _ -> uf)

(** val record_gotos : function5 -> U.t **)

let record_gotos f =
  PTree.fold record_goto f.fn_code0 U.empty

(** val tunnel_instr : U.t -> instruction0 -> instruction0 **)

let tunnel_instr uf i = match i with
| Lbranch s -> Lbranch (U.repr uf s)
| Lcond (cond, args, s1, s2) ->
  Lcond (cond, args, (U.repr uf s1), (U.repr uf s2))
| Ljumptable (arg, tbl) -> Ljumptable (arg, (map (U.repr uf) tbl))
| _ -> i

(** val tunnel_block : U.t -> bblock -> bblock **)

let tunnel_block uf b =
  map (tunnel_instr uf) b

(** val tunnel_function : function5 -> function5 **)

let tunnel_function f =
  let uf = record_gotos f in
  { fn_sig3 = f.fn_sig3; fn_stacksize0 = f.fn_stacksize0; fn_code0 =
  (PTree.map1 (tunnel_block uf) f.fn_code0); fn_entrypoint0 =
  (U.repr uf f.fn_entrypoint0) }

(** val tunnel_fundef : fundef5 -> fundef5 **)

let tunnel_fundef f =
  transf_fundef tunnel_function f

(** val tunnel_program : program5 -> program5 **)

let tunnel_program p =
  transform_program tunnel_fundef p

module Coq2_DS = Dataflow_Solver(LBoolean)(NodeSetForward)

(** val reachable_aux : function5 -> bool PMap.t option **)

let reachable_aux f =
  Coq2_DS.fixpoint f.fn_code0 successors_block (fun pc r -> r)
    f.fn_entrypoint0 True

(** val reachable : function5 -> bool PMap.t **)

let reachable f =
  match reachable_aux f with
  | Some rs -> rs
  | None -> PMap.init True

(** val enumerate_aux : function5 -> bool PMap.t -> node0 list **)

let enumerate_aux =
  failwith "AXIOM TO BE REALIZED"

module Nodeset = Coq_Make(OrderedPositive)

(** val nodeset_of_list : node0 list -> Nodeset.t -> Nodeset.t res **)

let rec nodeset_of_list l s =
  match l with
  | Nil -> OK s
  | Cons (hd0, tl0) ->
    (match Nodeset.mem hd0 s with
     | True ->
       Error
         (msg (String ((Ascii (False, False, True, True, False, False, True,
           False)), (String ((Ascii (True, False, False, True, False, True,
           True, False)), (String ((Ascii (False, True, True, True, False,
           True, True, False)), (String ((Ascii (True, False, True, False,
           False, True, True, False)), (String ((Ascii (True, False, False,
           False, False, True, True, False)), (String ((Ascii (False, True,
           False, False, True, True, True, False)), (String ((Ascii (True,
           False, False, True, False, True, True, False)), (String ((Ascii
           (False, True, False, True, True, True, True, False)), (String
           ((Ascii (True, False, True, False, False, True, True, False)),
           (String ((Ascii (False, True, False, True, True, True, False,
           False)), (String ((Ascii (False, False, False, False, False, True,
           False, False)), (String ((Ascii (False, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, True, False,
           True, True, True, False)), (String ((Ascii (False, False, False,
           False, True, True, True, False)), (String ((Ascii (False, False,
           True, True, False, True, True, False)), (String ((Ascii (True,
           False, False, True, False, True, True, False)), (String ((Ascii
           (True, True, False, False, False, True, True, False)), (String
           ((Ascii (True, False, False, False, False, True, True, False)),
           (String ((Ascii (False, False, True, False, True, True, True,
           False)), (String ((Ascii (True, False, True, False, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, False, False,
           False, True, False, False)), (String ((Ascii (True, False, False,
           True, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, False, True, False, False)), (String ((Ascii
           (True, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, True, False, True, True, True,
           False)), (String ((Ascii (True, False, True, True, False, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (False, True, False, False,
           True, True, True, False)), (String ((Ascii (True, False, False,
           False, False, True, True, False)), (String ((Ascii (False, False,
           True, False, True, True, True, False)), (String ((Ascii (True,
           False, False, True, False, True, True, False)), (String ((Ascii
           (True, True, True, True, False, True, True, False)), (String
           ((Ascii (False, True, True, True, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
     | False -> nodeset_of_list tl0 (Nodeset.add hd0 s))

(** val check_reachable_aux :
    bool PMap.t -> Nodeset.t -> bool -> node0 -> bblock -> bool **)

let check_reachable_aux reach s ok pc bb =
  match PMap.get pc reach with
  | True ->
    (match ok with
     | True -> Nodeset.mem pc s
     | False -> False)
  | False -> ok

(** val check_reachable : function5 -> bool PMap.t -> Nodeset.t -> bool **)

let check_reachable f reach s =
  PTree.fold (check_reachable_aux reach s) f.fn_code0 True

(** val enumerate : function5 -> node0 list res **)

let enumerate f =
  let reach = reachable f in
  let enum = enumerate_aux f reach in
  bind (nodeset_of_list enum Nodeset.empty) (fun s ->
    match check_reachable f reach s with
    | True -> OK enum
    | False ->
      Error
        (msg (String ((Ascii (False, False, True, True, False, False, True,
          False)), (String ((Ascii (True, False, False, True, False, True,
          True, False)), (String ((Ascii (False, True, True, True, False,
          True, True, False)), (String ((Ascii (True, False, True, False,
          False, True, True, False)), (String ((Ascii (True, False, False,
          False, False, True, True, False)), (String ((Ascii (False, True,
          False, False, True, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (False, True, False, True, True, True, True, False)), (String
          ((Ascii (True, False, True, False, False, True, True, False)),
          (String ((Ascii (False, True, False, True, True, True, False,
          False)), (String ((Ascii (False, False, False, False, False, True,
          False, False)), (String ((Ascii (True, True, True, False, True,
          True, True, False)), (String ((Ascii (False, True, False, False,
          True, True, True, False)), (String ((Ascii (True, True, True, True,
          False, True, True, False)), (String ((Ascii (False, True, True,
          True, False, True, True, False)), (String ((Ascii (True, True,
          True, False, False, True, True, False)), (String ((Ascii (False,
          False, False, False, False, True, False, False)), (String ((Ascii
          (True, False, True, False, False, True, True, False)), (String
          ((Ascii (False, True, True, True, False, True, True, False)),
          (String ((Ascii (True, False, True, False, True, True, True,
          False)), (String ((Ascii (True, False, True, True, False, True,
          True, False)), (String ((Ascii (True, False, True, False, False,
          True, True, False)), (String ((Ascii (False, True, False, False,
          True, True, True, False)), (String ((Ascii (True, False, False,
          False, False, True, True, False)), (String ((Ascii (False, False,
          True, False, True, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (True, True, True, True, False, True, True, False)), (String
          ((Ascii (False, True, True, True, False, True, True, False)),
          EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val starts_with : label2 -> code1 -> bool **)

let rec starts_with lbl = function
| Nil -> False
| Cons (i, k') ->
  (match i with
   | Llabel lbl' ->
     (match peq lbl lbl' with
      | Left -> True
      | Right -> starts_with lbl k')
   | _ -> False)

(** val add_branch : label2 -> code1 -> code1 **)

let add_branch s k =
  match starts_with s k with
  | True -> k
  | False -> Cons ((Lgoto s), k)

(** val linearize_block : bblock -> code1 -> code1 **)

let rec linearize_block b k =
  match b with
  | Nil -> k
  | Cons (i, b') ->
    (match i with
     | Lop (op, args, res2) ->
       Cons ((Lop0 (op, args, res2)), (linearize_block b' k))
     | Lload (chunk, addr, args, dst) ->
       Cons ((Lload0 (chunk, addr, args, dst)), (linearize_block b' k))
     | Lgetstack (sl, ofs, ty, dst) ->
       Cons ((Lgetstack0 (sl, ofs, ty, dst)), (linearize_block b' k))
     | Lsetstack (src, sl, ofs, ty) ->
       Cons ((Lsetstack0 (src, sl, ofs, ty)), (linearize_block b' k))
     | Lstore (chunk, addr, args, src) ->
       Cons ((Lstore0 (chunk, addr, args, src)), (linearize_block b' k))
     | Lcall (sig1, ros) ->
       Cons ((Lcall0 (sig1, ros)), (linearize_block b' k))
     | Ltailcall (sig1, ros) -> Cons ((Ltailcall0 (sig1, ros)), k)
     | Lbuiltin (ef, args, res2) ->
       Cons ((Lbuiltin0 (ef, args, res2)), (linearize_block b' k))
     | Lbranch s -> add_branch s k
     | Lcond (cond, args, s1, s2) ->
       (match starts_with s1 k with
        | True ->
          Cons ((Lcond0 ((negate_condition cond), args, s2)),
            (add_branch s1 k))
        | False -> Cons ((Lcond0 (cond, args, s1)), (add_branch s2 k)))
     | Ljumptable (arg, tbl) -> Cons ((Ljumptable0 (arg, tbl)), k)
     | Lreturn -> Cons (Lreturn0, k))

(** val linearize_node : function5 -> node0 -> code1 -> code1 **)

let linearize_node f pc k =
  match PTree.get pc f.fn_code0 with
  | Some b -> Cons ((Llabel pc), (linearize_block b k))
  | None -> k

(** val linearize_body : function5 -> node0 list -> code1 **)

let linearize_body f enum =
  list_fold_right (linearize_node f) enum Nil

(** val transf_function8 : function5 -> function6 res **)

let transf_function8 f =
  bind (enumerate f) (fun enum -> OK { fn_sig4 = f.fn_sig3; fn_stacksize1 =
    f.fn_stacksize0; fn_code1 =
    (add_branch f.fn_entrypoint0 (linearize_body f enum)) })

(** val transf_fundef8 : fundef5 -> fundef6 res **)

let transf_fundef8 f =
  transf_partial_fundef transf_function8 f

(** val transf_program7 : program5 -> program6 res **)

let transf_program7 p =
  transform_partial_program transf_fundef8 p

module Labelset = Coq_Make(OrderedPositive)

(** val add_label_branched_to : Labelset.t -> instruction1 -> Labelset.t **)

let add_label_branched_to ls = function
| Lgoto lbl -> Labelset.add lbl ls
| Lcond0 (cond, args, lbl) -> Labelset.add lbl ls
| Ljumptable0 (arg, tbl) -> fold_right Labelset.add ls tbl
| _ -> ls

(** val labels_branched_to : code1 -> Labelset.t **)

let labels_branched_to c =
  fold_left add_label_branched_to c Labelset.empty

(** val remove_unused : Labelset.t -> instruction1 -> code1 -> code1 **)

let remove_unused bto i k =
  match i with
  | Llabel lbl ->
    (match Labelset.mem lbl bto with
     | True -> Cons (i, k)
     | False -> k)
  | _ -> Cons (i, k)

(** val remove_unused_labels : Labelset.t -> code1 -> code1 **)

let remove_unused_labels bto c =
  list_fold_right (remove_unused bto) c Nil

(** val cleanup_labels : code1 -> code1 **)

let cleanup_labels c =
  remove_unused_labels (labels_branched_to c) c

(** val transf_function9 : function6 -> function6 **)

let transf_function9 f =
  { fn_sig4 = f.fn_sig4; fn_stacksize1 = f.fn_stacksize1; fn_code1 =
    (cleanup_labels f.fn_code1) }

(** val transf_fundef9 : fundef6 -> fundef6 **)

let transf_fundef9 f =
  transf_fundef transf_function9 f

(** val transf_program8 : program6 -> program6 **)

let transf_program8 p =
  transform_program transf_fundef9 p

type debuginfo = loc builtin_arg

(** val normalize_debug_1 : loc builtin_arg -> debuginfo option **)

let normalize_debug_1 = function
| BA_loadstack (chunk, ofs) -> None
| BA_addrstack ofs -> None
| BA_loadglobal (chunk, id, ofs) -> None
| BA_addrglobal (id, ofs) -> None
| BA_splitlong (hi0, lo0) ->
  (match hi0 with
   | BA hi ->
     (match lo0 with
      | BA lo -> Some (BA_splitlong ((BA hi), (BA lo)))
      | _ -> None)
   | _ -> None)
| x -> Some x

(** val normalize_debug : loc builtin_arg list -> debuginfo option **)

let rec normalize_debug = function
| Nil -> None
| Cons (a, l') ->
  (match a with
   | BA_int n0 ->
     (match normalize_debug l' with
      | Some i -> Some i
      | None -> normalize_debug_1 a)
   | BA_long n0 ->
     (match normalize_debug l' with
      | Some i -> Some i
      | None -> normalize_debug_1 a)
   | BA_float f ->
     (match normalize_debug l' with
      | Some i -> Some i
      | None -> normalize_debug_1 a)
   | BA_single f ->
     (match normalize_debug l' with
      | Some i -> Some i
      | None -> normalize_debug_1 a)
   | _ -> normalize_debug_1 a)

type avail = (ident, debuginfo) prod list

(** val set_state : ident -> debuginfo -> avail -> avail **)

let rec set_state v i s = match s with
| Nil -> Cons ((Pair (v, i)), Nil)
| Cons (vi', s') ->
  let Pair (v', i') = vi' in
  (match Coq_Pos.compare v v' with
   | Eq -> Cons ((Pair (v, i)), s')
   | Lt -> Cons ((Pair (v, i)), s)
   | Gt -> Cons (vi', (set_state v i s')))

(** val remove_state : ident -> avail -> avail **)

let rec remove_state v s = match s with
| Nil -> Nil
| Cons (vi', s') ->
  let Pair (v', i') = vi' in
  (match Coq_Pos.compare v v' with
   | Eq -> s'
   | Lt -> s
   | Gt -> Cons (vi', (remove_state v s')))

(** val set_debug_info : ident -> loc builtin_arg list -> avail -> avail **)

let rec set_debug_info v info s =
  match normalize_debug info with
  | Some a -> set_state v a s
  | None -> remove_state v s

(** val arg_no_overlap : loc builtin_arg -> loc -> bool **)

let rec arg_no_overlap a l =
  match a with
  | BA l' -> proj_sumbool (Loc.diff_dec l' l)
  | BA_splitlong (hi, lo) ->
    (match arg_no_overlap hi l with
     | True -> arg_no_overlap lo l
     | False -> False)
  | _ -> True

(** val kill0 : loc -> avail -> avail **)

let kill0 l s =
  filter (fun vi -> arg_no_overlap (snd vi) l) s

(** val kill_res : mreg builtin_res -> avail -> avail **)

let rec kill_res r s =
  match r with
  | BR r0 -> kill0 (R r0) s
  | BR_none -> s
  | BR_splitlong (hi, lo) -> kill_res hi (kill_res lo s)

(** val arg_preserved : loc builtin_arg -> bool **)

let rec arg_preserved = function
| BA x ->
  (match x with
   | R r -> negb (proj_sumbool (in_dec mreg_eq r destroyed_at_call))
   | S0 (sl, pos, ty) -> True)
| BA_splitlong (hi, lo) ->
  (match arg_preserved hi with
   | True -> arg_preserved lo
   | False -> False)
| _ -> True

(** val kill_at_call : avail -> avail **)

let kill_at_call s =
  filter (fun vi -> arg_preserved (snd vi)) s

(** val eq_arg : loc builtin_arg -> loc builtin_arg -> sumbool **)

let rec eq_arg b a0 =
  match b with
  | BA x ->
    (match a0 with
     | BA x0 -> Loc.eq x x0
     | _ -> Right)
  | BA_int n0 ->
    (match a0 with
     | BA_int n1 -> Int.eq_dec n0 n1
     | _ -> Right)
  | BA_long n0 ->
    (match a0 with
     | BA_long n1 -> Int64.eq_dec n0 n1
     | _ -> Right)
  | BA_float f ->
    (match a0 with
     | BA_float f0 -> Float.eq_dec f f0
     | _ -> Right)
  | BA_single f ->
    (match a0 with
     | BA_single f0 -> Float32.eq_dec f f0
     | _ -> Right)
  | BA_loadstack (chunk, ofs) ->
    (match a0 with
     | BA_loadstack (chunk0, ofs0) ->
       (match chunk_eq chunk chunk0 with
        | Left -> Int.eq_dec ofs ofs0
        | Right -> Right)
     | _ -> Right)
  | BA_addrstack ofs ->
    (match a0 with
     | BA_addrstack ofs0 -> Int.eq_dec ofs ofs0
     | _ -> Right)
  | BA_loadglobal (chunk, id, ofs) ->
    (match a0 with
     | BA_loadglobal (chunk0, id0, ofs0) ->
       (match chunk_eq chunk chunk0 with
        | Left ->
          (match ident_eq id id0 with
           | Left -> Int.eq_dec ofs ofs0
           | Right -> Right)
        | Right -> Right)
     | _ -> Right)
  | BA_addrglobal (id, ofs) ->
    (match a0 with
     | BA_addrglobal (id0, ofs0) ->
       (match ident_eq id id0 with
        | Left -> Int.eq_dec ofs ofs0
        | Right -> Right)
     | _ -> Right)
  | BA_splitlong (hi, lo) ->
    (match a0 with
     | BA_splitlong (hi0, lo0) ->
       (match eq_arg hi hi0 with
        | Left -> eq_arg lo lo0
        | Right -> Right)
     | _ -> Right)

(** val eq_debuginfo : debuginfo -> debuginfo -> sumbool **)

let eq_debuginfo i1 i2 =
  eq_arg i1 i2

(** val join0 : avail -> avail -> avail **)

let rec join0 s1 s2 =
  match s1 with
  | Nil -> Nil
  | Cons (vi1, s1') ->
    let Pair (v1, i1) = vi1 in
    let rec join2 s3 = match s3 with
    | Nil -> Nil
    | Cons (vi2, s2') ->
      let Pair (v2, i2) = vi2 in
      (match Coq_Pos.compare v1 v2 with
       | Eq ->
         (match eq_debuginfo i1 i2 with
          | Left -> Cons (vi1, (join0 s1' s2'))
          | Right -> join0 s1' s2')
       | Lt -> join0 s1' s3
       | Gt -> join2 s2')
    in join2 s2

(** val eq_state : avail -> avail -> sumbool **)

let eq_state s1 s2 =
  list_eq_dec (fun x y ->
    let Pair (x0, x1) = x in
    let Pair (i, d) = y in
    (match ident_eq x0 i with
     | Left -> eq_debuginfo x1 d
     | Right -> Right)) s1 s2

(** val top0 : avail **)

let top0 =
  Nil

type labelmap0 = (avail PTree.t, bool) prod

(** val get_label : label2 -> labelmap0 -> avail option **)

let get_label lbl lm =
  PTree.get lbl (fst lm)

(** val update_label :
    label2 -> avail -> labelmap0 -> (labelmap0, avail) prod **)

let update_label lbl s1 lm =
  match get_label lbl lm with
  | Some s2 ->
    let s = join0 s1 s2 in
    (match eq_state s s2 with
     | Left -> Pair (lm, s2)
     | Right -> Pair ((Pair ((PTree.set lbl s (fst lm)), True)), s))
  | None -> Pair ((Pair ((PTree.set lbl s1 (fst lm)), True)), s1)

(** val update_labels : label2 list -> avail -> labelmap0 -> labelmap0 **)

let rec update_labels lbls s lm =
  match lbls with
  | Nil -> lm
  | Cons (lbl1, lbls0) ->
    update_labels lbls0 s (fst (update_label lbl1 s lm))

(** val is_debug_setvar : external_function -> ident option **)

let is_debug_setvar = function
| EF_debug (kind, txt, targs) ->
  (match kind with
   | XO p ->
     (match p with
      | XH -> Some txt
      | _ -> None)
   | _ -> None)
| _ -> None

(** val is_builtin_debug_setvar : instruction1 -> ident option **)

let is_builtin_debug_setvar = function
| Lbuiltin0 (ef, args, b) ->
  (match b with
   | BR_none -> is_debug_setvar ef
   | _ -> None)
| _ -> None

(** val transfer4 :
    labelmap0 -> avail option -> instruction1 -> (labelmap0, avail option)
    prod **)

let transfer4 lm before i =
  match before with
  | Some s ->
    (match i with
     | Lgetstack0 (sl, ofs, ty, rd) -> Pair (lm, (Some (kill0 (R rd) s)))
     | Lsetstack0 (rs, sl, ofs, ty) ->
       Pair (lm, (Some (kill0 (S0 (sl, ofs, ty)) s)))
     | Lop0 (op, args, dst) -> Pair (lm, (Some (kill0 (R dst) s)))
     | Lload0 (chunk, addr, args, dst) -> Pair (lm, (Some (kill0 (R dst) s)))
     | Lstore0 (chunk, addr, args, src) -> Pair (lm, before)
     | Lcall0 (sg, ros) -> Pair (lm, (Some (kill_at_call s)))
     | Lbuiltin0 (ef, args, res2) ->
       let s' =
         match is_debug_setvar ef with
         | Some v -> set_debug_info v args s
         | None -> s
       in
       Pair (lm, (Some (kill_res res2 s')))
     | Llabel lbl ->
       let Pair (lm1, s1) = update_label lbl s lm in Pair (lm1, (Some s1))
     | Lgoto lbl ->
       let Pair (lm1, s1) = update_label lbl s lm in Pair (lm1, None)
     | Lcond0 (cond, args, lbl) ->
       let Pair (lm1, s1) = update_label lbl s lm in Pair (lm1, before)
     | Ljumptable0 (r, lbls) -> Pair ((update_labels lbls s lm), None)
     | _ -> Pair (lm, None))
  | None ->
    (match i with
     | Llabel lbl -> Pair (lm, (get_label lbl lm))
     | _ -> Pair (lm, None))

(** val ana_code : labelmap0 -> avail option -> code1 -> labelmap0 **)

let rec ana_code lm before = function
| Nil -> lm
| Cons (i, c0) ->
  let Pair (lm1, after) = transfer4 lm before i in ana_code lm1 after c0

(** val ana_iter : code1 -> labelmap0 -> (labelmap0, labelmap0) sum **)

let ana_iter c lm =
  let lm' = ana_code (Pair ((fst lm), False)) (Some top0) c in
  (match snd lm' with
   | True -> Inr lm'
   | False -> Inl lm)

(** val ana_function : function6 -> labelmap0 option **)

let ana_function f =
  PrimIter.iterate (ana_iter f.fn_code1) (Pair (PTree.empty, False))

(** val diff0 : avail -> avail -> avail **)

let rec diff0 s1 s2 =
  match s1 with
  | Nil -> Nil
  | Cons (vi1, s1') ->
    let Pair (v1, i1) = vi1 in
    let rec diff2 s3 = match s3 with
    | Nil -> s1
    | Cons (p, s2') ->
      let Pair (v2, i2) = p in
      (match Coq_Pos.compare v1 v2 with
       | Eq ->
         (match eq_debuginfo i1 i2 with
          | Left -> diff0 s1' s2'
          | Right -> Cons (vi1, (diff0 s1' s2')))
       | Lt -> Cons (vi1, (diff0 s1' s3))
       | Gt -> diff2 s2')
    in diff2 s2

(** val delta_state : avail option -> avail option -> (avail, avail) prod **)

let delta_state before after =
  match before with
  | Some b ->
    (match after with
     | Some a -> Pair ((diff0 b a), (diff0 a b))
     | None -> Pair (b, Nil))
  | None ->
    (match after with
     | Some a -> Pair (Nil, a)
     | None -> Pair (Nil, Nil))

(** val add_start_range : (ident, debuginfo) prod -> code1 -> code1 **)

let add_start_range vi c =
  let Pair (v, i) = vi in
  Cons ((Lbuiltin0 ((EF_debug ((XI XH), v, Nil)), (Cons (i, Nil)), BR_none)),
  c)

(** val add_end_range : (ident, debuginfo) prod -> code1 -> code1 **)

let add_end_range vi c =
  let Pair (v, i) = vi in
  Cons ((Lbuiltin0 ((EF_debug ((XO (XO XH)), v, Nil)), Nil, BR_none)), c)

(** val add_delta_ranges : avail option -> avail option -> code1 -> code1 **)

let add_delta_ranges before after c =
  let Pair (killed, born) = delta_state before after in
  fold_right add_end_range (fold_right add_start_range c born) killed

(** val skip_debug_setvar :
    labelmap0 -> avail option -> code1 -> avail option **)

let rec skip_debug_setvar lm before = function
| Nil -> before
| Cons (i, c') ->
  (match is_builtin_debug_setvar i with
   | Some i0 -> skip_debug_setvar lm (snd (transfer4 lm before i)) c'
   | None -> before)

(** val transf_code0 : labelmap0 -> avail option -> code1 -> code1 **)

let rec transf_code0 lm before = function
| Nil -> Nil
| Cons (i, c') ->
  (match i with
   | Lgoto lbl1 ->
     (match c' with
      | Nil ->
        let after = skip_debug_setvar lm (snd (transfer4 lm before i)) c' in
        Cons (i, (add_delta_ranges before after (transf_code0 lm after c')))
      | Cons (i0, c'0) ->
        (match i0 with
         | Llabel lbl2 ->
           let after = get_label lbl2 lm in
           Cons ((Lgoto lbl1), (Cons ((Llabel lbl2),
           (add_delta_ranges before after (transf_code0 lm after c'0)))))
         | _ ->
           let after = skip_debug_setvar lm (snd (transfer4 lm before i)) c'
           in
           Cons (i,
           (add_delta_ranges before after (transf_code0 lm after c')))))
   | _ ->
     let after = skip_debug_setvar lm (snd (transfer4 lm before i)) c' in
     Cons (i, (add_delta_ranges before after (transf_code0 lm after c'))))

(** val transf_function10 : function6 -> function6 res **)

let transf_function10 f =
  match ana_function f with
  | Some lm ->
    OK { fn_sig4 = f.fn_sig4; fn_stacksize1 = f.fn_stacksize1; fn_code1 =
      (transf_code0 lm (Some top0) f.fn_code1) }
  | None ->
    Error
      (msg (String ((Ascii (False, False, True, False, False, False, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, False, False, False,
        True, True, False)), (String ((Ascii (True, False, True, False, True,
        True, True, False)), (String ((Ascii (True, True, True, False, False,
        True, True, False)), (String ((Ascii (False, True, True, False, True,
        True, True, False)), (String ((Ascii (True, False, False, False,
        False, True, True, False)), (String ((Ascii (False, True, False,
        False, True, True, True, False)), (String ((Ascii (False, True,
        False, True, True, True, False, False)), (String ((Ascii (False,
        False, False, False, False, True, False, False)), (String ((Ascii
        (True, False, False, False, False, True, True, False)), (String
        ((Ascii (False, True, True, True, False, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, True, False, True, True,
        False)), (String ((Ascii (True, False, False, True, True, True, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, False, True, False, True,
        True, False)), (String ((Ascii (True, True, False, False, True, True,
        True, False)), (String ((Ascii (False, False, False, False, False,
        True, False, False)), (String ((Ascii (False, False, True, False,
        False, True, True, False)), (String ((Ascii (True, False, False,
        True, False, True, True, False)), (String ((Ascii (False, True, True,
        False, True, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (False, True,
        False, False, True, True, True, False)), (String ((Ascii (True, True,
        True, False, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (True, True, False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val transf_fundef10 : fundef6 -> fundef6 res **)

let transf_fundef10 fd =
  transf_partial_fundef transf_function10 fd

(** val transf_program9 : program6 -> program6 res **)

let transf_program9 p =
  transform_partial_program transf_fundef10 p

(** val slot_valid : function6 -> slot -> z -> typ -> bool **)

let slot_valid funct sl ofs ty =
  match match sl with
        | Incoming ->
          proj_sumbool
            (in_dec Loc.eq (S0 (Incoming, ofs, ty))
              (loc_parameters funct.fn_sig4))
        | _ -> proj_sumbool (zle Z0 ofs) with
  | True ->
    (match ty with
     | Tlong -> False
     | _ -> True)
  | False -> False

(** val slot_writable : slot -> bool **)

let slot_writable = function
| Incoming -> False
| _ -> True

(** val loc_valid : function6 -> loc -> bool **)

let loc_valid funct = function
| R r -> True
| S0 (sl, ofs, ty) ->
  (match sl with
   | Local -> slot_valid funct Local ofs ty
   | _ -> False)

(** val wt_builtin_res : typ -> mreg builtin_res -> bool **)

let rec wt_builtin_res ty = function
| BR r -> subtype ty (mreg_type r)
| BR_none -> True
| BR_splitlong (hi, lo) ->
  (match wt_builtin_res Tint hi with
   | True -> wt_builtin_res Tint lo
   | False -> False)

(** val wt_instr : function6 -> instruction1 -> bool **)

let wt_instr funct = function
| Lgetstack0 (sl, ofs, ty, r) ->
  (match subtype ty (mreg_type r) with
   | True -> slot_valid funct sl ofs ty
   | False -> False)
| Lsetstack0 (r, sl, ofs, ty) ->
  (match slot_valid funct sl ofs ty with
   | True -> slot_writable sl
   | False -> False)
| Lop0 (op, args, res2) ->
  (match is_move_operation op args with
   | Some arg -> subtype (mreg_type arg) (mreg_type res2)
   | None ->
     let Pair (targs, tres) = type_of_operation op in
     subtype tres (mreg_type res2))
| Lload0 (chunk, addr, args, dst) ->
  subtype (type_of_chunk chunk) (mreg_type dst)
| Ltailcall0 (sg, ros) -> proj_sumbool (zeq (size_arguments sg) Z0)
| Lbuiltin0 (ef, args, res2) ->
  (match wt_builtin_res (proj_sig_res (ef_sig ef)) res2 with
   | True -> forallb (loc_valid funct) (params_of_builtin_args args)
   | False -> False)
| _ -> True

(** val wt_code : function6 -> code1 -> bool **)

let wt_code f c =
  forallb (wt_instr f) c

(** val wt_function : function6 -> bool **)

let wt_function f =
  wt_code f f.fn_code1

type frame_index =
| FI_link
| FI_retaddr
| FI_local of z * typ
| FI_arg of z * typ
| FI_saved_int of z
| FI_saved_float of z

(** val offset_of_index : frame_env -> frame_index -> z **)

let offset_of_index fe = function
| FI_link -> fe.fe_ofs_link
| FI_retaddr -> fe.fe_ofs_retaddr
| FI_local (x, ty) -> Z.add fe.fe_ofs_local (Z.mul (Zpos (XO (XO XH))) x)
| FI_arg (x, ty) -> Z.add fe_ofs_arg (Z.mul (Zpos (XO (XO XH))) x)
| FI_saved_int x ->
  Z.add fe.fe_ofs_int_callee_save (Z.mul (Zpos (XO (XO XH))) x)
| FI_saved_float x ->
  Z.add fe.fe_ofs_float_callee_save (Z.mul (Zpos (XO (XO (XO XH)))) x)

(** val save_callee_save_reg :
    (frame_env -> z) -> (mreg -> z) -> (z -> frame_index) -> typ -> frame_env
    -> mreg -> code2 -> instruction2 list **)

let save_callee_save_reg bound number mkindex ty fe cs k =
  let i = number cs in
  (match zlt i (bound fe) with
   | Left ->
     Cons ((Msetstack (cs, (Int.repr (offset_of_index fe (mkindex i))), ty)),
       k)
   | Right -> k)

(** val save_callee_save_regs :
    (frame_env -> z) -> (mreg -> z) -> (z -> frame_index) -> typ -> frame_env
    -> mreg list -> code2 -> code2 **)

let save_callee_save_regs bound number mkindex ty fe csl k =
  fold_right (save_callee_save_reg bound number mkindex ty fe) k csl

(** val save_callee_save_int : frame_env -> code2 -> code2 **)

let save_callee_save_int fe =
  save_callee_save_regs fe_num_int_callee_save index_int_callee_save
    (fun x -> FI_saved_int x) Tany32 fe int_callee_save_regs

(** val save_callee_save_float : frame_env -> code2 -> code2 **)

let save_callee_save_float fe =
  save_callee_save_regs fe_num_float_callee_save index_float_callee_save
    (fun x -> FI_saved_float x) Tany64 fe float_callee_save_regs

(** val save_callee_save : frame_env -> code2 -> code2 **)

let save_callee_save fe k =
  save_callee_save_int fe (save_callee_save_float fe k)

(** val restore_callee_save_reg :
    (frame_env -> z) -> (mreg -> z) -> (z -> frame_index) -> typ -> frame_env
    -> mreg -> code2 -> instruction2 list **)

let restore_callee_save_reg bound number mkindex ty fe cs k =
  let i = number cs in
  (match zlt i (bound fe) with
   | Left ->
     Cons ((Mgetstack ((Int.repr (offset_of_index fe (mkindex i))), ty, cs)),
       k)
   | Right -> k)

(** val restore_callee_save_regs :
    (frame_env -> z) -> (mreg -> z) -> (z -> frame_index) -> typ -> frame_env
    -> mreg list -> code2 -> code2 **)

let restore_callee_save_regs bound number mkindex ty fe csl k =
  fold_right (restore_callee_save_reg bound number mkindex ty fe) k csl

(** val restore_callee_save_int : frame_env -> code2 -> code2 **)

let restore_callee_save_int fe =
  restore_callee_save_regs fe_num_int_callee_save index_int_callee_save
    (fun x -> FI_saved_int x) Tany32 fe int_callee_save_regs

(** val restore_callee_save_float : frame_env -> code2 -> code2 **)

let restore_callee_save_float fe =
  restore_callee_save_regs fe_num_float_callee_save index_float_callee_save
    (fun x -> FI_saved_float x) Tany64 fe float_callee_save_regs

(** val restore_callee_save : frame_env -> code2 -> code2 **)

let restore_callee_save fe k =
  restore_callee_save_int fe (restore_callee_save_float fe k)

(** val transl_op : frame_env -> operation -> operation **)

let transl_op fe op =
  shift_stack_operation (Int.repr fe.fe_stack_data) op

(** val transl_addr : frame_env -> addressing -> addressing **)

let transl_addr fe addr =
  shift_stack_addressing (Int.repr fe.fe_stack_data) addr

(** val transl_builtin_arg :
    frame_env -> loc builtin_arg -> mreg builtin_arg **)

let rec transl_builtin_arg fe = function
| BA x ->
  (match x with
   | R r -> BA r
   | S0 (sl, ofs, ty) ->
     (match sl with
      | Local ->
        BA_loadstack ((chunk_of_type ty),
          (Int.repr (offset_of_index fe (FI_local (ofs, ty)))))
      | _ -> BA_int Int.zero))
| BA_int n0 -> BA_int n0
| BA_long n0 -> BA_long n0
| BA_float n0 -> BA_float n0
| BA_single n0 -> BA_single n0
| BA_loadstack (chunk, ofs) ->
  BA_loadstack (chunk, (Int.add ofs (Int.repr fe.fe_stack_data)))
| BA_addrstack ofs -> BA_addrstack (Int.add ofs (Int.repr fe.fe_stack_data))
| BA_loadglobal (chunk, id, ofs) -> BA_loadglobal (chunk, id, ofs)
| BA_addrglobal (id, ofs) -> BA_addrglobal (id, ofs)
| BA_splitlong (hi, lo) ->
  BA_splitlong ((transl_builtin_arg fe hi), (transl_builtin_arg fe lo))

(** val transl_instr : frame_env -> instruction1 -> code2 -> code2 **)

let transl_instr fe i k =
  match i with
  | Lgetstack0 (sl, ofs, ty, r) ->
    (match sl with
     | Local ->
       Cons ((Mgetstack
         ((Int.repr (offset_of_index fe (FI_local (ofs, ty)))), ty, r)), k)
     | Incoming ->
       Cons ((Mgetparam ((Int.repr (offset_of_index fe (FI_arg (ofs, ty)))),
         ty, r)), k)
     | Outgoing ->
       Cons ((Mgetstack ((Int.repr (offset_of_index fe (FI_arg (ofs, ty)))),
         ty, r)), k))
  | Lsetstack0 (r, sl, ofs, ty) ->
    (match sl with
     | Local ->
       Cons ((Msetstack (r,
         (Int.repr (offset_of_index fe (FI_local (ofs, ty)))), ty)), k)
     | Incoming -> k
     | Outgoing ->
       Cons ((Msetstack (r,
         (Int.repr (offset_of_index fe (FI_arg (ofs, ty)))), ty)), k))
  | Lop0 (op, args, res2) -> Cons ((Mop ((transl_op fe op), args, res2)), k)
  | Lload0 (chunk, addr, args, dst) ->
    Cons ((Mload (chunk, (transl_addr fe addr), args, dst)), k)
  | Lstore0 (chunk, addr, args, src) ->
    Cons ((Mstore (chunk, (transl_addr fe addr), args, src)), k)
  | Lcall0 (sig1, ros) -> Cons ((Mcall (sig1, ros)), k)
  | Ltailcall0 (sig1, ros) ->
    restore_callee_save fe (Cons ((Mtailcall (sig1, ros)), k))
  | Lbuiltin0 (ef, args, dst) ->
    Cons ((Mbuiltin (ef, (map (transl_builtin_arg fe) args), dst)), k)
  | Llabel lbl -> Cons ((Mlabel lbl), k)
  | Lgoto lbl -> Cons ((Mgoto lbl), k)
  | Lcond0 (cond, args, lbl) -> Cons ((Mcond (cond, args, lbl)), k)
  | Ljumptable0 (arg, tbl) -> Cons ((Mjumptable (arg, tbl)), k)
  | Lreturn0 -> restore_callee_save fe (Cons (Mreturn, k))

(** val transl_code : frame_env -> instruction1 list -> code2 **)

let transl_code fe il =
  list_fold_right (transl_instr fe) il Nil

(** val transl_body : function6 -> frame_env -> code2 **)

let transl_body f fe =
  save_callee_save fe (transl_code fe f.fn_code1)

(** val transf_function11 : function6 -> function7 res **)

let transf_function11 f =
  let fe = make_env (function_bounds f) in
  (match negb (wt_function f) with
   | True ->
     Error
       (msg (String ((Ascii (True, False, False, True, False, False, True,
         False)), (String ((Ascii (False, False, True, True, False, True,
         True, False)), (String ((Ascii (False, False, True, True, False,
         True, True, False)), (String ((Ascii (True, False, True, True,
         False, True, False, False)), (String ((Ascii (False, True, True,
         False, False, True, True, False)), (String ((Ascii (True, True,
         True, True, False, True, True, False)), (String ((Ascii (False,
         True, False, False, True, True, True, False)), (String ((Ascii
         (True, False, True, True, False, True, True, False)), (String
         ((Ascii (True, False, True, False, False, True, True, False)),
         (String ((Ascii (False, False, True, False, False, True, True,
         False)), (String ((Ascii (False, False, False, False, False, True,
         False, False)), (String ((Ascii (False, False, True, True, False,
         False, True, False)), (String ((Ascii (True, False, False, True,
         False, True, True, False)), (String ((Ascii (False, True, True,
         True, False, True, True, False)), (String ((Ascii (True, False,
         True, False, False, True, True, False)), (String ((Ascii (True,
         False, False, False, False, True, True, False)), (String ((Ascii
         (False, True, False, False, True, True, True, False)), (String
         ((Ascii (False, False, False, False, False, True, False, False)),
         (String ((Ascii (True, True, False, False, False, True, True,
         False)), (String ((Ascii (True, True, True, True, False, True, True,
         False)), (String ((Ascii (False, False, True, False, False, True,
         True, False)), (String ((Ascii (True, False, True, False, False,
         True, True, False)),
         EmptyString)))))))))))))))))))))))))))))))))))))))))))))
   | False ->
     (match zlt Int.max_unsigned fe.fe_size with
      | Left ->
        Error
          (msg (String ((Ascii (False, False, True, False, True, False, True,
            False)), (String ((Ascii (True, True, True, True, False, True,
            True, False)), (String ((Ascii (True, True, True, True, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            False, True, False, False)), (String ((Ascii (True, False, True,
            True, False, True, True, False)), (String ((Ascii (True, False,
            False, False, False, True, True, False)), (String ((Ascii (False,
            True, True, True, False, True, True, False)), (String ((Ascii
            (True, False, False, True, True, True, True, False)), (String
            ((Ascii (False, False, False, False, False, True, False, False)),
            (String ((Ascii (True, True, False, False, True, True, True,
            False)), (String ((Ascii (False, False, False, False, True, True,
            True, False)), (String ((Ascii (True, False, False, True, False,
            True, True, False)), (String ((Ascii (False, False, True, True,
            False, True, True, False)), (String ((Ascii (False, False, True,
            True, False, True, True, False)), (String ((Ascii (True, False,
            True, False, False, True, True, False)), (String ((Ascii (False,
            False, True, False, False, True, True, False)), (String ((Ascii
            (False, False, False, False, False, True, False, False)), (String
            ((Ascii (False, True, True, False, True, True, True, False)),
            (String ((Ascii (True, False, False, False, False, True, True,
            False)), (String ((Ascii (False, True, False, False, True, True,
            True, False)), (String ((Ascii (True, False, False, True, False,
            True, True, False)), (String ((Ascii (True, False, False, False,
            False, True, True, False)), (String ((Ascii (False, True, False,
            False, False, True, True, False)), (String ((Ascii (False, False,
            True, True, False, True, True, False)), (String ((Ascii (True,
            False, True, False, False, True, True, False)), (String ((Ascii
            (True, True, False, False, True, True, True, False)), (String
            ((Ascii (False, False, True, True, False, True, False, False)),
            (String ((Ascii (False, False, False, False, False, True, False,
            False)), (String ((Ascii (True, True, False, False, True, True,
            True, False)), (String ((Ascii (False, False, True, False, True,
            True, True, False)), (String ((Ascii (True, False, False, False,
            False, True, True, False)), (String ((Ascii (True, True, False,
            False, False, True, True, False)), (String ((Ascii (True, True,
            False, True, False, True, True, False)), (String ((Ascii (False,
            False, False, False, False, True, False, False)), (String ((Ascii
            (True, True, False, False, True, True, True, False)), (String
            ((Ascii (True, False, False, True, False, True, True, False)),
            (String ((Ascii (False, True, False, True, True, True, True,
            False)), (String ((Ascii (True, False, True, False, False, True,
            True, False)), (String ((Ascii (False, False, False, False,
            False, True, False, False)), (String ((Ascii (True, False, True,
            False, False, True, True, False)), (String ((Ascii (False, False,
            False, True, True, True, True, False)), (String ((Ascii (True,
            True, False, False, False, True, True, False)), (String ((Ascii
            (True, False, True, False, False, True, True, False)), (String
            ((Ascii (True, False, True, False, False, True, True, False)),
            (String ((Ascii (False, False, True, False, False, True, True,
            False)), (String ((Ascii (True, False, True, False, False, True,
            True, False)), (String ((Ascii (False, False, True, False, False,
            True, True, False)),
            EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
      | Right ->
        OK { fn_sig5 = f.fn_sig4; fn_code2 = (transl_body f fe);
          fn_stacksize2 = fe.fe_size; fn_link_ofs =
          (Int.repr fe.fe_ofs_link); fn_retaddr_ofs =
          (Int.repr fe.fe_ofs_retaddr) }))

(** val transf_fundef11 : fundef6 -> fundef7 res **)

let transf_fundef11 f =
  transf_partial_fundef transf_function11 f

(** val transf_program10 : program6 -> program7 res **)

let transf_program10 p =
  transform_partial_program transf_fundef11 p

(** val ireg_of : mreg -> ireg res **)

let ireg_of r =
  match preg_of r with
  | IR mr -> OK mr
  | _ ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (True, False, False, True, False,
        True, True, False)), (String ((Ascii (False, True, False, False,
        True, True, True, False)), (String ((Ascii (True, False, True, False,
        False, True, True, False)), (String ((Ascii (True, True, True, False,
        False, True, True, False)), (String ((Ascii (True, True, True, True,
        True, False, True, False)), (String ((Ascii (True, True, True, True,
        False, True, True, False)), (String ((Ascii (False, True, True,
        False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))

(** val freg_of : mreg -> freg res **)

let freg_of r =
  match preg_of r with
  | FR mr -> OK mr
  | _ ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (False, True, True, False, False,
        True, True, False)), (String ((Ascii (False, True, False, False,
        True, True, True, False)), (String ((Ascii (True, False, True, False,
        False, True, True, False)), (String ((Ascii (True, True, True, False,
        False, True, True, False)), (String ((Ascii (True, True, True, True,
        True, False, True, False)), (String ((Ascii (True, True, True, True,
        False, True, True, False)), (String ((Ascii (False, True, True,
        False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))

(** val mk_mov : preg -> preg -> code3 -> code3 res **)

let mk_mov rd rs k =
  match rd with
  | IR rd0 ->
    (match rs with
     | IR rs0 -> OK (Cons ((Pmov_rr (rd0, rs0)), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, False, True, False, True, True, False)),
           (String ((Ascii (True, True, True, True, True, False, True,
           False)), (String ((Ascii (True, False, True, True, False, True,
           True, False)), (String ((Ascii (True, True, True, True, False,
           True, True, False)), (String ((Ascii (False, True, True, False,
           True, True, True, False)), EmptyString))))))))))))))))))))))))))))
  | FR rd0 ->
    (match rs with
     | FR rs0 -> OK (Cons ((Pmovsd_ff (rd0, rs0)), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, False, True, False, True, True, False)),
           (String ((Ascii (True, True, True, True, True, False, True,
           False)), (String ((Ascii (True, False, True, True, False, True,
           True, False)), (String ((Ascii (True, True, True, True, False,
           True, True, False)), (String ((Ascii (False, True, True, False,
           True, True, True, False)), EmptyString))))))))))))))))))))))))))))
  | _ ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (True, False, True, True, False,
        True, True, False)), (String ((Ascii (True, True, False, True, False,
        True, True, False)), (String ((Ascii (True, True, True, True, True,
        False, True, False)), (String ((Ascii (True, False, True, True,
        False, True, True, False)), (String ((Ascii (True, True, True, True,
        False, True, True, False)), (String ((Ascii (False, True, True,
        False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))

(** val mk_shrximm : Int.int -> code3 -> code3 res **)

let mk_shrximm n0 k =
  let p = Int.sub (Int.shl Int.one n0) Int.one in
  OK (Cons ((Ptest_rr (EAX, EAX)), (Cons ((Plea (ECX, (Addrmode ((Some EAX),
  None, (Inl p))))), (Cons ((Pcmov (Cond_l, EAX, ECX)), (Cons ((Psar_ri (EAX,
  n0)), k))))))))

(** val low_ireg : ireg -> bool **)

let low_ireg = function
| ESI -> False
| EDI -> False
| EBP -> False
| ESP -> False
| _ -> True

(** val mk_intconv :
    (ireg -> ireg -> instruction3) -> ireg -> ireg -> code3 -> instruction3
    list res **)

let mk_intconv mk rd rs k =
  match low_ireg rs with
  | True -> OK (Cons ((mk rd rs), k))
  | False -> OK (Cons ((Pmov_rr (EAX, rs)), (Cons ((mk rd EAX), k))))

(** val addressing_mentions : addrmode -> ireg -> bool **)

let addressing_mentions addr r =
  let Addrmode (base, displ, const) = addr in
  (match match base with
         | Some r' -> proj_sumbool (ireg_eq r r')
         | None -> False with
   | True -> True
   | False ->
     (match displ with
      | Some p -> let Pair (r', sc) = p in proj_sumbool (ireg_eq r r')
      | None -> False))

(** val mk_smallstore :
    (addrmode -> ireg -> instruction3) -> addrmode -> ireg -> code3 ->
    instruction3 list res **)

let mk_smallstore sto addr rs k =
  match low_ireg rs with
  | True -> OK (Cons ((sto addr rs), k))
  | False ->
    (match addressing_mentions addr EAX with
     | True ->
       OK (Cons ((Plea (ECX, addr)), (Cons ((Pmov_rr (EAX, rs)), (Cons
         ((sto (Addrmode ((Some ECX), None, (Inl Int.zero))) EAX), k))))))
     | False -> OK (Cons ((Pmov_rr (EAX, rs)), (Cons ((sto addr EAX), k)))))

(** val loadind :
    ireg -> Int.int -> typ -> mreg -> code3 -> instruction3 list res **)

let loadind base ofs ty dst k =
  match ty with
  | Tint ->
    (match preg_of dst with
     | IR r ->
       OK (Cons ((Pmov_rm (r, (Addrmode ((Some base), None, (Inl ofs))))),
         k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, True, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))
  | Tfloat ->
    (match preg_of dst with
     | FR r ->
       OK (Cons ((Pmovsd_fm (r, (Addrmode ((Some base), None, (Inl ofs))))),
         k))
     | ST0 ->
       OK (Cons ((Pfldl_m (Addrmode ((Some base), None, (Inl ofs)))), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, True, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))
  | Tlong ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (False, False, True, True, False,
        True, True, False)), (String ((Ascii (True, True, True, True, False,
        True, True, False)), (String ((Ascii (True, False, False, False,
        False, True, True, False)), (String ((Ascii (False, False, True,
        False, False, True, True, False)), (String ((Ascii (True, False,
        False, True, False, True, True, False)), (String ((Ascii (False,
        True, True, True, False, True, True, False)), (String ((Ascii (False,
        False, True, False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))
  | Tsingle ->
    (match preg_of dst with
     | FR r ->
       OK (Cons ((Pmovss_fm (r, (Addrmode ((Some base), None, (Inl ofs))))),
         k))
     | ST0 ->
       OK (Cons ((Pflds_m (Addrmode ((Some base), None, (Inl ofs)))), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, True, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))
  | Tany32 ->
    (match preg_of dst with
     | IR r ->
       OK (Cons ((Pmov_rm_a (r, (Addrmode ((Some base), None, (Inl ofs))))),
         k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, True, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))
  | Tany64 ->
    (match preg_of dst with
     | FR r ->
       OK (Cons ((Pmovsd_fm_a (r, (Addrmode ((Some base), None, (Inl
         ofs))))), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, True, False, True, True, False)), (String
           ((Ascii (True, True, True, True, False, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, False, True, False, False, True,
           True, False)), (String ((Ascii (True, False, False, True, False,
           True, True, False)), (String ((Ascii (False, True, True, True,
           False, True, True, False)), (String ((Ascii (False, False, True,
           False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))

(** val storeind :
    mreg -> ireg -> Int.int -> typ -> code3 -> instruction3 list res **)

let storeind src base ofs ty k =
  match ty with
  | Tint ->
    (match preg_of src with
     | IR r ->
       OK (Cons ((Pmov_mr ((Addrmode ((Some base), None, (Inl ofs))), r)),
         k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, True, True, False, True, True,
           False)), (String ((Ascii (False, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (False, False,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))
  | Tfloat ->
    (match preg_of src with
     | FR r ->
       OK (Cons ((Pmovsd_mf ((Addrmode ((Some base), None, (Inl ofs))), r)),
         k))
     | ST0 ->
       OK (Cons ((Pfstpl_m (Addrmode ((Some base), None, (Inl ofs)))), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, True, True, False, True, True,
           False)), (String ((Ascii (False, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (False, False,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))
  | Tlong ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (True, True, False, False, True,
        True, True, False)), (String ((Ascii (False, False, True, False,
        True, True, True, False)), (String ((Ascii (True, True, True, True,
        False, True, True, False)), (String ((Ascii (False, True, False,
        False, True, True, True, False)), (String ((Ascii (True, False, True,
        False, False, True, True, False)), (String ((Ascii (True, False,
        False, True, False, True, True, False)), (String ((Ascii (False,
        True, True, True, False, True, True, False)), (String ((Ascii (False,
        False, True, False, False, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))
  | Tsingle ->
    (match preg_of src with
     | FR r ->
       OK (Cons ((Pmovss_mf ((Addrmode ((Some base), None, (Inl ofs))), r)),
         k))
     | ST0 ->
       OK (Cons ((Pfstps_m (Addrmode ((Some base), None, (Inl ofs)))), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, True, True, False, True, True,
           False)), (String ((Ascii (False, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (False, False,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))
  | Tany32 ->
    (match preg_of src with
     | IR r ->
       OK (Cons ((Pmov_mr_a ((Addrmode ((Some base), None, (Inl ofs))), r)),
         k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, True, True, False, True, True,
           False)), (String ((Ascii (False, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (False, False,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))
  | Tany64 ->
    (match preg_of src with
     | FR r ->
       OK (Cons ((Pmovsd_mf_a ((Addrmode ((Some base), None, (Inl ofs))),
         r)), k))
     | _ ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (True, True, False, False, True, True, True, False)), (String
           ((Ascii (False, False, True, False, True, True, True, False)),
           (String ((Ascii (True, True, True, True, False, True, True,
           False)), (String ((Ascii (False, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, False, False,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (False, False,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))

(** val transl_addressing : addressing -> mreg list -> addrmode res **)

let transl_addressing a args =
  match a with
  | Aindexed n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Addrmode ((Some r1), None, (Inl
            n0))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))
  | Aindexed2 n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (ireg_of a1) (fun r1 ->
               bind (ireg_of a2) (fun r2 -> OK (Addrmode ((Some r1), (Some
                 (Pair (r2, Int.one))), (Inl n0)))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, False,
                 False, False, False, True, True, False)), (String ((Ascii
                 (False, False, True, False, False, True, True, False)),
                 (String ((Ascii (False, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, False, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (True, True, False, False, True, True, True,
                 False)), (String ((Ascii (True, False, False, True, False,
                 True, True, False)), (String ((Ascii (False, True, True,
                 True, False, True, True, False)), (String ((Ascii (True,
                 True, True, False, False, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))
  | Ascaled (sc, n0) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Addrmode (None, (Some (Pair (r1,
            sc))), (Inl n0))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))
  | Aindexed2scaled (sc, n0) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (ireg_of a1) (fun r1 ->
               bind (ireg_of a2) (fun r2 -> OK (Addrmode ((Some r1), (Some
                 (Pair (r2, sc))), (Inl n0)))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, False,
                 False, False, False, True, True, False)), (String ((Ascii
                 (False, False, True, False, False, True, True, False)),
                 (String ((Ascii (False, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, False, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (True, True, False, False, True, True, True,
                 False)), (String ((Ascii (True, False, False, True, False,
                 True, True, False)), (String ((Ascii (False, True, True,
                 True, False, True, True, False)), (String ((Ascii (True,
                 True, True, False, False, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))
  | Aglobal (id, ofs) ->
    (match args with
     | Nil -> OK (Addrmode (None, None, (Inr (Pair (id, ofs)))))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))
  | Abased (id, ofs) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Addrmode ((Some r1), None, (Inr
            (Pair (id, ofs))))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))
  | Abasedscaled (sc, id, ofs) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Addrmode (None, (Some (Pair (r1,
            sc))), (Inr (Pair (id, ofs))))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, False, False, False, False,
              True, True, False)), (String ((Ascii (False, False, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, False, False, True, True, True, False)), (String
              ((Ascii (True, False, True, False, False, True, True, False)),
              (String ((Ascii (True, True, False, False, True, True, True,
              False)), (String ((Ascii (True, True, False, False, True, True,
              True, False)), (String ((Ascii (True, False, False, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))))))))))))))
  | Ainstack n0 ->
    (match args with
     | Nil -> OK (Addrmode ((Some ESP), None, (Inl n0)))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, False,
           False, False, False, True, True, False)), (String ((Ascii (False,
           False, True, False, False, True, True, False)), (String ((Ascii
           (False, False, True, False, False, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, True, False, False, True, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (True, False, False, True,
           False, True, True, False)), (String ((Ascii (False, True, True,
           True, False, True, True, False)), (String ((Ascii (True, True,
           True, False, False, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))

(** val floatcomp : comparison0 -> freg -> freg -> instruction3 **)

let floatcomp cmp0 r1 r2 =
  match cmp0 with
  | Clt -> Pcomisd_ff (r2, r1)
  | Cle -> Pcomisd_ff (r2, r1)
  | _ -> Pcomisd_ff (r1, r2)

(** val floatcomp32 : comparison0 -> freg -> freg -> instruction3 **)

let floatcomp32 cmp0 r1 r2 =
  match cmp0 with
  | Clt -> Pcomiss_ff (r2, r1)
  | Cle -> Pcomiss_ff (r2, r1)
  | _ -> Pcomiss_ff (r1, r2)

(** val transl_cond : condition -> mreg list -> code3 -> code3 res **)

let transl_cond cond args k =
  match cond with
  | Ccompimm (c, n0) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK
            (match Int.eq_dec n0 Int.zero with
             | Left -> Cons ((Ptest_rr (r1, r1)), k)
             | Right -> Cons ((Pcmp_ri (r1, n0)), k)))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))
  | Ccompuimm (c, n0) ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Cons ((Pcmp_ri (r1, n0)), k)))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))
  | Ccompf cmp0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (freg_of a1) (fun r1 ->
               bind (freg_of a2) (fun r2 -> OK (Cons ((floatcomp cmp0 r1 r2),
                 k))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 False, False, False, True, True, False)), (String ((Ascii
                 (True, True, True, True, False, True, True, False)), (String
                 ((Ascii (False, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, False, True, False, False,
                 True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))
  | Cnotcompf cmp0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (freg_of a1) (fun r1 ->
               bind (freg_of a2) (fun r2 -> OK (Cons ((floatcomp cmp0 r1 r2),
                 k))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 False, False, False, True, True, False)), (String ((Ascii
                 (True, True, True, True, False, True, True, False)), (String
                 ((Ascii (False, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, False, True, False, False,
                 True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))
  | Ccompfs cmp0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (freg_of a1) (fun r1 ->
               bind (freg_of a2) (fun r2 -> OK (Cons
                 ((floatcomp32 cmp0 r1 r2), k))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 False, False, False, True, True, False)), (String ((Ascii
                 (True, True, True, True, False, True, True, False)), (String
                 ((Ascii (False, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, False, True, False, False,
                 True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))
  | Cnotcompfs cmp0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (freg_of a1) (fun r1 ->
               bind (freg_of a2) (fun r2 -> OK (Cons
                 ((floatcomp32 cmp0 r1 r2), k))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 False, False, False, True, True, False)), (String ((Ascii
                 (True, True, True, True, False, True, True, False)), (String
                 ((Ascii (False, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, False, True, False, False,
                 True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))
  | Cmaskzero n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Cons ((Ptest_ri (r1, n0)), k)))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))
  | Cmasknotzero n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 -> OK (Cons ((Ptest_ri (r1, n0)), k)))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))))
  | _ ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           False, False, False, True, True, False)), (String ((Ascii (True,
           True, True, True, False, True, True, False)), (String ((Ascii
           (False, True, True, True, False, True, True, False)), (String
           ((Ascii (False, False, True, False, False, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, False, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, True, True,
              True, False, True, True, False)), (String ((Ascii (False,
              False, True, False, False, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             bind (ireg_of a1) (fun r1 ->
               bind (ireg_of a2) (fun r2 -> OK (Cons ((Pcmp_rr (r1, r2)),
                 k))))
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 False, False, False, True, True, False)), (String ((Ascii
                 (True, True, True, True, False, True, True, False)), (String
                 ((Ascii (False, True, True, True, False, True, True,
                 False)), (String ((Ascii (False, False, True, False, False,
                 True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))))))

(** val testcond_for_signed_comparison : comparison0 -> testcond **)

let testcond_for_signed_comparison = function
| Ceq -> Cond_e
| Cne -> Cond_ne
| Clt -> Cond_l
| Cle -> Cond_le
| Cgt -> Cond_g
| Cge -> Cond_ge

(** val testcond_for_unsigned_comparison : comparison0 -> testcond **)

let testcond_for_unsigned_comparison = function
| Ceq -> Cond_e
| Cne -> Cond_ne
| Clt -> Cond_b
| Cle -> Cond_be
| Cgt -> Cond_a
| Cge -> Cond_ae

type extcond =
| Cond_base of testcond
| Cond_or of testcond * testcond
| Cond_and of testcond * testcond

(** val testcond_for_condition : condition -> extcond **)

let testcond_for_condition = function
| Ccomp c -> Cond_base (testcond_for_signed_comparison c)
| Ccompu c -> Cond_base (testcond_for_unsigned_comparison c)
| Ccompimm (c, n0) -> Cond_base (testcond_for_signed_comparison c)
| Ccompuimm (c, n0) -> Cond_base (testcond_for_unsigned_comparison c)
| Ccompf c ->
  (match c with
   | Ceq -> Cond_and (Cond_np, Cond_e)
   | Cne -> Cond_or (Cond_p, Cond_ne)
   | Clt -> Cond_base Cond_a
   | Cgt -> Cond_base Cond_a
   | _ -> Cond_base Cond_ae)
| Cnotcompf c ->
  (match c with
   | Ceq -> Cond_or (Cond_p, Cond_ne)
   | Cne -> Cond_and (Cond_np, Cond_e)
   | Cle -> Cond_base Cond_b
   | Cge -> Cond_base Cond_b
   | _ -> Cond_base Cond_be)
| Ccompfs c ->
  (match c with
   | Ceq -> Cond_and (Cond_np, Cond_e)
   | Cne -> Cond_or (Cond_p, Cond_ne)
   | Clt -> Cond_base Cond_a
   | Cgt -> Cond_base Cond_a
   | _ -> Cond_base Cond_ae)
| Cnotcompfs c ->
  (match c with
   | Ceq -> Cond_or (Cond_p, Cond_ne)
   | Cne -> Cond_and (Cond_np, Cond_e)
   | Cle -> Cond_base Cond_b
   | Cge -> Cond_base Cond_b
   | _ -> Cond_base Cond_be)
| Cmaskzero n0 -> Cond_base Cond_e
| Cmasknotzero n0 -> Cond_base Cond_ne

(** val mk_setcc_base : extcond -> ireg -> code3 -> instruction3 list **)

let mk_setcc_base cond rd k =
  match cond with
  | Cond_base c -> Cons ((Psetcc (c, rd)), k)
  | Cond_or (c1, c2) ->
    (match ireg_eq rd EAX with
     | Left ->
       Cons ((Psetcc (c1, EAX)), (Cons ((Psetcc (c2, ECX)), (Cons ((Por_rr
         (EAX, ECX)), k)))))
     | Right ->
       Cons ((Psetcc (c1, EAX)), (Cons ((Psetcc (c2, rd)), (Cons ((Por_rr
         (rd, EAX)), k))))))
  | Cond_and (c1, c2) ->
    (match ireg_eq rd EAX with
     | Left ->
       Cons ((Psetcc (c1, EAX)), (Cons ((Psetcc (c2, ECX)), (Cons ((Pand_rr
         (EAX, ECX)), k)))))
     | Right ->
       Cons ((Psetcc (c1, EAX)), (Cons ((Psetcc (c2, rd)), (Cons ((Pand_rr
         (rd, EAX)), k))))))

(** val mk_setcc : extcond -> ireg -> code3 -> instruction3 list **)

let mk_setcc cond rd k =
  match low_ireg rd with
  | True -> mk_setcc_base cond rd k
  | False -> mk_setcc_base cond EAX (Cons ((Pmov_rr (rd, EAX)), k))

(** val mk_jcc : extcond -> label4 -> code3 -> instruction3 list **)

let mk_jcc cond lbl k =
  match cond with
  | Cond_base c -> Cons ((Pjcc (c, lbl)), k)
  | Cond_or (c1, c2) -> Cons ((Pjcc (c1, lbl)), (Cons ((Pjcc (c2, lbl)), k)))
  | Cond_and (c1, c2) -> Cons ((Pjcc2 (c1, c2, lbl)), k)

(** val transl_op0 : operation -> mreg list -> mreg -> code3 -> code3 res **)

let transl_op0 op args res2 k =
  match op with
  | Omove ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil -> mk_mov (preg_of res2) (preg_of a1) k
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ointconst1 n0 ->
    (match args with
     | Nil ->
       bind (ireg_of res2) (fun r -> OK (Cons
         ((match Int.eq_dec n0 Int.zero with
           | Left -> Pxor_r r
           | Right -> Pmov_ri (r, n0)), k)))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))
  | Ofloatconst1 f ->
    (match args with
     | Nil ->
       bind (freg_of res2) (fun r -> OK (Cons
         ((match Float.eq_dec f Float.zero with
           | Left -> Pxorpd_f r
           | Right -> Pmovsd_fi (r, f)), k)))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))
  | Osingleconst1 f ->
    (match args with
     | Nil ->
       bind (freg_of res2) (fun r -> OK (Cons
         ((match Float32.eq_dec f Float32.zero with
           | Left -> Pxorps_f r
           | Right -> Pmovss_fi (r, f)), k)))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))
  | Oindirectsymbol id ->
    (match args with
     | Nil -> bind (ireg_of res2) (fun r -> OK (Cons ((Pmov_ra (r, id)), k)))
     | Cons (m0, l) ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString))))))))))))))))))))))))))))))))))
  | Ocast8signed0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 ->
            bind (ireg_of res2) (fun r ->
              mk_intconv (fun x x0 -> Pmovsb_rr (x, x0)) r r1 k))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ocast8unsigned0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 ->
            bind (ireg_of res2) (fun r ->
              mk_intconv (fun x x0 -> Pmovzb_rr (x, x0)) r r1 k))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ocast16signed0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 ->
            bind (ireg_of res2) (fun r ->
              mk_intconv (fun x x0 -> Pmovsw_rr (x, x0)) r r1 k))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ocast16unsigned0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of a1) (fun r1 ->
            bind (ireg_of res2) (fun r ->
              mk_intconv (fun x x0 -> Pmovzw_rr (x, x0)) r r1 k))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oneg0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (ireg_of res2) (fun r -> OK (Cons ((Pneg r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Osub1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Psub_rr (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omul1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Pimul_rr (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omulimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Pimul_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Omulhs ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq res2 DX with
                 | Left ->
                   bind (ireg_of a2) (fun r2 -> OK (Cons ((Pimul_r r2), k)))
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omulhu ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq res2 DX with
                 | Left ->
                   bind (ireg_of a2) (fun r2 -> OK (Cons ((Pmul_r r2), k)))
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Odiv1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   (match mreg_eq res2 AX with
                    | Left -> OK (Cons ((Pidiv ECX), k))
                    | Right -> assertion_failed)
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Odivu0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   (match mreg_eq res2 AX with
                    | Left -> OK (Cons ((Pdiv ECX), k))
                    | Right -> assertion_failed)
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omod1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   (match mreg_eq res2 DX with
                    | Left -> OK (Cons ((Pidiv ECX), k))
                    | Right -> assertion_failed)
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omodu0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 AX with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   (match mreg_eq res2 DX with
                    | Left -> OK (Cons ((Pdiv ECX), k))
                    | Right -> assertion_failed)
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oand1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Pand_rr (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oandimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Pand_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oor1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Por_rr (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oorimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Por_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oxor1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Pxor_rr (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oxorimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Pxor_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Onot ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (ireg_of res2) (fun r -> OK (Cons ((Pnot r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oshl1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   bind (ireg_of res2) (fun r -> OK (Cons ((Psal_rcl r), k)))
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oshlimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Psal_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oshr1 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   bind (ireg_of res2) (fun r -> OK (Cons ((Psar_rcl r), k)))
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oshrimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Psar_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oshrximm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 AX with
           | Left ->
             (match mreg_eq res2 AX with
              | Left -> mk_shrximm n0 k
              | Right -> assertion_failed)
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oshru0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                (match mreg_eq a2 CX with
                 | Left ->
                   bind (ireg_of res2) (fun r -> OK (Cons ((Pshr_rcl r), k)))
                 | Right -> assertion_failed)
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Oshruimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Pshr_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ororimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left ->
             bind (ireg_of res2) (fun r -> OK (Cons ((Pror_ri (r, n0)), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oshldimm n0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (ireg_of res2) (fun r ->
                  bind (ireg_of a2) (fun r2 -> OK (Cons ((Pshld_ri (r, r2,
                    n0)), k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Olea addr ->
    bind (transl_addressing addr args) (fun am ->
      bind (ireg_of res2) (fun r -> OK (Cons ((Plea (r, am)), k))))
  | Onegf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (freg_of res2) (fun r -> OK (Cons ((Pnegd r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oabsf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (freg_of res2) (fun r -> OK (Cons ((Pabsd r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oaddf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Paddd_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Osubf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Psubd_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omulf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Pmuld_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Odivf0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Pdivd_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Onegfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (freg_of res2) (fun r -> OK (Cons ((Pnegs r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oabsfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          (match mreg_eq a1 res2 with
           | Left -> bind (freg_of res2) (fun r -> OK (Cons ((Pabss r), k)))
           | Right -> assertion_failed)
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Oaddfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Padds_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Osubfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Psubs_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Omulfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Pmuls_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Odivfs0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))
        | Cons (a2, l0) ->
          (match l0 with
           | Nil ->
             (match mreg_eq a1 res2 with
              | Left ->
                bind (freg_of res2) (fun r ->
                  bind (freg_of a2) (fun r2 -> OK (Cons ((Pdivs_ff (r, r2)),
                    k))))
              | Right -> assertion_failed)
           | Cons (m0, l1) ->
             Error
               (msg (String ((Ascii (True, False, False, False, False, False,
                 True, False)), (String ((Ascii (True, True, False, False,
                 True, True, True, False)), (String ((Ascii (True, False,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, True, False, False, True, True, False)),
                 (String ((Ascii (True, False, True, False, False, True,
                 True, False)), (String ((Ascii (False, True, True, True,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, False, False)), (String ((Ascii
                 (False, False, True, False, True, True, True, False)),
                 (String ((Ascii (False, True, False, False, True, True,
                 True, False)), (String ((Ascii (True, False, False, False,
                 False, True, True, False)), (String ((Ascii (False, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (True, True, False, False, True, True, True, False)),
                 (String ((Ascii (False, False, True, True, False, True,
                 True, False)), (String ((Ascii (True, True, True, True,
                 True, False, True, False)), (String ((Ascii (True, True,
                 True, True, False, True, True, False)), (String ((Ascii
                 (False, False, False, False, True, True, True, False)),
                 EmptyString))))))))))))))))))))))))))))))))))))
  | Osingleoffloat0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (freg_of res2) (fun r ->
            bind (freg_of a1) (fun r1 -> OK (Cons ((Pcvtsd2ss_ff (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ofloatofsingle0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (freg_of res2) (fun r ->
            bind (freg_of a1) (fun r1 -> OK (Cons ((Pcvtss2sd_ff (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ointoffloat0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of res2) (fun r ->
            bind (freg_of a1) (fun r1 -> OK (Cons ((Pcvttsd2si_rf (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ofloatofint0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (freg_of res2) (fun r ->
            bind (ireg_of a1) (fun r1 -> OK (Cons ((Pcvtsi2sd_fr (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ointofsingle0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (ireg_of res2) (fun r ->
            bind (freg_of a1) (fun r1 -> OK (Cons ((Pcvttss2si_rf (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Osingleofint0 ->
    (match args with
     | Nil ->
       Error
         (msg (String ((Ascii (True, False, False, False, False, False, True,
           False)), (String ((Ascii (True, True, False, False, True, True,
           True, False)), (String ((Ascii (True, False, True, True, False,
           True, True, False)), (String ((Ascii (True, True, True, False,
           False, True, True, False)), (String ((Ascii (True, False, True,
           False, False, True, True, False)), (String ((Ascii (False, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           True, True, True, False, True, False, False)), (String ((Ascii
           (False, False, True, False, True, True, True, False)), (String
           ((Ascii (False, True, False, False, True, True, True, False)),
           (String ((Ascii (True, False, False, False, False, True, True,
           False)), (String ((Ascii (False, True, True, True, False, True,
           True, False)), (String ((Ascii (True, True, False, False, True,
           True, True, False)), (String ((Ascii (False, False, True, True,
           False, True, True, False)), (String ((Ascii (True, True, True,
           True, True, False, True, False)), (String ((Ascii (True, True,
           True, True, False, True, True, False)), (String ((Ascii (False,
           False, False, False, True, True, True, False)),
           EmptyString)))))))))))))))))))))))))))))))))
     | Cons (a1, l) ->
       (match l with
        | Nil ->
          bind (freg_of res2) (fun r ->
            bind (ireg_of a1) (fun r1 -> OK (Cons ((Pcvtsi2ss_fr (r, r1)),
              k))))
        | Cons (m0, l0) ->
          Error
            (msg (String ((Ascii (True, False, False, False, False, False,
              True, False)), (String ((Ascii (True, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (False, True, True, True, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, False, False)),
              (String ((Ascii (False, False, True, False, True, True, True,
              False)), (String ((Ascii (False, True, False, False, True,
              True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, True, True, False, True, True, False)), (String ((Ascii
              (True, True, False, False, True, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (True, True, True, True, True, False, True,
              False)), (String ((Ascii (True, True, True, True, False, True,
              True, False)), (String ((Ascii (False, False, False, False,
              True, True, True, False)),
              EmptyString)))))))))))))))))))))))))))))))))))
  | Ocmp0 c ->
    bind (ireg_of res2) (fun r ->
      transl_cond c args (mk_setcc (testcond_for_condition c) r k))
  | _ ->
    Error
      (msg (String ((Ascii (True, False, False, False, False, False, True,
        False)), (String ((Ascii (True, True, False, False, True, True, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, True, True, False, False, True, True,
        False)), (String ((Ascii (True, False, True, False, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        False, False)), (String ((Ascii (False, False, True, False, True,
        True, True, False)), (String ((Ascii (False, True, False, False,
        True, True, True, False)), (String ((Ascii (True, False, False,
        False, False, True, True, False)), (String ((Ascii (False, True,
        True, True, False, True, True, False)), (String ((Ascii (True, True,
        False, False, True, True, True, False)), (String ((Ascii (False,
        False, True, True, False, True, True, False)), (String ((Ascii (True,
        True, True, True, True, False, True, False)), (String ((Ascii (True,
        True, True, True, False, True, True, False)), (String ((Ascii (False,
        False, False, False, True, True, True, False)),
        EmptyString)))))))))))))))))))))))))))))))))

(** val transl_load :
    memory_chunk -> addressing -> mreg list -> mreg -> code3 -> code3 res **)

let transl_load chunk addr args dest k =
  bind (transl_addressing addr args) (fun am ->
    match chunk with
    | Mint8signed ->
      bind (ireg_of dest) (fun r -> OK (Cons ((Pmovsb_rm (r, am)), k)))
    | Mint8unsigned ->
      bind (ireg_of dest) (fun r -> OK (Cons ((Pmovzb_rm (r, am)), k)))
    | Mint16signed ->
      bind (ireg_of dest) (fun r -> OK (Cons ((Pmovsw_rm (r, am)), k)))
    | Mint16unsigned ->
      bind (ireg_of dest) (fun r -> OK (Cons ((Pmovzw_rm (r, am)), k)))
    | Mint32 ->
      bind (ireg_of dest) (fun r -> OK (Cons ((Pmov_rm (r, am)), k)))
    | Mfloat32 ->
      bind (freg_of dest) (fun r -> OK (Cons ((Pmovss_fm (r, am)), k)))
    | Mfloat64 ->
      bind (freg_of dest) (fun r -> OK (Cons ((Pmovsd_fm (r, am)), k)))
    | _ ->
      Error
        (msg (String ((Ascii (True, False, False, False, False, False, True,
          False)), (String ((Ascii (True, True, False, False, True, True,
          True, False)), (String ((Ascii (True, False, True, True, False,
          True, True, False)), (String ((Ascii (True, True, True, False,
          False, True, True, False)), (String ((Ascii (True, False, True,
          False, False, True, True, False)), (String ((Ascii (False, True,
          True, True, False, True, True, False)), (String ((Ascii (False,
          True, True, True, False, True, False, False)), (String ((Ascii
          (False, False, True, False, True, True, True, False)), (String
          ((Ascii (False, True, False, False, True, True, True, False)),
          (String ((Ascii (True, False, False, False, False, True, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (True, True, False, False, True,
          True, True, False)), (String ((Ascii (False, False, True, True,
          False, True, True, False)), (String ((Ascii (True, True, True,
          True, True, False, True, False)), (String ((Ascii (False, False,
          True, True, False, True, True, False)), (String ((Ascii (True,
          True, True, True, False, True, True, False)), (String ((Ascii
          (True, False, False, False, False, True, True, False)), (String
          ((Ascii (False, False, True, False, False, True, True, False)),
          EmptyString))))))))))))))))))))))))))))))))))))))

(** val transl_store :
    memory_chunk -> addressing -> mreg list -> mreg -> code3 -> code3 res **)

let transl_store chunk addr args src k =
  bind (transl_addressing addr args) (fun am ->
    match chunk with
    | Mint8signed ->
      bind (ireg_of src) (fun r ->
        mk_smallstore (fun x x0 -> Pmovb_mr (x, x0)) am r k)
    | Mint8unsigned ->
      bind (ireg_of src) (fun r ->
        mk_smallstore (fun x x0 -> Pmovb_mr (x, x0)) am r k)
    | Mint16signed ->
      bind (ireg_of src) (fun r -> OK (Cons ((Pmovw_mr (am, r)), k)))
    | Mint16unsigned ->
      bind (ireg_of src) (fun r -> OK (Cons ((Pmovw_mr (am, r)), k)))
    | Mint32 ->
      bind (ireg_of src) (fun r -> OK (Cons ((Pmov_mr (am, r)), k)))
    | Mfloat32 ->
      bind (freg_of src) (fun r -> OK (Cons ((Pmovss_mf (am, r)), k)))
    | Mfloat64 ->
      bind (freg_of src) (fun r -> OK (Cons ((Pmovsd_mf (am, r)), k)))
    | _ ->
      Error
        (msg (String ((Ascii (True, False, False, False, False, False, True,
          False)), (String ((Ascii (True, True, False, False, True, True,
          True, False)), (String ((Ascii (True, False, True, True, False,
          True, True, False)), (String ((Ascii (True, True, True, False,
          False, True, True, False)), (String ((Ascii (True, False, True,
          False, False, True, True, False)), (String ((Ascii (False, True,
          True, True, False, True, True, False)), (String ((Ascii (False,
          True, True, True, False, True, False, False)), (String ((Ascii
          (False, False, True, False, True, True, True, False)), (String
          ((Ascii (False, True, False, False, True, True, True, False)),
          (String ((Ascii (True, False, False, False, False, True, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (True, True, False, False, True,
          True, True, False)), (String ((Ascii (False, False, True, True,
          False, True, True, False)), (String ((Ascii (True, True, True,
          True, True, False, True, False)), (String ((Ascii (True, True,
          False, False, True, True, True, False)), (String ((Ascii (False,
          False, True, False, True, True, True, False)), (String ((Ascii
          (True, True, True, True, False, True, True, False)), (String
          ((Ascii (False, True, False, False, True, True, True, False)),
          (String ((Ascii (True, False, True, False, False, True, True,
          False)), EmptyString))))))))))))))))))))))))))))))))))))))))

(** val transl_instr0 :
    function7 -> instruction2 -> bool -> code3 -> instruction3 list res **)

let transl_instr0 f i edx_is_parent k =
  match i with
  | Mgetstack (ofs, ty, dst) -> loadind ESP ofs ty dst k
  | Msetstack (src, ofs, ty) -> storeind src ESP ofs ty k
  | Mgetparam (ofs, ty, dst) ->
    (match edx_is_parent with
     | True -> loadind EDX ofs ty dst k
     | False ->
       bind (loadind EDX ofs ty dst k) (fun k1 ->
         loadind ESP f.fn_link_ofs Tint DX k1))
  | Mop (op, args, res2) -> transl_op0 op args res2 k
  | Mload (chunk, addr, args, dst) -> transl_load chunk addr args dst k
  | Mstore (chunk, addr, args, src) -> transl_store chunk addr args src k
  | Mcall (sig1, s) ->
    (match s with
     | Inl reg0 ->
       bind (ireg_of reg0) (fun r -> OK (Cons ((Pcall_r (r, sig1)), k)))
     | Inr symb -> OK (Cons ((Pcall_s (symb, sig1)), k)))
  | Mtailcall (sig1, s) ->
    (match s with
     | Inl reg0 ->
       bind (ireg_of reg0) (fun r -> OK (Cons ((Pfreeframe (f.fn_stacksize2,
         f.fn_retaddr_ofs, f.fn_link_ofs)), (Cons ((Pjmp_r (r, sig1)), k)))))
     | Inr symb ->
       OK (Cons ((Pfreeframe (f.fn_stacksize2, f.fn_retaddr_ofs,
         f.fn_link_ofs)), (Cons ((Pjmp_s (symb, sig1)), k)))))
  | Mbuiltin (ef, args, res2) ->
    OK (Cons ((Pbuiltin (ef, (map (map_builtin_arg preg_of) args),
      (map_builtin_res preg_of res2))), k))
  | Mlabel lbl -> OK (Cons ((Plabel lbl), k))
  | Mgoto lbl -> OK (Cons ((Pjmp_l lbl), k))
  | Mcond (cond, args, lbl) ->
    transl_cond cond args (mk_jcc (testcond_for_condition cond) lbl k)
  | Mjumptable (arg, tbl) ->
    bind (ireg_of arg) (fun r -> OK (Cons ((Pjmptbl (r, tbl)), k)))
  | Mreturn ->
    OK (Cons ((Pfreeframe (f.fn_stacksize2, f.fn_retaddr_ofs,
      f.fn_link_ofs)), (Cons (Pret, k))))

(** val it1_is_parent : bool -> instruction2 -> bool **)

let it1_is_parent before = function
| Msetstack (src, ofs, ty) -> before
| Mgetparam (ofs, ty, dst) -> negb (proj_sumbool (mreg_eq dst DX))
| _ -> False

(** val transl_code_rec :
    function7 -> instruction2 list -> bool -> (code3 -> code3 res) -> code3
    res **)

let rec transl_code_rec f il it1p k =
  match il with
  | Nil -> k Nil
  | Cons (i1, il') ->
    transl_code_rec f il' (it1_is_parent it1p i1) (fun c1 ->
      bind (transl_instr0 f i1 it1p c1) (fun c2 -> k c2))

(** val transl_code' :
    function7 -> instruction2 list -> bool -> code3 res **)

let transl_code' f il it1p =
  transl_code_rec f il it1p (fun c -> OK c)

(** val transl_function2 : function7 -> function8 res **)

let transl_function2 f =
  bind (transl_code' f f.fn_code2 True) (fun c -> OK { fn_sig6 = f.fn_sig5;
    fn_code3 = (Cons ((Pallocframe (f.fn_stacksize2, f.fn_retaddr_ofs,
    f.fn_link_ofs)), c)) })

(** val transf_function12 : function7 -> function8 res **)

let transf_function12 f =
  bind (transl_function2 f) (fun tf ->
    match zlt Int.max_unsigned (list_length_z tf.fn_code3) with
    | Left ->
      Error
        (msg (String ((Ascii (True, True, False, False, False, True, True,
          False)), (String ((Ascii (True, True, True, True, False, True,
          True, False)), (String ((Ascii (False, False, True, False, False,
          True, True, False)), (String ((Ascii (True, False, True, False,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)), (String ((Ascii (True, True,
          False, False, True, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (False, True, False, True, True, True, True, False)), (String
          ((Ascii (True, False, True, False, False, True, True, False)),
          (String ((Ascii (False, False, False, False, False, True, False,
          False)), (String ((Ascii (True, False, True, False, False, True,
          True, False)), (String ((Ascii (False, False, False, True, True,
          True, True, False)), (String ((Ascii (True, True, False, False,
          False, True, True, False)), (String ((Ascii (True, False, True,
          False, False, True, True, False)), (String ((Ascii (True, False,
          True, False, False, True, True, False)), (String ((Ascii (False,
          False, True, False, False, True, True, False)), (String ((Ascii
          (True, False, True, False, False, True, True, False)), (String
          ((Ascii (False, False, True, False, False, True, True, False)),
          EmptyString)))))))))))))))))))))))))))))))))))))
    | Right -> OK tf)

(** val transf_fundef12 : fundef7 -> fundef8 res **)

let transf_fundef12 f =
  transf_partial_fundef transf_function12 f

(** val transf_program11 : program7 -> program8 res **)

let transf_program11 p =
  transform_partial_program transf_fundef12 p

(** val print_Clight : program0 -> unit0 **)

let print_Clight =
  failwith "AXIOM TO BE REALIZED"

(** val print_Cminor : program1 -> unit0 **)

let print_Cminor =
  failwith "AXIOM TO BE REALIZED"

(** val print_RTL : z -> program4 -> unit0 **)

let print_RTL =
  failwith "AXIOM TO BE REALIZED"

(** val print_LTL : program5 -> unit0 **)

let print_LTL =
  failwith "AXIOM TO BE REALIZED"

(** val print_Mach : program7 -> unit0 **)

let print_Mach =
  failwith "AXIOM TO BE REALIZED"

(** val apply_total : 'a1 res -> ('a1 -> 'a2) -> 'a2 res **)

let apply_total x f =
  match x with
  | OK x1 -> OK (f x1)
  | Error msg0 -> Error msg0

(** val apply_partial : 'a1 res -> ('a1 -> 'a2 res) -> 'a2 res **)

let apply_partial x f =
  match x with
  | OK x1 -> f x1
  | Error msg0 -> Error msg0

(** val print : ('a1 -> unit0) -> 'a1 -> 'a1 **)

let print printer prog =
  prog

(** val time : string -> ('a1 -> 'a2) -> 'a1 -> 'a2 **)

let time name f =
  f

(** val total_if : (unit0 -> bool) -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)

let total_if flag f prog =
  match flag Tt with
  | True -> f prog
  | False -> prog

(** val partial_if :
    (unit0 -> bool) -> ('a1 -> 'a1 res) -> 'a1 -> 'a1 res **)

let partial_if flag f prog =
  match flag Tt with
  | True -> f prog
  | False -> OK prog

(** val transf_rtl_program : program4 -> program8 res **)

let transf_rtl_program f =
  apply_partial
    (apply_total
      (apply_partial
        (apply_partial
          (apply_total
            (apply_partial
              (apply_total
                (apply_total
                  (apply_partial
                    (apply_total
                      (apply_partial
                        (apply_total
                          (apply_partial
                            (apply_total
                              (apply_partial
                                (apply_total
                                  (apply_total
                                    (apply_total
                                      (apply_total
                                        (apply_total
                                          (apply_total
                                            (apply_total
                                              (apply_partial
                                                (apply_total
                                                  (apply_total
                                                    (apply_total (OK f)
                                                      (print (print_RTL Z0)))
                                                    (total_if optim_tailcalls
                                                      (time (String ((Ascii
                                                        (False, False, True,
                                                        False, True, False,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (True, False, False,
                                                        False, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (True, False, False,
                                                        True, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (False, False, True,
                                                        True, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (False, False, False,
                                                        False, False, True,
                                                        False, False)),
                                                        (String ((Ascii
                                                        (True, True, False,
                                                        False, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (True, False, False,
                                                        False, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (False, False, True,
                                                        True, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (False, False, True,
                                                        True, False, True,
                                                        True, False)),
                                                        (String ((Ascii
                                                        (True, True, False,
                                                        False, True, True,
                                                        True, False)),
                                                        EmptyString))))))))))))))))))))
                                                        transf_program0)))
                                                  (print
                                                    (print_RTL (Zpos XH))))
                                                (time (String ((Ascii (True,
                                                  False, False, True, False,
                                                  False, True, False)),
                                                  (String ((Ascii (False,
                                                  True, True, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (False,
                                                  False, True, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (True,
                                                  False, False, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (False,
                                                  True, True, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (True,
                                                  False, False, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (False,
                                                  True, True, True, False,
                                                  True, True, False)),
                                                  (String ((Ascii (True,
                                                  True, True, False, False,
                                                  True, True, False)),
                                                  EmptyString))))))))))))))))
                                                  transf_program1))
                                              (print
                                                (print_RTL (Zpos (XO XH)))))
                                            (time (String ((Ascii (False,
                                              True, False, False, True,
                                              False, True, False)), (String
                                              ((Ascii (True, False, True,
                                              False, False, True, True,
                                              False)), (String ((Ascii
                                              (False, True, True, True,
                                              False, True, True, False)),
                                              (String ((Ascii (True, False,
                                              True, False, True, True, True,
                                              False)), (String ((Ascii (True,
                                              False, True, True, False, True,
                                              True, False)), (String ((Ascii
                                              (False, True, False, False,
                                              False, True, True, False)),
                                              (String ((Ascii (True, False,
                                              True, False, False, True, True,
                                              False)), (String ((Ascii
                                              (False, True, False, False,
                                              True, True, True, False)),
                                              (String ((Ascii (True, False,
                                              False, True, False, True, True,
                                              False)), (String ((Ascii
                                              (False, True, True, True,
                                              False, True, True, False)),
                                              (String ((Ascii (True, True,
                                              True, False, False, True, True,
                                              False)),
                                              EmptyString))))))))))))))))))))))
                                              transf_program2))
                                          (print (print_RTL (Zpos (XI XH)))))
                                        (total_if optim_constprop
                                          (time (String ((Ascii (True, True,
                                            False, False, False, False, True,
                                            False)), (String ((Ascii (True,
                                            True, True, True, False, True,
                                            True, False)), (String ((Ascii
                                            (False, True, True, True, False,
                                            True, True, False)), (String
                                            ((Ascii (True, True, False,
                                            False, True, True, True, False)),
                                            (String ((Ascii (False, False,
                                            True, False, True, True, True,
                                            False)), (String ((Ascii (True,
                                            False, False, False, False, True,
                                            True, False)), (String ((Ascii
                                            (False, True, True, True, False,
                                            True, True, False)), (String
                                            ((Ascii (False, False, True,
                                            False, True, True, True, False)),
                                            (String ((Ascii (False, False,
                                            False, False, False, True, False,
                                            False)), (String ((Ascii (False,
                                            False, False, False, True, True,
                                            True, False)), (String ((Ascii
                                            (False, True, False, False, True,
                                            True, True, False)), (String
                                            ((Ascii (True, True, True, True,
                                            False, True, True, False)),
                                            (String ((Ascii (False, False,
                                            False, False, True, True, True,
                                            False)), (String ((Ascii (True,
                                            False, False, False, False, True,
                                            True, False)), (String ((Ascii
                                            (True, True, True, False, False,
                                            True, True, False)), (String
                                            ((Ascii (True, False, False,
                                            False, False, True, True,
                                            False)), (String ((Ascii (False,
                                            False, True, False, True, True,
                                            True, False)), (String ((Ascii
                                            (True, False, False, True, False,
                                            True, True, False)), (String
                                            ((Ascii (True, True, True, True,
                                            False, True, True, False)),
                                            (String ((Ascii (False, True,
                                            True, True, False, True, True,
                                            False)),
                                            EmptyString))))))))))))))))))))))))))))))))))))))))
                                            transf_program3)))
                                      (print (print_RTL (Zpos (XO (XO XH))))))
                                    (total_if optim_constprop
                                      (time (String ((Ascii (False, True,
                                        False, False, True, False, True,
                                        False)), (String ((Ascii (True,
                                        False, True, False, False, True,
                                        True, False)), (String ((Ascii
                                        (False, True, True, True, False,
                                        True, True, False)), (String ((Ascii
                                        (True, False, True, False, True,
                                        True, True, False)), (String ((Ascii
                                        (True, False, True, True, False,
                                        True, True, False)), (String ((Ascii
                                        (False, True, False, False, False,
                                        True, True, False)), (String ((Ascii
                                        (True, False, True, False, False,
                                        True, True, False)), (String ((Ascii
                                        (False, True, False, False, True,
                                        True, True, False)), (String ((Ascii
                                        (True, False, False, True, False,
                                        True, True, False)), (String ((Ascii
                                        (False, True, True, True, False,
                                        True, True, False)), (String ((Ascii
                                        (True, True, True, False, False,
                                        True, True, False)),
                                        EmptyString))))))))))))))))))))))
                                        transf_program2)))
                                  (print (print_RTL (Zpos (XI (XO XH))))))
                                (partial_if optim_CSE
                                  (time (String ((Ascii (True, True, False,
                                    False, False, False, True, False)),
                                    (String ((Ascii (True, True, False,
                                    False, True, False, True, False)),
                                    (String ((Ascii (True, False, True,
                                    False, False, False, True, False)),
                                    EmptyString)))))) transf_program4)))
                              (print (print_RTL (Zpos (XO (XI XH))))))
                            (partial_if optim_redundancy
                              (time (String ((Ascii (False, True, False,
                                False, True, False, True, False)), (String
                                ((Ascii (True, False, True, False, False,
                                True, True, False)), (String ((Ascii (False,
                                False, True, False, False, True, True,
                                False)), (String ((Ascii (True, False, True,
                                False, True, True, True, False)), (String
                                ((Ascii (False, True, True, True, False,
                                True, True, False)), (String ((Ascii (False,
                                False, True, False, False, True, True,
                                False)), (String ((Ascii (True, False, False,
                                False, False, True, True, False)), (String
                                ((Ascii (False, True, True, True, False,
                                True, True, False)), (String ((Ascii (True,
                                True, False, False, False, True, True,
                                False)), (String ((Ascii (True, False, False,
                                True, True, True, True, False)), (String
                                ((Ascii (False, False, False, False, False,
                                True, False, False)), (String ((Ascii (True,
                                False, True, False, False, True, True,
                                False)), (String ((Ascii (False, False, True,
                                True, False, True, True, False)), (String
                                ((Ascii (True, False, False, True, False,
                                True, True, False)), (String ((Ascii (True,
                                False, True, True, False, True, True,
                                False)), (String ((Ascii (True, False, False,
                                True, False, True, True, False)), (String
                                ((Ascii (False, True, True, True, False,
                                True, True, False)), (String ((Ascii (True,
                                False, False, False, False, True, True,
                                False)), (String ((Ascii (False, False, True,
                                False, True, True, True, False)), (String
                                ((Ascii (True, False, False, True, False,
                                True, True, False)), (String ((Ascii (True,
                                True, True, True, False, True, True, False)),
                                (String ((Ascii (False, True, True, True,
                                False, True, True, False)),
                                EmptyString))))))))))))))))))))))))))))))))))))))))))))
                                transf_program5)))
                          (print (print_RTL (Zpos (XI (XI XH))))))
                        (time (String ((Ascii (True, False, True, False,
                          True, False, True, False)), (String ((Ascii (False,
                          True, True, True, False, True, True, False)),
                          (String ((Ascii (True, False, True, False, True,
                          True, True, False)), (String ((Ascii (True, True,
                          False, False, True, True, True, False)), (String
                          ((Ascii (True, False, True, False, False, True,
                          True, False)), (String ((Ascii (False, False, True,
                          False, False, True, True, False)), (String ((Ascii
                          (False, False, False, False, False, True, False,
                          False)), (String ((Ascii (True, True, True, False,
                          False, True, True, False)), (String ((Ascii (False,
                          False, True, True, False, True, True, False)),
                          (String ((Ascii (True, True, True, True, False,
                          True, True, False)), (String ((Ascii (False, True,
                          False, False, False, True, True, False)), (String
                          ((Ascii (True, False, False, False, False, True,
                          True, False)), (String ((Ascii (False, False, True,
                          True, False, True, True, False)), (String ((Ascii
                          (True, True, False, False, True, True, True,
                          False)), EmptyString))))))))))))))))))))))))))))
                          transform_program0))
                      (print (print_RTL (Zpos (XO (XO (XO XH)))))))
                    (time (String ((Ascii (False, True, False, False, True,
                      False, True, False)), (String ((Ascii (True, False,
                      True, False, False, True, True, False)), (String
                      ((Ascii (True, True, True, False, False, True, True,
                      False)), (String ((Ascii (True, False, False, True,
                      False, True, True, False)), (String ((Ascii (True,
                      True, False, False, True, True, True, False)), (String
                      ((Ascii (False, False, True, False, True, True, True,
                      False)), (String ((Ascii (True, False, True, False,
                      False, True, True, False)), (String ((Ascii (False,
                      True, False, False, True, True, True, False)), (String
                      ((Ascii (False, False, False, False, False, True,
                      False, False)), (String ((Ascii (True, False, False,
                      False, False, True, True, False)), (String ((Ascii
                      (False, False, True, True, False, True, True, False)),
                      (String ((Ascii (False, False, True, True, False, True,
                      True, False)), (String ((Ascii (True, True, True, True,
                      False, True, True, False)), (String ((Ascii (True,
                      True, False, False, False, True, True, False)), (String
                      ((Ascii (True, False, False, False, False, True, True,
                      False)), (String ((Ascii (False, False, True, False,
                      True, True, True, False)), (String ((Ascii (True,
                      False, False, True, False, True, True, False)), (String
                      ((Ascii (True, True, True, True, False, True, True,
                      False)), (String ((Ascii (False, True, True, True,
                      False, True, True, False)),
                      EmptyString))))))))))))))))))))))))))))))))))))))
                      transf_program6)) (print print_LTL))
                (time (String ((Ascii (False, True, False, False, False,
                  False, True, False)), (String ((Ascii (False, True, False,
                  False, True, True, True, False)), (String ((Ascii (True,
                  False, False, False, False, True, True, False)), (String
                  ((Ascii (False, True, True, True, False, True, True,
                  False)), (String ((Ascii (True, True, False, False, False,
                  True, True, False)), (String ((Ascii (False, False, False,
                  True, False, True, True, False)), (String ((Ascii (False,
                  False, False, False, False, True, False, False)), (String
                  ((Ascii (False, False, True, False, True, True, True,
                  False)), (String ((Ascii (True, False, True, False, True,
                  True, True, False)), (String ((Ascii (False, True, True,
                  True, False, True, True, False)), (String ((Ascii (False,
                  True, True, True, False, True, True, False)), (String
                  ((Ascii (True, False, True, False, False, True, True,
                  False)), (String ((Ascii (False, False, True, True, False,
                  True, True, False)), (String ((Ascii (True, False, False,
                  True, False, True, True, False)), (String ((Ascii (False,
                  True, True, True, False, True, True, False)), (String
                  ((Ascii (True, True, True, False, False, True, True,
                  False)), EmptyString))))))))))))))))))))))))))))))))
                  tunnel_program))
              (time (String ((Ascii (True, True, False, False, False, False,
                True, False)), (String ((Ascii (False, True, True, False,
                False, False, True, False)), (String ((Ascii (True, True,
                True, False, False, False, True, False)), (String ((Ascii
                (False, False, False, False, False, True, False, False)),
                (String ((Ascii (False, False, True, True, False, True, True,
                False)), (String ((Ascii (True, False, False, True, False,
                True, True, False)), (String ((Ascii (False, True, True,
                True, False, True, True, False)), (String ((Ascii (True,
                False, True, False, False, True, True, False)), (String
                ((Ascii (True, False, False, False, False, True, True,
                False)), (String ((Ascii (False, True, False, False, True,
                True, True, False)), (String ((Ascii (True, False, False,
                True, False, True, True, False)), (String ((Ascii (False,
                True, False, True, True, True, True, False)), (String ((Ascii
                (True, False, False, False, False, True, True, False)),
                (String ((Ascii (False, False, True, False, True, True, True,
                False)), (String ((Ascii (True, False, False, True, False,
                True, True, False)), (String ((Ascii (True, True, True, True,
                False, True, True, False)), (String ((Ascii (False, True,
                True, True, False, True, True, False)),
                EmptyString))))))))))))))))))))))))))))))))))
                transf_program7))
            (time (String ((Ascii (False, False, True, True, False, False,
              True, False)), (String ((Ascii (True, False, False, False,
              False, True, True, False)), (String ((Ascii (False, True,
              False, False, False, True, True, False)), (String ((Ascii
              (True, False, True, False, False, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (False, False, False, False, False, True,
              False, False)), (String ((Ascii (True, True, False, False,
              False, True, True, False)), (String ((Ascii (False, False,
              True, True, False, True, True, False)), (String ((Ascii (True,
              False, True, False, False, True, True, False)), (String ((Ascii
              (True, False, False, False, False, True, True, False)), (String
              ((Ascii (False, True, True, True, False, True, True, False)),
              (String ((Ascii (True, False, True, False, True, True, True,
              False)), (String ((Ascii (False, False, False, False, True,
              True, True, False)), EmptyString))))))))))))))))))))))))))
              transf_program8))
          (partial_if debug
            (time (String ((Ascii (False, False, True, False, False, False,
              True, False)), (String ((Ascii (True, False, True, False,
              False, True, True, False)), (String ((Ascii (False, True,
              False, False, False, True, True, False)), (String ((Ascii
              (True, False, True, False, True, True, True, False)), (String
              ((Ascii (True, True, True, False, False, True, True, False)),
              (String ((Ascii (True, True, True, False, False, True, True,
              False)), (String ((Ascii (True, False, False, True, False,
              True, True, False)), (String ((Ascii (False, True, True, True,
              False, True, True, False)), (String ((Ascii (True, True, True,
              False, False, True, True, False)), (String ((Ascii (False,
              False, False, False, False, True, False, False)), (String
              ((Ascii (True, False, False, True, False, True, True, False)),
              (String ((Ascii (False, True, True, True, False, True, True,
              False)), (String ((Ascii (False, True, True, False, False,
              True, True, False)), (String ((Ascii (True, True, True, True,
              False, True, True, False)), (String ((Ascii (False, False,
              False, False, False, True, False, False)), (String ((Ascii
              (False, True, True, False, False, True, True, False)), (String
              ((Ascii (True, True, True, True, False, True, True, False)),
              (String ((Ascii (False, True, False, False, True, True, True,
              False)), (String ((Ascii (False, False, False, False, False,
              True, False, False)), (String ((Ascii (False, False, True,
              True, False, True, True, False)), (String ((Ascii (True, True,
              True, True, False, True, True, False)), (String ((Ascii (True,
              True, False, False, False, True, True, False)), (String ((Ascii
              (True, False, False, False, False, True, True, False)), (String
              ((Ascii (False, False, True, True, False, True, True, False)),
              (String ((Ascii (False, False, False, False, False, True,
              False, False)), (String ((Ascii (False, True, True, False,
              True, True, True, False)), (String ((Ascii (True, False, False,
              False, False, True, True, False)), (String ((Ascii (False,
              True, False, False, True, True, True, False)), (String ((Ascii
              (True, False, False, True, False, True, True, False)), (String
              ((Ascii (True, False, False, False, False, True, True, False)),
              (String ((Ascii (False, True, False, False, False, True, True,
              False)), (String ((Ascii (False, False, True, True, False,
              True, True, False)), (String ((Ascii (True, False, True, False,
              False, True, True, False)), (String ((Ascii (True, True, False,
              False, True, True, True, False)),
              EmptyString))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
              transf_program9)))
        (time (String ((Ascii (True, False, True, True, False, False, True,
          False)), (String ((Ascii (True, False, False, False, False, True,
          True, False)), (String ((Ascii (True, True, False, False, False,
          True, True, False)), (String ((Ascii (False, False, False, True,
          False, True, True, False)), (String ((Ascii (False, False, False,
          False, False, True, False, False)), (String ((Ascii (True, True,
          True, False, False, True, True, False)), (String ((Ascii (True,
          False, True, False, False, True, True, False)), (String ((Ascii
          (False, True, True, True, False, True, True, False)), (String
          ((Ascii (True, False, True, False, False, True, True, False)),
          (String ((Ascii (False, True, False, False, True, True, True,
          False)), (String ((Ascii (True, False, False, False, False, True,
          True, False)), (String ((Ascii (False, False, True, False, True,
          True, True, False)), (String ((Ascii (True, False, False, True,
          False, True, True, False)), (String ((Ascii (True, True, True,
          True, False, True, True, False)), (String ((Ascii (False, True,
          True, True, False, True, True, False)),
          EmptyString)))))))))))))))))))))))))))))) transf_program10))
      (print print_Mach))
    (time (String ((Ascii (True, False, False, False, False, False, True,
      False)), (String ((Ascii (True, True, False, False, True, True, True,
      False)), (String ((Ascii (True, False, True, True, False, True, True,
      False)), (String ((Ascii (False, False, False, False, False, True,
      False, False)), (String ((Ascii (True, True, True, False, False, True,
      True, False)), (String ((Ascii (True, False, True, False, False, True,
      True, False)), (String ((Ascii (False, True, True, True, False, True,
      True, False)), (String ((Ascii (True, False, True, False, False, True,
      True, False)), (String ((Ascii (False, True, False, False, True, True,
      True, False)), (String ((Ascii (True, False, False, False, False, True,
      True, False)), (String ((Ascii (False, False, True, False, True, True,
      True, False)), (String ((Ascii (True, False, False, True, False, True,
      True, False)), (String ((Ascii (True, True, True, True, False, True,
      True, False)), (String ((Ascii (False, True, True, True, False, True,
      True, False)), EmptyString))))))))))))))))))))))))))))
      transf_program11)

(** val transf_cminor_program : program1 -> program8 res **)

let transf_cminor_program p =
  apply_partial
    (apply_partial
      (apply_partial (apply_total (OK p) (print print_Cminor))
        (time (String ((Ascii (True, False, False, True, False, False, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (True, True, False, False, True,
          True, True, False)), (String ((Ascii (False, False, True, False,
          True, True, True, False)), (String ((Ascii (False, True, False,
          False, True, True, True, False)), (String ((Ascii (True, False,
          True, False, True, True, True, False)), (String ((Ascii (True,
          True, False, False, False, True, True, False)), (String ((Ascii
          (False, False, True, False, True, True, True, False)), (String
          ((Ascii (True, False, False, True, False, True, True, False)),
          (String ((Ascii (True, True, True, True, False, True, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (False, False, False, False, False,
          True, False, False)), (String ((Ascii (True, True, False, False,
          True, True, True, False)), (String ((Ascii (True, False, True,
          False, False, True, True, False)), (String ((Ascii (False, False,
          True, True, False, True, True, False)), (String ((Ascii (True,
          False, True, False, False, True, True, False)), (String ((Ascii
          (True, True, False, False, False, True, True, False)), (String
          ((Ascii (False, False, True, False, True, True, True, False)),
          (String ((Ascii (True, False, False, True, False, True, True,
          False)), (String ((Ascii (True, True, True, True, False, True,
          True, False)), (String ((Ascii (False, True, True, True, False,
          True, True, False)),
          EmptyString)))))))))))))))))))))))))))))))))))))))))) sel_program))
      (time (String ((Ascii (False, True, False, False, True, False, True,
        False)), (String ((Ascii (False, False, True, False, True, False,
        True, False)), (String ((Ascii (False, False, True, True, False,
        False, True, False)), (String ((Ascii (False, False, False, False,
        False, True, False, False)), (String ((Ascii (True, True, True,
        False, False, True, True, False)), (String ((Ascii (True, False,
        True, False, False, True, True, False)), (String ((Ascii (False,
        True, True, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, True, False, False, True, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, False, True, True, True,
        False)), (String ((Ascii (True, False, False, True, False, True,
        True, False)), (String ((Ascii (True, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), EmptyString))))))))))))))))))))))))))))
        transl_program1)) transf_rtl_program

(** val transf_clight_program : program0 -> program8 res **)

let transf_clight_program p =
  apply_partial
    (apply_partial
      (apply_partial
        (apply_partial (apply_total (OK p) (print print_Clight))
          (time (String ((Ascii (True, True, False, False, True, False, True,
            False)), (String ((Ascii (True, False, False, True, False, True,
            True, False)), (String ((Ascii (True, False, True, True, False,
            True, True, False)), (String ((Ascii (False, False, False, False,
            True, True, True, False)), (String ((Ascii (False, False, True,
            True, False, True, True, False)), (String ((Ascii (True, False,
            False, True, False, True, True, False)), (String ((Ascii (False,
            True, True, False, False, True, True, False)), (String ((Ascii
            (True, False, False, True, False, True, True, False)), (String
            ((Ascii (True, True, False, False, False, True, True, False)),
            (String ((Ascii (True, False, False, False, False, True, True,
            False)), (String ((Ascii (False, False, True, False, True, True,
            True, False)), (String ((Ascii (True, False, False, True, False,
            True, True, False)), (String ((Ascii (True, True, True, True,
            False, True, True, False)), (String ((Ascii (False, True, True,
            True, False, True, True, False)), (String ((Ascii (False, False,
            False, False, False, True, False, False)), (String ((Ascii (True,
            True, True, True, False, True, True, False)), (String ((Ascii
            (False, True, True, False, False, True, True, False)), (String
            ((Ascii (False, False, False, False, False, True, False, False)),
            (String ((Ascii (False, False, True, True, False, True, True,
            False)), (String ((Ascii (True, True, True, True, False, True,
            True, False)), (String ((Ascii (True, True, False, False, False,
            True, True, False)), (String ((Ascii (True, False, False, False,
            False, True, True, False)), (String ((Ascii (False, False, True,
            True, False, True, True, False)), (String ((Ascii (True, True,
            False, False, True, True, True, False)),
            EmptyString))))))))))))))))))))))))))))))))))))))))))))))))
            transf_program))
        (time (String ((Ascii (True, True, False, False, False, False, True,
          False)), (String ((Ascii (True, True, False, False, False, True,
          False, False)), (String ((Ascii (True, False, True, True, False,
          True, True, False)), (String ((Ascii (True, False, False, True,
          False, True, True, False)), (String ((Ascii (False, True, True,
          True, False, True, True, False)), (String ((Ascii (True, True,
          True, True, False, True, True, False)), (String ((Ascii (False,
          True, False, False, True, True, True, False)), (String ((Ascii
          (False, False, False, False, False, True, False, False)), (String
          ((Ascii (True, True, True, False, False, True, True, False)),
          (String ((Ascii (True, False, True, False, False, True, True,
          False)), (String ((Ascii (False, True, True, True, False, True,
          True, False)), (String ((Ascii (True, False, True, False, False,
          True, True, False)), (String ((Ascii (False, True, False, False,
          True, True, True, False)), (String ((Ascii (True, False, False,
          False, False, True, True, False)), (String ((Ascii (False, False,
          True, False, True, True, True, False)), (String ((Ascii (True,
          False, False, True, False, True, True, False)), (String ((Ascii
          (True, True, True, True, False, True, True, False)), (String
          ((Ascii (False, True, True, True, False, True, True, False)),
          EmptyString)))))))))))))))))))))))))))))))))))) transl_program))
      (time (String ((Ascii (True, True, False, False, False, False, True,
        False)), (String ((Ascii (True, False, True, True, False, True, True,
        False)), (String ((Ascii (True, False, False, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), (String ((Ascii (True, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, False, False, True,
        True, True, False)), (String ((Ascii (False, False, False, False,
        False, True, False, False)), (String ((Ascii (True, True, True,
        False, False, True, True, False)), (String ((Ascii (True, False,
        True, False, False, True, True, False)), (String ((Ascii (False,
        True, True, True, False, True, True, False)), (String ((Ascii (True,
        False, True, False, False, True, True, False)), (String ((Ascii
        (False, True, False, False, True, True, True, False)), (String
        ((Ascii (True, False, False, False, False, True, True, False)),
        (String ((Ascii (False, False, True, False, True, True, True,
        False)), (String ((Ascii (True, False, False, True, False, True,
        True, False)), (String ((Ascii (True, True, True, True, False, True,
        True, False)), (String ((Ascii (False, True, True, True, False, True,
        True, False)), EmptyString))))))))))))))))))))))))))))))))))
        transl_program0)) transf_cminor_program

type expr3 =
| Econst_int0 of Int.int
| Ebinop2 of binary_operation * expr3 * expr3 * type0
| Econd of expr3 * expr3 * expr3 * type0
| Ecall of expr3 * expr3 * type0
| Evar3 of ident

type function9 = { fn_return0 : type0; fn_params4 : (ident, type0) prod list;
                   fn_body3 : expr3 }

(** val fn_return0 : function9 -> type0 **)

let fn_return0 x = x.fn_return0

(** val fn_params4 : function9 -> (ident, type0) prod list **)

let fn_params4 x = x.fn_params4

(** val fn_body3 : function9 -> expr3 **)

let fn_body3 x = x.fn_body3

type fundef9 =
  function9
  (* singleton inductive, whose constructor was Internal *)

type program9 = { prog_defs1 : (ident, (fundef9, type0) globdef) prod list;
                  prog_public1 : ident list; prog_main1 : ident;
                  prog_types0 : composite_definition list;
                  prog_comp_env0 : composite_env }

(** val prog_defs1 :
    program9 -> (ident, (fundef9, type0) globdef) prod list **)

let prog_defs1 x = x.prog_defs1

(** val prog_public1 : program9 -> ident list **)

let prog_public1 x = x.prog_public1

(** val prog_main1 : program9 -> ident **)

let prog_main1 x = x.prog_main1

(** val prog_types0 : program9 -> composite_definition list **)

let prog_types0 x = x.prog_types0

(** val prog_comp_env0 : program9 -> composite_env **)

let prog_comp_env0 x = x.prog_comp_env0

(** val typ0 : type0 **)

let typ0 =
  Tint0 (I32, Unsigned, { attr_volatile = False; attr_alignas = None })

(** val stmt_list_to_stmt : statement list -> statement **)

let rec stmt_list_to_stmt = function
| Nil -> Sskip
| Cons (f, r) ->
  (match r with
   | Nil -> f
   | Cons (s, l0) -> Ssequence (f, (stmt_list_to_stmt r)))

(** val transf_expr :
    expr3 -> positive -> ((statement list, expr) prod, positive) prod **)

let rec transf_expr e tmp =
  match e with
  | Econst_int0 i -> Pair ((Pair (Nil, (Econst_int (i, typ0)))), tmp)
  | Ebinop2 (op, l, r, t1) ->
    let Pair (lstlex, tmp1) = transf_expr l tmp in
    let Pair (lst, lex) = lstlex in
    let Pair (rstrex, tmp2) = transf_expr r tmp1 in
    let Pair (rst, rex) = rstrex in
    Pair ((Pair ((app lst rst), (Ebinop (op, lex, rex, t1)))), tmp2)
  | Econd (cond, t1, f, typ1) ->
    let Pair (p, tmp1) = transf_expr cond tmp in
    let Pair (clist, cexpr) = p in
    let Pair (p0, tmp2) = transf_expr t1 tmp1 in
    let Pair (tlist, texpr) = p0 in
    let Pair (p1, tmp3) = transf_expr f tmp2 in
    let Pair (flist, fexpr) = p1 in
    let tbranch =
      stmt_list_to_stmt (app tlist (Cons ((Sset (tmp3, texpr)), Nil)))
    in
    let fbranch =
      stmt_list_to_stmt (app tlist (Cons ((Sset (tmp3, fexpr)), Nil)))
    in
    Pair ((Pair
    ((app clist (Cons ((Sifthenelse (cexpr, tbranch, fbranch)), Nil))),
    (Etempvar (tmp3, typ1)))), (Coq_Pos.succ tmp3))
  | Ecall (fn, arg, typ1) ->
    let Pair (p, tmp1) = transf_expr fn tmp in
    let Pair (fnst, fnexp) = p in
    let Pair (p0, tmp2) = transf_expr arg tmp1 in
    let Pair (argst, argexp) = p0 in
    Pair ((Pair
    ((app fnst
       (app argst (Cons ((Scall ((Some tmp2), fnexp, (Cons (argexp, Nil)))),
         Nil)))), (Etempvar (tmp2, typ1)))), (Coq_Pos.succ tmp2))
  | Evar3 id -> Pair ((Pair (Nil, (Evar (id, typ0)))), tmp)

(** val transf_function13 : function9 -> function0 **)

let transf_function13 f =
  let Pair (p, p0) = transf_expr f.fn_body3 (XI (XI (XI (XO (XI XH))))) in
  let Pair (stmts, exp) = p in
  { fn_return = f.fn_return0; fn_callconv = { cc_vararg = False; cc_unproto =
  False; cc_structret = False }; fn_params = f.fn_params4; fn_vars = Nil;
  fn_temps = Nil; fn_body =
  (stmt_list_to_stmt (app stmts (Cons ((Sreturn (Some exp)), Nil)))) }

(** val transf_fundef13 : fundef9 -> fundef0 **)

let transf_fundef13 f =
  Internal0 (transf_function13 f)

(** val transf_idg :
    (ident, (fundef9, type0) globdef) prod -> (ident, (fundef0, type0)
    globdef) prod **)

let transf_idg = function
| Pair (id, g) ->
  (match g with
   | Gfun f -> Pair (id, (Gfun (transf_fundef13 f)))
   | Gvar v -> Pair (id, (Gvar v)))

(** val transf_program12 : program9 -> program0 **)

let transf_program12 p =
  { prog_defs0 = (map transf_idg p.prog_defs1); prog_public0 =
    p.prog_public1; prog_main0 = p.prog_main1; prog_types = p.prog_types0;
    prog_comp_env = p.prog_comp_env0 }

(** val fib_name : ident **)

let fib_name =
  XO XH

(** val t0 : type0 **)

let t0 =
  Tint0 (I32, Unsigned, { attr_volatile = False; attr_alignas = None })

(** val xm : z -> expr3 **)

let xm i =
  Ebinop2 (Osub, (Evar3 XH), (Econst_int0 (Int.repr i)), t0)

(** val call_fib : expr3 -> expr3 **)

let call_fib arg =
  Ecall ((Evar3 fib_name), arg, t0)

(** val fib_body : expr3 **)

let fib_body =
  Econd ((Ebinop2 (Olt, (Evar3 XH), (Econst_int0 (Int.repr (Zpos (XO XH)))),
    t0)), (Evar3 XH), (Ebinop2 (Oadd, (call_fib (xm (Zpos XH))),
    (call_fib (xm (Zpos (XO XH)))), t0)), t0)

(** val fib : function9 **)

let fib =
  { fn_return0 = t0; fn_params4 = (Cons ((Pair (XH, t0)), Nil)); fn_body3 =
    fib_body }

(** val fib_prog : program9 **)

let fib_prog =
  { prog_defs1 = (Cons ((Pair (fib_name, (Gfun fib))), Nil)); prog_public1 =
    Nil; prog_main1 = (XI XH); prog_types0 = Nil; prog_comp_env0 =
    PTree.empty }

(** val transf_program_to_asm : program9 -> program8 res **)

let transf_program_to_asm x =
  transf_clight_program (transf_program12 x)

(** val transf_fib : program8 res **)

let transf_fib =
  transf_program_to_asm fib_prog


let _ =
  let oc = open_out "fib.S" in
  let asm = 
    match transf_fib with
    | Errors.OK asm -> asm
    | Errors.Error msg ->
       eprintf "%s: %a" sourcename print_error msg;
       exit 2 in
  PrintAsm.print_program oc asm None;
  close_out oc
